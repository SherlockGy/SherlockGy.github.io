<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SherlockGy&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-26T16:27:02.210Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>SherlockGy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java多线程学习笔记</title>
    <link href="http://yoursite.com/2020/07/27/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/07/27/Java多线程学习笔记/</id>
    <published>2020-07-26T16:04:26.000Z</published>
    <updated>2020-07-26T16:27:02.210Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java多线程学习笔记"><a href="#Java多线程学习笔记" class="headerlink" title="Java多线程学习笔记"></a>Java多线程学习笔记</h1><p>CAS</p><p>compare and swap，比较并且交换，同compare and exchange</p><p> <img src="../work/笔记/imgs/image-20200726215411185.png" alt="image-20200726215411185" style="zoom:50%;"></p><p>CAS可以在没有加锁的情况下，保值多线程的一致性。</p><p>如何解决ABA问题：</p><ol><li>加版本号</li><li>使用一个bool类型作标记</li><li>没有影响的话，可以不考虑此问题</li></ol><p>CAS如何实现的</p><p>hotspot源码，cpp内，调用了汇编指令cmpxchg，如果是多核CPU，还需要lock</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock cmpxchg 指令</span><br></pre></td></tr></table></figure><p>所以，<code>cmpxchg</code>本身是非原子性的</p><p>硬件：</p><p>lock指令在执行后面的时候锁定一个<code>北桥信号</code>，不采用锁总线的方式</p><hr><p>对象在内存中的布局</p><p>new Object()在内存占多少字节</p><p>使用Open JDK的工具JOL（Java Object Layout），Maven导入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br></pre></td></tr></table></figure><p>  输出：</p><p><img src="../work/笔记/imgs/image-20200726222016355.png" alt="image-20200726222016355" style="zoom:50%;"></p><p>对象在内存中的布局：</p><p><img src="../work/笔记/imgs/image-20200726222735685.png" alt="image-20200726222735685" style="zoom:50%;"></p><p>普通对象说明：</p><ul><li>markword + 指针类型，加起来是对象头</li><li>关于锁（synchronized）的信息都存在markword中</li><li>指针类型指向所属的类</li><li>实例数据存的是成员变量</li><li>对齐是保证对象内存大小可以被8整除，使得总线读取更快</li></ul><p>查看Java命令行参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -XX:+PrintCommandLineFlags -version</span></span><br><span class="line"></span><br><span class="line">-XX:G1ConcRefinementThreads=4 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=134217728 -XX:MaxHeapSize=2147483648 -XX:MinHeapSize=6815736 -XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC</span><br><span class="line">java version "14" 2020-03-17</span><br><span class="line">Java(TM) SE Runtime Environment (build 14+36-1461)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 14+36-1461, mixed mode)</span><br></pre></td></tr></table></figure><p>对<code>new Object()</code>内存布局的解释：</p><ul><li>前两行：合计是markword，共8字节</li><li>第三行，指针，指向类，4字节（补充：64位系统指针应该是8字节，但是被ClassPoniter压缩至4字节）</li><li>第四行：补齐，由于不能被8整除，补齐4字节，即loss due to the next… </li><li>由于没有成员变量，实例数据部分0字节</li></ul><p>面试题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object o = new Object();在内存中占有多少字节？ -- 顺丰</span><br></pre></td></tr></table></figure><p>答：管理synchronized等信息的markword 8字节；如果开启了ClassPointer的压缩，类型指针占4字节；成员变量没有，所以0字节；合计12字节，由于不能被8整除，补齐至16字节。如果没有开启ClassPointer的压缩，类型指针占8个，那么就正好16字节，不需要补齐。</p><hr><p>分析这段代码的内存布局，和之前的<code>new Object()</code>作个对比：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(o) &#123;</span><br><span class="line">    System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="../work/笔记/imgs/image-20200726225404529.png" alt="image-20200726225404529" style="zoom:50%;"></p><p>注意第一行value的区别，说明锁信息是保存在对象的markword内的。</p><hr><p>锁升级：</p><p>new - 偏向锁 - 轻量级锁（无锁 == 自旋锁、自适应自旋）- 重量级锁</p><p><img src="../work/笔记/imgs/image-20200726233046984.png" alt="image-20200726233046984" style="zoom:50%;"></p><p>由上图可知，<code>锁状态</code>、<code>GC标记</code>、<code>分代年龄</code>都是存在对象的markword的8字节内的</p><p>分代年龄：</p><p>每次GC，如果对象没有被回收，则分代年龄+1，达到一定值（PS+PO GC默认15; CMS GC默认6），则对象从年轻代到老年代</p><p><strong>注意：</strong></p><p>由于分代年龄是4bit表示的，最大值是1111（二进制），即1 + 2 + 4 + 8 = 15，所以将值调到大于15是没有用的</p><p>自旋锁进一步升级的条件：</p><ol><li>有线程自旋超过10次</li><li>在自旋的线程超过总核数的1/2</li></ol><p>自适应自旋锁可以自动调整以上的两个值</p><hr><p>用户态和内核态</p><p>用户态：ring3 应用程序大多跑着用户态</p><p>内核态：ring0 申请锁需要在内核态进行</p><p>在内核态申请到锁之后，线程会进入一个阻塞的队列，wait的线程不消耗资源，区别于自旋锁依赖频繁的CAS会消耗大量CPU资源</p><hr><p>锁降级：</p><p>锁降级只存在在GC的时候，其他线程已经不持有锁，只发生在VMThread访问的时候，所以没意义，一般认为不存在降级</p><hr><p>锁消除</p><p>举例说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(str1).append(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：</p><p>虽然<code>StringBuffer</code>是线程安全的，即<code>append()</code>方法是被synchronized修饰的，但是在本add方法内，锁会被消除。原因是，sb是局部变量而不是成员变量（栈私有），不可能存在竞争，所以sb对象的锁会被JVM消除。</p><hr><p>锁粗化</p><p>举例说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">100</span>) &#123;</span><br><span class="line">        sb.append(str);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：</p><p>JVM检测到一连串对同一对象的加锁和解锁，JVM会粗化加锁范围，使得锁只需要加1次。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java多线程学习笔记&quot;&gt;&lt;a href=&quot;#Java多线程学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Java多线程学习笔记&quot;&gt;&lt;/a&gt;Java多线程学习笔记&lt;/h1&gt;&lt;p&gt;CAS&lt;/p&gt;
&lt;p&gt;compare and swap，比较并且交换
      
    
    </summary>
    
      <category term="程序人生" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Java/"/>
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Java/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="锁机制" scheme="http://yoursite.com/tags/%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>浅聊企业文化——读《浪潮之巅》有感</title>
    <link href="http://yoursite.com/2020/05/25/%E6%B5%85%E8%81%8A%E4%BC%81%E4%B8%9A%E6%96%87%E5%8C%96%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85%E3%80%8B%E6%9C%89%E6%84%9F/"/>
    <id>http://yoursite.com/2020/05/25/浅聊企业文化——读《浪潮之巅》有感/</id>
    <published>2020-05-24T17:18:15.000Z</published>
    <updated>2020-05-24T17:33:42.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在《浪潮之巅》第四版的下册中（原《硅谷之谜》），开篇第一章即是《挑战者——Google公司》。讨论Google总会给年轻人一种充满热血的感觉，因为这家企业确实是非常硅谷，非常叛逆。</p><a id="more"></a><p>它和其他的IT领域的大企业不同，不同于传统的IBM靠硬件设备赚钱；也不同于Microsoft和Oracle靠卖软件；Google几乎全部收入都来自于广告，也正是这样，Google才能始终贯彻自身的<strong>工程师文化</strong>，Google愿意将大把资金投入到回报遥遥无期的<a href="https://x.company/" target="_blank" rel="noopener">Google X Lab</a>，去研发<code>Google Glass</code>和<code>Waymo</code>智能驾驶等未来项目。</p><blockquote><p><strong>X</strong>，前称为“<strong>Google X</strong>”，是一个谷歌公司运行的秘密实验室，位于加利福尼亚州旧金山湾区某处。</p><p>——维基百科</p></blockquote><p>据说在硅谷，<code>Uber</code>被称为一家996公司，而<code>Google</code>则是一家对员工无比关怀的”养老公司”。因为这些天才工程师们的目标是“改变世界”，而996并不能提升效率。所以Google的员工的工作氛围非常的轻松，如丰厚的零食和之前的20%time。</p><p>另一个说明Google重视自己员工的例子是“All-hands meeting”（每周全体员工和领导层一起交流的大会），虽然据说在2019年也已经被取消了，不过这就是后话了。</p><p>之前网络上甚至有些人使用“谷人希”（谷歌，人类的希望）来形容这家公司，虽然充满了些许夸张，但是确实可以看出在广大网民眼中，Google公司是创新金字塔顶端的存在，尤其是在Microsoft多年的封闭和百度的负面不断的背景下，Google的魔幻魅力吸引了大批崇拜者。</p><h2 id="Google与工程师文化"><a href="#Google与工程师文化" class="headerlink" title="Google与工程师文化"></a>Google与工程师文化</h2><blockquote><p>Google的很多特点，追根溯源都可以归结为工程师文化。</p></blockquote><p>吴军博士在《浪潮之巅》中分析称，不同的企业文化决定了他们的竞争优势和劣势。确实，Google的工程师文化为之吸纳了大量的人才，甚至是天才，尤其是在其早期阶段的时候。</p><p>拥有大量天才工程师的Google，几乎成为了开源界的灯塔，诸如V8、K8s这些改变行业和领域的软件都和Google的贡献密不可分。这也使Google获得了巨大的先发优势，没有人会想去取代V8，K8s也几乎是行业规范，还有其他一大批开源软件源自于Google的论文，如Hadoop。</p><p>但是一个公司的平均智商，总是会随着其体量不断增大而下降的，直到一个稳定线上。曾经的Google还没有如此庞大，以至于他们员工能够拥有20%的独立时间（如Go编程语言就是诞生于20%时间的业余项目）。随着平均智商的下降，Google的绝大部份员工的20%时间已经很难再创造出什么太有价值的东西。所以20%时间制度被取消可以认为是一种必然。当然，这肯定也和近几年Google单纯靠广告收入已经不再好过有关。</p><blockquote><p>连Google自己的员工创办的公司都不使用Google的云计算服务。</p></blockquote><p>相比于将顾客摆在第一位的Amazon，Google在企业服务方面显然是出了问题。Amazon虽然对待自己的员工抠门，但是AWS良好的服务却让他们的产品占据云计算市场的大半壁江山。</p><p>技术优势和天才工程师确实能够帮助Google称为科技行业的先锋，但是在云计算服务这个行业，Google的技术优势看起来比起Amazon并没有高出多少。在这样一个没有技术先发优势的情况下，显然重视客户服务的企业更容易获得市场。</p><p>通过Google的成与败，我们可以看到工程师文化确实如吴军博士说的，成为了Google的萧何，如今的Google，在云计算领域的对手有Microsoft和Amazon；在操作系统领域对手有Apple和Microsoft；在量子计算领域对手有IBM…无论何种方向，Google都难以找到10年前的技术统治地位，这或许也是为什么<code>All-hands meeting</code>会被取消吧，因为Google可能要重新在工程师的浪漫和客户服务之间，寻找新的平衡点了。</p><h2 id="由工程师文化而思考编程语言之争"><a href="#由工程师文化而思考编程语言之争" class="headerlink" title="由工程师文化而思考编程语言之争"></a>由工程师文化而思考编程语言之争</h2><blockquote><p>编程语言只有两种，被人骂的和没人用的。</p></blockquote><p>确实在社区里面看到的对<code>JavaScript</code>的批评太多了，由于历史原因，js的早期版本存在大量的设计问题，直到如今也没有被全部解决。当然，这也为<code>TypeScript</code>的崛起提供了契机。</p><p>但是无论js被如何骂，谁也改变不了的事实就是，js已经成为了事实上的全栈“全能”语言。从web前端到服务端，从移动端到游戏，js已经处处可见了。</p><p>从工程师文化来说的话，有无数语言的设计比js更“优雅”，但是他们只能要么成为小众领域的选择，要么干脆成为玩具……</p><p>即是对比<code>Python</code>和<code>Ruby</code>这两个非常相似的语言也可以得出一样的结论，无论<code>Ruby</code>是不是一款能让程序员”快乐”的语言，他都不能改变他市场占有率不断走低，而Py如日中天的事实。</p><h2 id="产品经理-or-顾客至上"><a href="#产品经理-or-顾客至上" class="headerlink" title="产品经理 or 顾客至上"></a>产品经理 or 顾客至上</h2><blockquote><p>如果當初我去問顧客到底想要什麼，他們會回答說要一匹跑得更快的馬。——福特汽车创始人：亨利‧福特</p></blockquote><p>吴军博士大致将企业文化分为如下几种，且一个公司很难同时拥有多种企业文化，因为无法兼顾：</p><ul><li>工程师文化，代表是：Google、Microsoft、华为</li><li>产品经理文化，代表是：Apple、FaceBook、腾讯</li><li>销售文化，代表是：亚马逊、阿里巴巴</li></ul><p>而按照三方利益分类，则是这样：</p><ul><li>员工利益，代表是：星巴克、Google、腾讯</li><li>消费者利益，代表是：亚马逊、阿里巴巴</li><li>投资人利益，代表如巴菲特投资的一系列企业</li></ul><p>个人则倾向于，在产品的设计方面，保持自己的核心审美，而不是一味讨好客户，因为客户口味总是不一样的，没有清晰的产品定位，一味听从客户意见，注定搞出四不像。</p><p>正如Go语言创始人之一，<code>Rob Pike</code>所说，Go语言的最大成就就是始终保证了对最初方向对坚持。仅从这个意义上说的话，他达成了他的使命——纠正C++，因为现代C++已经复杂到诸多行业精英都嫌弃了。。。</p><p>所以，顾客至上，应该是服务上的至上，而在提供什么样的产品上，产品经理应该保持独立的思考，而不是一味地询问你的顾客。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在《浪潮之巅》第四版的下册中（原《硅谷之谜》），开篇第一章即是《挑战者——Google公司》。讨论Google总会给年轻人一种充满热血的感觉，因为这家企业确实是非常硅谷，非常叛逆。&lt;/p&gt;
    
    </summary>
    
      <category term="感悟" scheme="http://yoursite.com/categories/%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="感悟" scheme="http://yoursite.com/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="读后感" scheme="http://yoursite.com/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>Java有意思的现象——执行注释后的代码</title>
    <link href="http://yoursite.com/2020/05/08/Java%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%8E%B0%E8%B1%A1%E2%80%94%E2%80%94%E6%89%A7%E8%A1%8C%E6%B3%A8%E9%87%8A%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2020/05/08/Java有意思的现象——执行注释后的代码/</id>
    <published>2020-05-07T17:42:45.000Z</published>
    <updated>2020-05-07T17:56:10.603Z</updated>
    
    <content type="html"><![CDATA[<p>今天看到这样一个有意思的图片，给大家分享下：</p><p><img src="https://SherlockGy.github.io/img/image-20200508014429297.png" alt="image-20200508014429297" style="zoom:50%;"></p><p>问题来了，为什么代码里面已经被注释的部分也可以执行呢？</p><a id="more"></a><p>其实也很简单，查一下<code>\u000d</code>是个啥玩意就行了，果不其然，这个代表<code>回车（CR：Return）</code>；而另一个类似的<code>\u000a</code>则是<code>换行（LF：Line Feed）</code>。其实也就是<code>\r</code>和<code>\n</code>啦。</p><p>而Java在解析代码的时候，是会按照Unicode编码去解析，而不是把它当作字符串。因此，注释自然是无效啦～</p><hr><p>额外试了下其他语言，这个用法在<code>Go</code>、<code>Python</code>、<code>Nim</code>等语言中并不可以哦！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天看到这样一个有意思的图片，给大家分享下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://SherlockGy.github.io/img/image-20200508014429297.png&quot; alt=&quot;image-20200508014429297&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;问题来了，为什么代码里面已经被注释的部分也可以执行呢？&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Java/"/>
    
    
      <category term="技巧" scheme="http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="趣事" scheme="http://yoursite.com/tags/%E8%B6%A3%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>HHKB使用心得</title>
    <link href="http://yoursite.com/2020/05/07/HHKB%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <id>http://yoursite.com/2020/05/07/HHKB使用心得/</id>
    <published>2020-05-07T15:06:27.000Z</published>
    <updated>2020-05-07T15:22:12.606Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要是在使用HHKB键盘的过程中的一些心得和技巧，属于不定期追加内容的形式</p><a id="more"></a><h2 id="大小写切换"><a href="#大小写切换" class="headerlink" title="大小写切换"></a>大小写切换</h2><p>很多Mac用户应该知道，如果我们使Mac的原生键盘的话，可以很方便地使用<code>Caps Lock</code>键来切换中英文。</p><p>但是由于HHKB键盘帮我们非常友好地把这个键给优化没了，所以我们只有两个选择了：</p><ul><li>使用软件改键</li><li>使用默认的替换按键</li></ul><p>其实HHKB并没有删除这个键的功能，可以通过<code>fn</code> + <code>tab</code>键的方式来起到相同的效果</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要是在使用HHKB键盘的过程中的一些心得和技巧，属于不定期追加内容的形式&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="外设" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E5%A4%96%E8%AE%BE/"/>
    
    
      <category term="HHKB" scheme="http://yoursite.com/tags/HHKB/"/>
    
      <category term="键盘" scheme="http://yoursite.com/tags/%E9%94%AE%E7%9B%98/"/>
    
      <category term="外设" scheme="http://yoursite.com/tags/%E5%A4%96%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>Go实现最简单的超时控制</title>
    <link href="http://yoursite.com/2020/05/07/Go%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2020/05/07/Go实现最简单的超时控制/</id>
    <published>2020-05-07T14:37:15.000Z</published>
    <updated>2020-05-07T14:38:47.854Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">&#125;(ch)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ch:</span><br><span class="line">fmt.Println(<span class="string">"ok"</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">5</span>):</span><br><span class="line">fmt.Println(<span class="string">"time out"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;time&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ch := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ch &lt;span class=&quot;keyword&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		time.Sleep(time.Second * &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		ch &amp;lt;- &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;(ch)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &amp;lt;-ch:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;ok&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &amp;lt;-time.After(time.Second * &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;time out&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="Golang" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Golang/"/>
    
    
      <category term="Golang" scheme="http://yoursite.com/tags/Golang/"/>
    
      <category term="示例代码" scheme="http://yoursite.com/tags/%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Go实现最简单的在线视频播放</title>
    <link href="http://yoursite.com/2020/04/28/Go%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%9C%A8%E7%BA%BF%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/"/>
    <id>http://yoursite.com/2020/04/28/Go实现最简单的在线视频播放/</id>
    <published>2020-04-27T17:26:38.000Z</published>
    <updated>2020-04-27T17:27:26.165Z</updated>
    
    <content type="html"><![CDATA[<p>如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">video</span><span class="params">(response http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">response.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"video/mp4"</span>)</span><br><span class="line">file, err := os.Open(<span class="string">"/Users/sherlockgy/Downloads/1.mp4"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">"文件打开异常..."</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">http.ServeContent(response, request, <span class="string">"test"</span>, time.Now(), file)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/video"</span>, video)         <span class="comment">// 设置访问的路由</span></span><br><span class="line">err := http.ListenAndServe(<span class="string">":9090"</span>, <span class="literal">nil</span>) <span class="comment">// 设置监听的端口</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如下：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;log&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;net/http&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;os&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;time&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;video&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(response http.ResponseWriter, request *http.Request)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	response.Header().Set(&lt;span class=&quot;string&quot;&gt;&quot;Content-Type&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;video/mp4&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	file, err := os.Open(&lt;span class=&quot;string&quot;&gt;&quot;/Users/sherlockgy/Downloads/1.mp4&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		log.Println(&lt;span class=&quot;string&quot;&gt;&quot;文件打开异常...&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	http.ServeContent(response, request, &lt;span class=&quot;string&quot;&gt;&quot;test&quot;&lt;/span&gt;, time.Now(), file)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;defer&lt;/span&gt; file.Close()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	http.HandleFunc(&lt;span class=&quot;string&quot;&gt;&quot;/video&quot;&lt;/span&gt;, video)         &lt;span class=&quot;comment&quot;&gt;// 设置访问的路由&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	err := http.ListenAndServe(&lt;span class=&quot;string&quot;&gt;&quot;:9090&quot;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// 设置监听的端口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		log.Fatal(&lt;span class=&quot;string&quot;&gt;&quot;ListenAndServe: &quot;&lt;/span&gt;, err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="Golang" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Golang/"/>
    
    
      <category term="Golang" scheme="http://yoursite.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/04/22/%E4%BD%BF%E7%94%A8ZK%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E5%8D%95%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://yoursite.com/2020/04/22/使用ZK实现最简单分布式锁/</id>
    <published>2020-04-22T13:04:06.953Z</published>
    <updated>2020-04-22T13:05:26.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用ZK实现最简单分布式锁"><a href="#使用ZK实现最简单分布式锁" class="headerlink" title="使用ZK实现最简单分布式锁"></a>使用ZK实现最简单分布式锁</h1><p>分布式锁也是ZK的常见应用场景。我们可以利用其临时节点来实现分布式锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用ZK实现最简单分布式锁&quot;&gt;&lt;a href=&quot;#使用ZK实现最简单分布式锁&quot; class=&quot;headerlink&quot; title=&quot;使用ZK实现最简单分布式锁&quot;&gt;&lt;/a&gt;使用ZK实现最简单分布式锁&lt;/h1&gt;&lt;p&gt;分布式锁也是ZK的常见应用场景。我们可以利用其临时节
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/04/18/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/04/18/云原生学习笔记/</id>
    <published>2020-04-18T10:14:28.557Z</published>
    <updated>2020-05-07T17:57:10.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="云原生学习笔记"><a href="#云原生学习笔记" class="headerlink" title="云原生学习笔记"></a>云原生学习笔记</h1><p> [TOC]</p><h2 id="一、技术发展历史"><a href="#一、技术发展历史" class="headerlink" title="一、技术发展历史"></a>一、技术发展历史</h2><ul><li>2004～2007：Google大规模使用容器（cgroups）技术</li><li>2008.01：cgroups技术合并进Linux主干，为容器化打下基础</li><li>2013.03：Docker项目正式发布</li><li>2014.06：Kubernetes项目发布</li><li>2015.07：CNCF（云原生基金会）成立，22个创始成员，Kubernetes成为第一个CNCF项目</li><li>2017.07：CNCF成立2周年，170个会员，14个基金会项目</li><li>2018.07：CNCF成立3周年，195个会员，19个基金会项目，11个孵化项目</li></ul><h2 id="二、云原生的定义"><a href="#二、云原生的定义" class="headerlink" title="二、云原生的定义"></a>二、云原生的定义</h2><p>容器技术的革命性类似于<code>集装箱</code>的革命性。</p><p>容器技术可以使应用以<code>自包含</code>的方式定义，从而更敏捷、可拓展、可复制。</p><p>云原生是一条最佳路径（最佳实践）。这条路径能：</p><ul><li>低心智负担的、</li><li>敏捷的、</li><li>以可拓展、可复制的方式</li></ul><p>最大化地利用云的能力，发挥最大价值。</p><p>容器技术就是云原生技术的核心底盘。</p><h2 id="三、云原生思想的两个理论基础"><a href="#三、云原生思想的两个理论基础" class="headerlink" title="三、云原生思想的两个理论基础"></a>三、云原生思想的两个理论基础</h2><h3 id="1-不可变基础设施"><a href="#1-不可变基础设施" class="headerlink" title="1. 不可变基础设施"></a>1. 不可变基础设施</h3><p>目前实现：容器镜像</p><p>解释：我们的跑应用的基础设施应该是==不可变==的，是自包含、自描述且可以随时迁移的。</p><h4 id="基础设施向云演进的过程"><a href="#基础设施向云演进的过程" class="headerlink" title="基础设施向云演进的过程"></a>基础设施向云演进的过程</h4><p><strong>传统应用的基础设施：</strong></p><p>可变，如SSH连接到服务器，手动升级或降级软件包，逐个服务器调整配置文件，新代码直接部署到现有服务器上</p><p><strong>对云友好的应用基础设施：</strong></p><p>不可变，如部署完成之后基础设施不会被修改。如需更新，则更改公共镜像构建新服务以替换旧服务。验证后，新服务投入使用，旧服务退役。</p><h3 id="2-云应用编排理论"><a href="#2-云应用编排理论" class="headerlink" title="2. 云应用编排理论"></a>2. 云应用编排理论</h3><p>目前实现：容器设计模式（Google提出）</p><h2 id="四、容器与镜像"><a href="#四、容器与镜像" class="headerlink" title="四、容器与镜像"></a>四、容器与镜像</h2><p>容器与普通的操作系统进程，有什么区别呢？</p><p><img src="https://SherlockGy.github.io/img/image-20200418213049729.png" alt="image-20200418213049729"></p><p>由于进程是共享同一份文件系统，导致权限较高的进程会影响到权限较低的进程的文件操作，形成相互干扰；</p><p>由于进程和进程间的依赖可能存在冲突，会给运维带来压力；</p><p>由于进程间使用同样的宿主机的资源，存在资源抢占，权限低的进程可能会因为抢占不到资源而无法提供服务。</p><h3 id="什么是容器？"><a href="#什么是容器？" class="headerlink" title="什么是容器？"></a>什么是容器？</h3><p>容器，是一个视图隔离、资源可限制、独立文件系统的进程集合。</p><ul><li>视图隔离 - 如能看见其他进程；独立主机名等等</li><li>控制资源使用率 - 如2G内存大小；CPU使用个数等等</li></ul><h3 id="什么是镜像？"><a href="#什么是镜像？" class="headerlink" title="什么是镜像？"></a>什么是镜像？</h3><p>运行容器所需要的所有文件的集合，就是容器镜像</p><p>Dockerfile - 描述镜像构建步骤</p><p>构建步骤所产生出文件系统的变化 - changeset</p><ul><li>类似disk snapshot</li><li>提高分发效率，减少磁盘压力</li></ul><h3 id="容器的生命周期"><a href="#容器的生命周期" class="headerlink" title="容器的生命周期"></a>容器的生命周期</h3><h4 id="单进程模型"><a href="#单进程模型" class="headerlink" title="单进程模型"></a>单进程模型</h4><ol><li>init进程的生命周期 = 容器的生命周期</li><li>运行期间可以执行exec执行运维操作，exec进程也归init进程管理，当init进程退出，其管理的其他进程皆退出</li></ol><h4 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h4><ol><li>独立于容器的生命周期</li><li>数据卷 - docker volume vs bind</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;云原生学习笔记&quot;&gt;&lt;a href=&quot;#云原生学习笔记&quot; class=&quot;headerlink&quot; title=&quot;云原生学习笔记&quot;&gt;&lt;/a&gt;云原生学习笔记&lt;/h1&gt;&lt;p&gt; [TOC]&lt;/p&gt;
&lt;h2 id=&quot;一、技术发展历史&quot;&gt;&lt;a href=&quot;#一、技术发展历史&quot; c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Golang与UTF-8</title>
    <link href="http://yoursite.com/2020/04/17/Golang%E4%B8%8EUTF-8/"/>
    <id>http://yoursite.com/2020/04/17/Golang与UTF-8/</id>
    <published>2020-04-16T18:04:15.000Z</published>
    <updated>2020-04-16T18:05:20.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang与UTF-8"><a href="#Golang与UTF-8" class="headerlink" title="Golang与UTF-8"></a>Golang与UTF-8</h1><p>我们在浏览器抓包的时候，有时候会发现类似这样的一串字符串：</p><blockquote><p>\350\241\250\346\203\205</p></blockquote><p>当然我们都知道这多半是<code>UTF-8</code>表示的汉字。那么在Go语言当中，我们要怎么转换他们呢？</p><p>这里直接贴一下代码，以作记录。</p><p><strong>注意：</strong>这里的数字其实是<code>8进制</code>表示的！</p><a id="more"></a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 将这样的8进制表示的UTF-8字符串恢复成可读状态</span></span><br><span class="line">str := <span class="string">"\350\241\250\346\203\205"</span></span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, str) <span class="comment">// out：表情</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用range遍历“表情”，会发现一个汉字就对应一个编码</span></span><br><span class="line">str2 := <span class="string">"表情"</span></span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> str2 &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%o "</span>, c) <span class="comment">// 104150 60305</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用fori遍历“表情”，每个汉字对应3个数字，正好和上面的一串字符吻合</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str2); i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%o "</span>, str2[i])</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println() <span class="comment">// 350 241 250 346 203 205 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Golang与UTF-8&quot;&gt;&lt;a href=&quot;#Golang与UTF-8&quot; class=&quot;headerlink&quot; title=&quot;Golang与UTF-8&quot;&gt;&lt;/a&gt;Golang与UTF-8&lt;/h1&gt;&lt;p&gt;我们在浏览器抓包的时候，有时候会发现类似这样的一串字符串：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;\350\241\250\346\203\205&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然我们都知道这多半是&lt;code&gt;UTF-8&lt;/code&gt;表示的汉字。那么在Go语言当中，我们要怎么转换他们呢？&lt;/p&gt;
&lt;p&gt;这里直接贴一下代码，以作记录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;这里的数字其实是&lt;code&gt;8进制&lt;/code&gt;表示的！&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="Golang" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Golang/"/>
    
    
      <category term="Golang" scheme="http://yoursite.com/tags/Golang/"/>
    
      <category term="编码" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A0%81/"/>
    
      <category term="UTF-8" scheme="http://yoursite.com/tags/UTF-8/"/>
    
      <category term="技巧" scheme="http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>给macOS的访达（Finder）配置快捷键快速启动</title>
    <link href="http://yoursite.com/2020/04/16/%E7%BB%99macOS%E7%9A%84%E8%AE%BF%E8%BE%BE%EF%BC%88Finder%EF%BC%89%E9%85%8D%E7%BD%AE%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8/"/>
    <id>http://yoursite.com/2020/04/16/给macOS的访达（Finder）配置快捷键快速启动/</id>
    <published>2020-04-15T17:22:59.000Z</published>
    <updated>2020-04-15T17:31:10.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="给macOS的访达（Finder）配置快捷键快速启动"><a href="#给macOS的访达（Finder）配置快捷键快速启动" class="headerlink" title="给macOS的访达（Finder）配置快捷键快速启动"></a>给macOS的访达（Finder）配置快捷键快速启动</h1><p>[TOC]</p><h2 id="第一步，配置自动操作指令"><a href="#第一步，配置自动操作指令" class="headerlink" title="第一步，配置自动操作指令"></a>第一步，配置自动操作指令</h2><p>首先，打开macOS自带的这个小机器人工具：</p><p><img src="https://SherlockGy.github.io/img/image-20200416010727401.png" alt="image-20200416010727401"></p><p>然后点击<code>新建文稿</code>：</p><p><img src="https://SherlockGy.github.io/img/image-20200416010812552.png" alt="image-20200416010812552"></p><p>文稿类型选择<code>快速操作</code>：</p><p><img src="https://SherlockGy.github.io/img/image-20200416010848813.png" alt="image-20200416010848813"></p><p>选择<code>实用工具</code> -&gt; <code>开启应用程序</code>：</p><a id="more"></a><p><img src="https://SherlockGy.github.io/img/image-20200416011033107.png" alt="image-20200416011033107"></p><p>然后将开启应用程序拖拽进右侧。</p><p>将流程设置为如下参数，即：<code>没有输入</code>和<code>任何应用程序</code>：</p><p><img src="https://SherlockGy.github.io/img/image-20200416011126942.png" alt="image-20200416011126942"></p><p>在下面的开启应用程序中，选择<code>新建变量</code>，再点击<code>其他</code>：</p><p><img src="https://SherlockGy.github.io/img/image-20200416011328250.png" alt="image-20200416011328250"></p><p>然后选择<code>系统</code> -&gt; <code>资源库</code> -&gt; <code>coreServices</code> -&gt; <code>访达</code>：</p><p><img src="https://SherlockGy.github.io/img/image-20200416011605639.png" alt="image-20200416011605639"></p><p><img src="https://SherlockGy.github.io/img/image-20200416011632447.png" alt="image-20200416011632447"></p><p>至此，本步骤完成。可以把该指令起名为<code>快捷启动访达</code>，保存退出，以便后续配置快捷键。</p><h2 id="第二步，给指令添加快捷键"><a href="#第二步，给指令添加快捷键" class="headerlink" title="第二步，给指令添加快捷键"></a>第二步，给指令添加快捷键</h2><p>打开<code>系统偏好设置</code>中的<code>键盘</code>：</p><p><img src="https://SherlockGy.github.io/img/image-20200416011849665.png" alt="image-20200416011849665"></p><p>然后按下图配置快捷键即可：</p><p><img src="https://SherlockGy.github.io/img/image-20200416011927870.png" alt="image-20200416011927870"></p><p><strong>建议：</strong>不要配置太简单的快捷键，如：<code>command + E</code>，避免部分应用程序的快捷键会冲突，如：<code>Chrome</code></p><p><a href="https://www.youtube.com/watch?v=9tEvq-QJFlE" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;给macOS的访达（Finder）配置快捷键快速启动&quot;&gt;&lt;a href=&quot;#给macOS的访达（Finder）配置快捷键快速启动&quot; class=&quot;headerlink&quot; title=&quot;给macOS的访达（Finder）配置快捷键快速启动&quot;&gt;&lt;/a&gt;给macOS的访达（Finder）配置快捷键快速启动&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;第一步，配置自动操作指令&quot;&gt;&lt;a href=&quot;#第一步，配置自动操作指令&quot; class=&quot;headerlink&quot; title=&quot;第一步，配置自动操作指令&quot;&gt;&lt;/a&gt;第一步，配置自动操作指令&lt;/h2&gt;&lt;p&gt;首先，打开macOS自带的这个小机器人工具：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://SherlockGy.github.io/img/image-20200416010727401.png&quot; alt=&quot;image-20200416010727401&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后点击&lt;code&gt;新建文稿&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://SherlockGy.github.io/img/image-20200416010812552.png&quot; alt=&quot;image-20200416010812552&quot;&gt;&lt;/p&gt;
&lt;p&gt;文稿类型选择&lt;code&gt;快速操作&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://SherlockGy.github.io/img/image-20200416010848813.png&quot; alt=&quot;image-20200416010848813&quot;&gt;&lt;/p&gt;
&lt;p&gt;选择&lt;code&gt;实用工具&lt;/code&gt; -&amp;gt; &lt;code&gt;开启应用程序&lt;/code&gt;：&lt;/p&gt;
    
    </summary>
    
      <category term="技巧分享" scheme="http://yoursite.com/categories/%E6%8A%80%E5%B7%A7%E5%88%86%E4%BA%AB/"/>
    
      <category term="Mac" scheme="http://yoursite.com/categories/%E6%8A%80%E5%B7%A7%E5%88%86%E4%BA%AB/Mac/"/>
    
    
      <category term="技巧" scheme="http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Mac" scheme="http://yoursite.com/tags/Mac/"/>
    
      <category term="快捷键" scheme="http://yoursite.com/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>Golang单元测试</title>
    <link href="http://yoursite.com/2020/04/14/Golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2020/04/14/Golang单元测试/</id>
    <published>2020-04-14T05:20:09.000Z</published>
    <updated>2020-04-14T05:29:59.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang单元测试"><a href="#Golang单元测试" class="headerlink" title="Golang单元测试"></a>Golang单元测试</h1><p>[TOC]</p><h2 id="一、约定的条件"><a href="#一、约定的条件" class="headerlink" title="一、约定的条件"></a>一、约定的条件</h2><ol><li>包含单元测试的代码文件必须以<code>_test.go</code>结尾，否则测试框架并不会读区该文件作为测试代码。</li><li>单元测试文件名<code>_test.go</code>前面的部分建议是被测试的方法所在代码文件的文件名。</li><li>单元测试的函数名必须以<code>Test</code>开头，注意首字母是大写的。如果不满足则测试框架不会执行该函数。</li><li>函数名最好是Test+要测试的方法函数名，如<code>TestAdd</code>，表示测试的是<code>Add</code>这个这个函数。</li><li>测试函数的签名必须接收一个指向<code>testing.T</code>或<code>testing.B</code>类型的指针，且无返回值。</li></ol><h2 id="二、简单的样例"><a href="#二、简单的样例" class="headerlink" title="二、简单的样例"></a>二、简单的样例</h2><p>测试文件：test/demo_test.go</p><p>代码为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> result := Add(<span class="number">1</span>, <span class="number">2</span>); result != <span class="number">3</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">"测试Add函数报错，参数分别是%v and %v，返回结果为%v，期望是%v"</span>, <span class="number">1</span>, <span class="number">2</span>, result, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、如果对测试函数的执行顺序有要求"><a href="#三、如果对测试函数的执行顺序有要求" class="headerlink" title="三、如果对测试函数的执行顺序有要求"></a>三、如果对测试函数的执行顺序有要求</h2><blockquote><p>将单个测试用例的首字母小写，这样这个用例就不会被测试框架调用了</p><p>我们将测试方法传递给t的Run()方法，从而实现指定顺序执行单元测试</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testAdd1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> result := Add(<span class="number">1</span>, <span class="number">2</span>); result != <span class="number">3</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">"测试Add函数报错，参数分别是%v and %v，返回结果为%v，期望是%v"</span>, <span class="number">1</span>, <span class="number">2</span>, result, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testAdd2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> result := Add(<span class="number">3</span>, <span class="number">4</span>); result != <span class="number">7</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">"测试Add函数报错，参数分别是%v and %v，返回结果为%v，期望是%v"</span>, <span class="number">1</span>, <span class="number">2</span>, result, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">t.Run(<span class="string">"test1"</span>, testAdd1)</span><br><span class="line">t.Run(<span class="string">"test2"</span>, testAdd2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="四、测试开始前的统一初始化等操作"><a href="#四、测试开始前的统一初始化等操作" class="headerlink" title="四、测试开始前的统一初始化等操作"></a>四、测试开始前的统一初始化等操作</h2><p>如果我们需要在单元测试开始前进行统一的初始化操作，如：数据准备、连接数据库等，就需要用到<code>*testing.M</code>。</p><p>在现有用例的基础上增加这个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"统一初始化..."</span>)</span><br><span class="line">m.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、基准测试，测试性能–benchmark"><a href="#五、基准测试，测试性能–benchmark" class="headerlink" title="五、基准测试，测试性能–benchmark"></a>五、基准测试，测试性能–benchmark</h2><blockquote><ol><li>benchmark函数必须以Benchmark开头</li><li>benchmark的测试case一般会跑b.N次，并且每次执行都是这样</li><li>实际执行时，会调整b.N的次数，直到执行时间达到稳态</li><li>b.ResetTimer是重置计时器，这样可以避免for循环之前的初始化代码的干扰</li><li>被测试的代码要放到循环里</li><li>b.N是基准测试框架提供的，表示循环的次数，因为需要反复调用测试的代码，才可以评估性能</li></ol></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkPrint</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">Print()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以这样的方式进行执行</span></span><br><span class="line"><span class="comment"># .表示运行所有的基准测试</span></span><br><span class="line">go <span class="built_in">test</span> -bench=.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Golang单元测试&quot;&gt;&lt;a href=&quot;#Golang单元测试&quot; class=&quot;headerlink&quot; title=&quot;Golang单元测试&quot;&gt;&lt;/a&gt;Golang单元测试&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;一、约定的条件&quot;&gt;&lt;a href=&quot;#一、约定的条件&quot; class=&quot;headerlink&quot; title=&quot;一、约定的条件&quot;&gt;&lt;/a&gt;一、约定的条件&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;包含单元测试的代码文件必须以&lt;code&gt;_test.go&lt;/code&gt;结尾，否则测试框架并不会读区该文件作为测试代码。&lt;/li&gt;
&lt;li&gt;单元测试文件名&lt;code&gt;_test.go&lt;/code&gt;前面的部分建议是被测试的方法所在代码文件的文件名。&lt;/li&gt;
&lt;li&gt;单元测试的函数名必须以&lt;code&gt;Test&lt;/code&gt;开头，注意首字母是大写的。如果不满足则测试框架不会执行该函数。&lt;/li&gt;
&lt;li&gt;函数名最好是Test+要测试的方法函数名，如&lt;code&gt;TestAdd&lt;/code&gt;，表示测试的是&lt;code&gt;Add&lt;/code&gt;这个这个函数。&lt;/li&gt;
&lt;li&gt;测试函数的签名必须接收一个指向&lt;code&gt;testing.T&lt;/code&gt;或&lt;code&gt;testing.B&lt;/code&gt;类型的指针，且无返回值。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;二、简单的样例&quot;&gt;&lt;a href=&quot;#二、简单的样例&quot; class=&quot;headerlink&quot; title=&quot;二、简单的样例&quot;&gt;&lt;/a&gt;二、简单的样例&lt;/h2&gt;&lt;p&gt;测试文件：test/demo_test.go&lt;/p&gt;
&lt;p&gt;代码为：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; test&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;testing&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(a, b &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a + b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestAdd&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; result := Add(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;); result != &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		t.Errorf(&lt;span class=&quot;string&quot;&gt;&quot;测试Add函数报错，参数分别是%v and %v，返回结果为%v，期望是%v&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, result, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;三、如果对测试函数的执行顺序有要求&quot;&gt;&lt;a href=&quot;#三、如果对测试函数的执行顺序有要求&quot; class=&quot;headerlink&quot; title=&quot;三、如果对测试函数的执行顺序有要求&quot;&gt;&lt;/a&gt;三、如果对测试函数的执行顺序有要求&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;将单个测试用例的首字母小写，这样这个用例就不会被测试框架调用了&lt;/p&gt;
&lt;p&gt;我们将测试方法传递给t的Run()方法，从而实现指定顺序执行单元测试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; test&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;testing&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(a, b &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a + b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;testAdd1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; result := Add(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;); result != &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		t.Errorf(&lt;span class=&quot;string&quot;&gt;&quot;测试Add函数报错，参数分别是%v and %v，返回结果为%v，期望是%v&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, result, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;testAdd2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; result := Add(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;); result != &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		t.Errorf(&lt;span class=&quot;string&quot;&gt;&quot;测试Add函数报错，参数分别是%v and %v，返回结果为%v，期望是%v&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, result, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestAdd&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	t.Run(&lt;span class=&quot;string&quot;&gt;&quot;test1&quot;&lt;/span&gt;, testAdd1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	t.Run(&lt;span class=&quot;string&quot;&gt;&quot;test2&quot;&lt;/span&gt;, testAdd2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="Golang" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Golang/"/>
    
    
      <category term="Golang" scheme="http://yoursite.com/tags/Golang/"/>
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="测试" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>解决升级macOS catalina后VMware黑屏问题</title>
    <link href="http://yoursite.com/2020/02/15/%E8%A7%A3%E5%86%B3%E5%8D%87%E7%BA%A7MacOS%20catalina%E5%90%8EVMware%E9%BB%91%E5%B1%8F%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/02/15/解决升级MacOS catalina后VMware黑屏问题/</id>
    <published>2020-02-15T05:52:35.000Z</published>
    <updated>2020-02-15T06:14:35.528Z</updated>
    
    <content type="html"><![CDATA[<p><code>VMware</code>软件的Mac版本名为<code>VMware Fusion</code>，该软件在你的Mac电脑安装了目前最新的<code>macOS</code>系统：<code>catalina</code>后，会出现黑屏的问题，而当你挂起虚拟机后，又可以看到虚拟机画面。这是由于自从<code>catalina</code>版本开始，应用程序需要自主申请各项权限，而旧版的<code>VMware</code>并不会申请<strong>屏幕录制</strong>权限，这就导致了黑屏的问题。</p><p>要想解决该问题，有三种方法：</p><ol><li>将操作系统回退到之前版本，如果你有时间机器的备份，这应该比较容易</li><li>升级<code>VMware</code>，但是如果你是破解版，会出现破解失败，需要付费的情况</li><li>手动赋予<code>VMware</code>屏幕录制权限</li></ol><p>这里重点介绍如何手动赋予<code>VMware</code>屏幕录制权限：</p><a id="more"></a><h2 id="一、关闭MacOS的rootless机制"><a href="#一、关闭MacOS的rootless机制" class="headerlink" title="一、关闭MacOS的rootless机制"></a>一、关闭MacOS的rootless机制</h2><ol><li>重启你的Mac，同时在<strong>白色苹果logo</strong>弹出之前就按住<strong>command</strong>和<strong>r</strong>键</li><li>选择菜单（menu）上面的实用工具（Utilities），选择<strong>终端（Terminal）</strong></li><li>输入以下命令关闭rootless机制，然后重启Mac</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关闭rootless机制</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> csrutil <span class="built_in">disable</span></span></span><br></pre></td></tr></table></figure><h2 id="二、手动赋予VMware屏幕录制权限"><a href="#二、手动赋予VMware屏幕录制权限" class="headerlink" title="二、手动赋予VMware屏幕录制权限"></a>二、手动赋予<code>VMware</code>屏幕录制权限</h2><p>依次在终端键入以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tccutil reset All com.vmware.fusion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo sqlite3 <span class="string">"/Library/Application Support/com.apple.TCC/TCC.db"</span> <span class="string">'insert into access values ("kTCCServiceScreenCapture", "com.vmware.fusion", 0, 1, 1, "", "", "", "UNUSED", "", 0,1565595574)'</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo sqlite3 <span class="string">"/Library/Application Support/com.apple.TCC/TCC.db"</span> <span class="string">'insert into access values ("kTCCServiceListenEvent", "com.vmware.fusion", 0, 1, 1, "", "", "", "UNUSED", "", 0,1565595574)'</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo sqlite3 <span class="string">"/Library/Application Support/com.apple.TCC/TCC.db"</span> <span class="string">'insert into access values ("kTCCServicePostEvent", "com.vmware.fusion", 0, 1, 1, "", "", "", "UNUSED", "", 0,1565595574)'</span></span></span><br></pre></td></tr></table></figure><p>此时黑屏问题应该已经解决，可检查<strong>设置</strong> -&gt; <strong>安全性和隐私</strong> -&gt; <strong>屏幕录制权限</strong>是否赋予给了VMware。如问题依然存在，麻烦查询其他方案解决。</p><h2 id="三、重新打开rootless机制"><a href="#三、重新打开rootless机制" class="headerlink" title="三、重新打开rootless机制"></a>三、重新打开rootless机制</h2><ol><li>重启你的Mac，同时在<strong>白色苹果logo</strong>弹出之前就按住<strong>command</strong>和<strong>r</strong>键</li><li>选择菜单（menu）上面的实用工具（Utilities），选择<strong>终端（Terminal）</strong></li><li>输入以下命令启动rootless机制，然后重启Mac</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重新打开rootless机制</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> csrutil <span class="built_in">enable</span></span></span><br></pre></td></tr></table></figure><h2 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a>四、参考文章</h2><p><a href="https://www.cnblogs.com/pyyu/p/11663295.html" target="_blank" rel="noopener">文章1</a><br><a href="http://tonglei.org/%E8%A7%A3%E5%86%B3macos-catalina-%E5%8D%87%E7%BA%A7%E5%AF%BC%E8%87%B4vmware%E9%BB%91%E5%B1%8F%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">文章1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;VMware&lt;/code&gt;软件的Mac版本名为&lt;code&gt;VMware Fusion&lt;/code&gt;，该软件在你的Mac电脑安装了目前最新的&lt;code&gt;macOS&lt;/code&gt;系统：&lt;code&gt;catalina&lt;/code&gt;后，会出现黑屏的问题，而当你挂起虚拟机后，又可以看到虚拟机画面。这是由于自从&lt;code&gt;catalina&lt;/code&gt;版本开始，应用程序需要自主申请各项权限，而旧版的&lt;code&gt;VMware&lt;/code&gt;并不会申请&lt;strong&gt;屏幕录制&lt;/strong&gt;权限，这就导致了黑屏的问题。&lt;/p&gt;
&lt;p&gt;要想解决该问题，有三种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将操作系统回退到之前版本，如果你有时间机器的备份，这应该比较容易&lt;/li&gt;
&lt;li&gt;升级&lt;code&gt;VMware&lt;/code&gt;，但是如果你是破解版，会出现破解失败，需要付费的情况&lt;/li&gt;
&lt;li&gt;手动赋予&lt;code&gt;VMware&lt;/code&gt;屏幕录制权限&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里重点介绍如何手动赋予&lt;code&gt;VMware&lt;/code&gt;屏幕录制权限：&lt;/p&gt;
    
    </summary>
    
      <category term="技巧分享" scheme="http://yoursite.com/categories/%E6%8A%80%E5%B7%A7%E5%88%86%E4%BA%AB/"/>
    
      <category term="问题fix" scheme="http://yoursite.com/categories/%E6%8A%80%E5%B7%A7%E5%88%86%E4%BA%AB/%E9%97%AE%E9%A2%98fix/"/>
    
    
      <category term="Mac" scheme="http://yoursite.com/tags/Mac/"/>
    
      <category term="Fix" scheme="http://yoursite.com/tags/Fix/"/>
    
      <category term="虚拟机" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="VMware" scheme="http://yoursite.com/tags/VMware/"/>
    
  </entry>
  
  <entry>
    <title>Mac如何卸载旧版Java</title>
    <link href="http://yoursite.com/2020/02/09/Mac%E5%A6%82%E4%BD%95%E5%8D%B8%E8%BD%BD%E6%97%A7%E7%89%88Java/"/>
    <id>http://yoursite.com/2020/02/09/Mac如何卸载旧版Java/</id>
    <published>2020-02-09T07:10:17.000Z</published>
    <updated>2020-04-15T17:22:22.373Z</updated>
    
    <content type="html"><![CDATA[<p>卸载步骤：</p><ol><li>删除终端命令：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -fr /Library/Internet\ Plug-Ins/JavaAppletPlugin.plugin</span><br><span class="line">sudo rm -fr /Library/PreferencesPanes/JavaControlPanel.prefPane</span><br></pre></td></tr></table></figure><ol start="2"><li>删除JDK包</li></ol><p>先查看已安装了哪些版本的Java</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /Library/Java/JavaVirtualMachines/</span><br></pre></td></tr></table></figure><p>再进入目录，删除对应版本的Java</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /Library/Java/JavaVirtualMachines/</span><br><span class="line">sudo rm -rf jdk[_update].jdk</span><br></pre></td></tr></table></figure><ol start="3"><li>删除偏好设置面板图标</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -fr /Library/PreferencePanes/JavaControlPanel.prefPane</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;卸载步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;删除终端命令：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo rm -fr /Library/Internet\ Plug-Ins/JavaAppletPlugin.plugin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo rm -fr /Library/PreferencesPanes/JavaControlPanel.prefPane&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;删除JDK包&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;先查看已安装了哪些版本的Java&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ls /Library/Java/JavaVirtualMachines/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;再进入目录，删除对应版本的Java&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd /Library/Java/JavaVirtualMachines/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo rm -rf jdk[_update].jdk&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;删除偏好设置面板图标&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo rm -fr /Library/PreferencePanes/JavaControlPanel.prefPane&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="踩坑" scheme="http://yoursite.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="Mac" scheme="http://yoursite.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Java踩坑——Double类型转String变成了科学计数法怎么解决</title>
    <link href="http://yoursite.com/2019/11/28/Java%E8%B8%A9%E5%9D%91%E2%80%94%E2%80%94Double%E8%BD%ACString%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95/"/>
    <id>http://yoursite.com/2019/11/28/Java踩坑——Double转String如何避免科学计数法/</id>
    <published>2019-11-28T15:23:29.000Z</published>
    <updated>2019-11-28T16:01:08.263Z</updated>
    
    <content type="html"><![CDATA[<p>现在有一个场景,需要将一个<code>Double</code>类型的字段转换成字符串然后写入文件,不过在某些时候,数字会出现以科学计数法的形式来表示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> scale = <span class="number">0.0005</span>;</span><br><span class="line">System.out.println(String.valueOf(scale)); <span class="comment">// 5.0E-4</span></span><br><span class="line">System.out.println(scale + <span class="string">""</span>);            <span class="comment">// 5.0E-4</span></span><br><span class="line">System.out.println(scale);                 <span class="comment">// 5.0E-4</span></span><br></pre></td></tr></table></figure><p>如上,在尝试了几种容易想到的方法后,发现均不可行.后来经过搜索和更多次尝试,整理出几种方案:</p><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>使用<code>java.math</code>包的<code>BigDecimal</code>类.效果如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> scale = <span class="number">0.0005</span>;</span><br><span class="line">BigDecimal bigDecimal = <span class="keyword">new</span> BigDecimal(scale);</span><br><span class="line">System.out.println(bigDecimal); <span class="comment">// 0.0005000000000000000104083408558608425664715468883514404296875</span></span><br></pre></td></tr></table></figure><p>由于<code>BigDecimal</code>直接使用不符合我们对小数点后长度的需求,就需要使用<code>String.format()</code>的方式进行转换:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> scale = <span class="number">0.0005</span>;</span><br><span class="line">BigDecimal bigDecimal = <span class="keyword">new</span> BigDecimal(scale);</span><br><span class="line">System.out.println(String.format(<span class="string">"%.4f"</span>, bigDecimal)); <span class="comment">// 0.0005</span></span><br></pre></td></tr></table></figure><p>至此问题貌似是解决了,但是依然很不放心.主要原因在于这种方式还是有可能导致误差:毕竟本来我的数字就是标准的0.0005,而BigDecimal因为精度原因需要做截取.</p><p>虽然目前看似没有问题,但是如果出现BigDecimal将结果输出成:0.0004999999999999之类的怎么办呢?</p><p>这个时候又想到了四舍五入之类的方法,但是总感觉与真正的方法相去越来越远:这么简单的一个转换,不应该搞得这么复杂,于是有了方案二</p><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>这一次是使用<code>java.text</code>包下的<code>DecimalFormat</code>类,具体实现如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> scale = <span class="number">0.0005</span>;</span><br><span class="line">DecimalFormat decimalFormat = <span class="keyword">new</span> DecimalFormat(<span class="string">"#.####"</span>);</span><br><span class="line">System.out.println(decimalFormat.format(scale)); <span class="comment">// 0.0005</span></span><br></pre></td></tr></table></figure><h2 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h2><p>后来想起来,发现其实上面两种方法都是庸人自扰,属于脑子一下没转过弯来才会干的事…因为实际上问题可以非常简单地解决:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> scale = <span class="number">0.0005</span>;</span><br><span class="line">String scaleStr = String.format(<span class="string">"%.4f"</span>, scale);</span><br><span class="line">System.out.println(scaleStr); <span class="comment">// 0.0005</span></span><br></pre></td></tr></table></figure><p>好吧,果然这种问题的解决办法一定是非常简单的…</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在有一个场景,需要将一个&lt;code&gt;Double&lt;/code&gt;类型的字段转换成字符串然后写入文件,不过在某些时候,数字会出现以科学计数法的形式来表示:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; scale = &lt;span class=&quot;number&quot;&gt;0.0005&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(String.valueOf(scale)); &lt;span class=&quot;comment&quot;&gt;// 5.0E-4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(scale + &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;);            &lt;span class=&quot;comment&quot;&gt;// 5.0E-4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(scale);                 &lt;span class=&quot;comment&quot;&gt;// 5.0E-4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如上,在尝试了几种容易想到的方法后,发现均不可行.后来经过搜索和更多次尝试,整理出几种方案:&lt;/p&gt;
&lt;h2 id=&quot;方案一&quot;&gt;&lt;a href=&quot;#方案一&quot; class=&quot;headerlink&quot; title=&quot;方案一&quot;&gt;&lt;/a&gt;方案一&lt;/h2&gt;&lt;p&gt;使用&lt;code&gt;java.math&lt;/code&gt;包的&lt;code&gt;BigDecimal&lt;/code&gt;类.效果如下:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; scale = &lt;span class=&quot;number&quot;&gt;0.0005&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BigDecimal bigDecimal = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BigDecimal(scale);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(bigDecimal); &lt;span class=&quot;comment&quot;&gt;// 0.0005000000000000000104083408558608425664715468883514404296875&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于&lt;code&gt;BigDecimal&lt;/code&gt;直接使用不符合我们对小数点后长度的需求,就需要使用&lt;code&gt;String.format()&lt;/code&gt;的方式进行转换:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; scale = &lt;span class=&quot;number&quot;&gt;0.0005&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BigDecimal bigDecimal = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BigDecimal(scale);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(String.format(&lt;span class=&quot;string&quot;&gt;&quot;%.4f&quot;&lt;/span&gt;, bigDecimal)); &lt;span class=&quot;comment&quot;&gt;// 0.0005&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;至此问题貌似是解决了,但是依然很不放心.主要原因在于这种方式还是有可能导致误差:毕竟本来我的数字就是标准的0.0005,而BigDecimal因为精度原因需要做截取.&lt;/p&gt;
&lt;p&gt;虽然目前看似没有问题,但是如果出现BigDecimal将结果输出成:0.0004999999999999之类的怎么办呢?&lt;/p&gt;
&lt;p&gt;这个时候又想到了四舍五入之类的方法,但是总感觉与真正的方法相去越来越远:这么简单的一个转换,不应该搞得这么复杂,于是有了方案二&lt;/p&gt;
&lt;h2 id=&quot;方案二&quot;&gt;&lt;a href=&quot;#方案二&quot; class=&quot;headerlink&quot; title=&quot;方案二&quot;&gt;&lt;/a&gt;方案二&lt;/h2&gt;&lt;p&gt;这一次是使用&lt;code&gt;java.text&lt;/code&gt;包下的&lt;code&gt;DecimalFormat&lt;/code&gt;类,具体实现如下:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; scale = &lt;span class=&quot;number&quot;&gt;0.0005&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DecimalFormat decimalFormat = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; DecimalFormat(&lt;span class=&quot;string&quot;&gt;&quot;#.####&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(decimalFormat.format(scale)); &lt;span class=&quot;comment&quot;&gt;// 0.0005&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;方案三&quot;&gt;&lt;a href=&quot;#方案三&quot; class=&quot;headerlink&quot; title=&quot;方案三&quot;&gt;&lt;/a&gt;方案三&lt;/h2&gt;&lt;p&gt;后来想起来,发现其实上面两种方法都是庸人自扰,属于脑子一下没转过弯来才会干的事…因为实际上问题可以非常简单地解决:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; scale = &lt;span class=&quot;number&quot;&gt;0.0005&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String scaleStr = String.format(&lt;span class=&quot;string&quot;&gt;&quot;%.4f&quot;&lt;/span&gt;, scale);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(scaleStr); &lt;span class=&quot;comment&quot;&gt;// 0.0005&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;好吧,果然这种问题的解决办法一定是非常简单的…&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="踩坑" scheme="http://yoursite.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>Redis系统学习</title>
    <link href="http://yoursite.com/2019/11/28/Redis%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/11/28/Redis系统学习/</id>
    <published>2019-11-27T17:51:10.000Z</published>
    <updated>2020-02-08T03:19:22.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis系统学习"><a href="#Redis系统学习" class="headerlink" title="Redis系统学习"></a>Redis系统学习</h1><h2 id="一、什么是Redis"><a href="#一、什么是Redis" class="headerlink" title="一、什么是Redis?"></a>一、什么是Redis?</h2><ol><li>Redis是用C语言开发的一个开源、免费、高性能<strong>键值对</strong>内存数据库</li><li>它提供5种数据类型来<strong>存储值</strong>:字符串类型、散列类型、列表类型、集合类型、有序集合类型</li><li>他是一种NoSQL数据库</li><li>可用于缓存、内存数据库、消息队列等</li></ol><h3 id="1-1-什么是NoSQL"><a href="#1-1-什么是NoSQL" class="headerlink" title="1.1 什么是NoSQL?"></a>1.1 什么是NoSQL?</h3><ul><li>NoSQL,即Not-Only-SQL,泛指<strong>非关系型数据库</strong></li><li>NoSQL数据库为了解决<strong>高并发</strong>、<strong>高可用</strong>、<strong>高可拓展</strong>、<strong>大数据存储</strong>问题而产生的数据库解决方案</li><li>NoSQL可以作为关系型数据库的良好补充,但<strong>不是替代关系型数据库</strong></li></ul><h3 id="1-2-NoSQL数据库分类"><a href="#1-2-NoSQL数据库分类" class="headerlink" title="1.2 NoSQL数据库分类"></a>1.2 NoSQL数据库分类</h3><h4 id="1-2-1-键值存储数据库"><a href="#1-2-1-键值存储数据库" class="headerlink" title="1.2.1 键值存储数据库"></a>1.2.1 键值存储数据库</h4><p>相关产品: Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB</p><p>典型应用: 内容<strong>缓存</strong>,主要处理大量数据的<strong>高访问负载</strong></p><p>数据模型: 一系列键值对</p><p>优势: 快速<strong>查询</strong></p><p>劣势: 存储的数据缺少结构化</p><h4 id="1-2-2-列存储数据库"><a href="#1-2-2-列存储数据库" class="headerlink" title="1.2.2 列存储数据库"></a>1.2.2 列存储数据库</h4><p>相关产品: Cassardra、HBase、Riak</p><p>典型应用: <strong>分布式</strong>的文件系统</p><p>数据模型: 以列簇式存储,将同一列数据存在一起</p><p>优势: 查找速度快、可拓展性强,更容易进行分布式拓展</p><p>劣势: 功能相对局限</p><h4 id="1-2-3-文档型数据库"><a href="#1-2-3-文档型数据库" class="headerlink" title="1.2.3 文档型数据库"></a>1.2.3 文档型数据库</h4><p>说明: 与Key-Value类似,Value是<strong>结构化</strong>的,即<strong>可嵌套</strong></p><p>相关产品: Mongo DB、Couch DB</p><p>典型应用: Web应用</p><p>数据模型: 一系列键值对</p><p>优势: 数据结构要求不严格</p><h3 id="1-3-Redis的应用场景"><a href="#1-3-Redis的应用场景" class="headerlink" title="1.3 Redis的应用场景"></a>1.3 Redis的应用场景</h3><ul><li>内存数据库(登陆信息、购物车信息、用户浏览记录等)</li><li><strong>缓存服务器</strong>(商品数据、广告数据等)</li><li>解决分布式集群架构中的session分离问题(session共享)</li><li>任务队列(秒杀、抢购、12306等)</li><li>支持发布-订阅的消息模式</li><li>应用排行榜</li><li>网站访问统计</li><li>数据过期处理(精确到毫秒)</li></ul><h2 id="二、安装启动"><a href="#二、安装启动" class="headerlink" title="二、安装启动"></a>二、安装启动</h2><h3 id="2-1-解压二进制安装包"><a href="#2-1-解压二进制安装包" class="headerlink" title="2.1 解压二进制安装包"></a>2.1 解压二进制安装包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -xf redis-3.2.9.tar.gz <span class="comment"># 加上-z参数可以显示解压进度</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> redis-3.2.9</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make <span class="comment"># 需要安装GCC</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install PREFIX=/redis <span class="comment"># 指定安装目录安装</span></span></span><br></pre></td></tr></table></figure><h3 id="2-2-启动"><a href="#2-2-启动" class="headerlink" title="2.2 启动"></a>2.2 启动</h3><h4 id="2-2-1-前端启动"><a href="#2-2-1-前端启动" class="headerlink" title="2.2.1 前端启动"></a>2.2.1 前端启动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 直接运行bin/redis-server将以前端模式启动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./redis-server</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ctrl + c关闭</span></span><br></pre></td></tr></table></figure><h4 id="2-2-2-守护进程启动"><a href="#2-2-2-守护进程启动" class="headerlink" title="2.2.2 守护进程启动"></a>2.2.2 守护进程启动</h4><ol><li>修改<code>redis-conf</code>配置文件,将文件中的<code>daemonize</code>项改为<code>yes</code></li><li>bind 127.0.0.1改为bind &lt;redis实例所在机器的真实IP&gt;，如：bind 192.168.10.133（本地测试忽略）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定配置文件位置启动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-server /usr/<span class="built_in">local</span>/bin/redis.conf</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查是否启动成功</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ps -ef | grep redis</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭redis</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./redis-cli shutdown</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-3-其他命令介绍"><a href="#2-3-其他命令介绍" class="headerlink" title="2.3 其他命令介绍"></a>2.3 其他命令介绍</h3><ul><li>redis-server: 启动Redis服务</li><li>redis-cli: 进入Redis命令客户端</li><li>redis-benchmark: 性能测试工具</li><li>redis-check-aof: aof文件进行检查的工具</li><li>redis-check-dump: rdb文件进行检查的工具</li><li>redis-sentinel: 启动哨兵监控服务</li></ul><h3 id="2-4-Redis客户端"><a href="#2-4-Redis客户端" class="headerlink" title="2.4 Redis客户端"></a>2.4 Redis客户端</h3><h4 id="2-4-1-自带的命令客户端"><a href="#2-4-1-自带的命令客户端" class="headerlink" title="2.4.1 自带的命令客户端"></a>2.4.1 自带的命令客户端</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 默认进入当前机器的6379端口所在的Redis</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./redis-cli</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定机器和端口(host port)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./redis-cli -h IP地址 -p 端口</span></span><br></pre></td></tr></table></figure><h4 id="2-4-2-程序客户端-Jedis"><a href="#2-4-2-程序客户端-Jedis" class="headerlink" title="2.4.2 程序客户端-Jedis"></a>2.4.2 程序客户端-Jedis</h4><ul><li>Redis不仅可以使用命令客户端进行操作,还可以使用<strong>程序客户端</strong>进行操作</li><li>现在的主流语言都有客户端支持,比如:Java、C、C#、C++、PHP、Node.js、Go等</li><li>Java的客户端有: <strong>Jedis</strong>、<strong>Redisson</strong>、Jredis、JDBC-Redis</li></ul><h4 id="2-4-3-多数据库支持"><a href="#2-4-3-多数据库支持" class="headerlink" title="2.4.3 多数据库支持"></a>2.4.3 多数据库支持</h4><p>默认一共是<strong>16</strong>个数据库，每个数据库之间是<strong>相互隔离</strong>（但是可以使用flushall一次清空所有的库）。数据库的数量是在redis.conf中配置的。</p><p>切换数据库使用命令：select 数据库编号（0-15）</p><p>例如：select 1</p><h2 id="三、通用命令"><a href="#三、通用命令" class="headerlink" title="三、通用命令"></a>三、通用命令</h2><h3 id="3-1-set-amp-get命令"><a href="#3-1-set-amp-get命令" class="headerlink" title="3.1 set &amp; get命令"></a>3.1 set &amp; get命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> redis通过<span class="built_in">set</span> key value的方式塞值</span></span><br><span class="line">set name tom</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis通过get key的方式取值</span></span><br><span class="line">get name</span><br></pre></td></tr></table></figure><h3 id="3-2-keys命令"><a href="#3-2-keys命令" class="headerlink" title="3.2 keys命令"></a>3.2 keys命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 返回满足给定pattern的所有key</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 语法:keys pattern</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> keys *</span></span><br><span class="line">1) "age"</span><br><span class="line">2) "id"</span><br><span class="line">3) "Category"</span><br><span class="line">4) "name"</span><br><span class="line">5) "ID"</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> keys i*</span></span><br><span class="line">1) "id"</span><br></pre></td></tr></table></figure><h3 id="3-3-setnx命令"><a href="#3-3-setnx命令" class="headerlink" title="3.3 setnx命令"></a>3.3 setnx命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> setnx只能在key不存在的场景下可以塞值成功</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> get name</span></span><br><span class="line">"Jack"</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> setnx name <span class="string">"Bob"</span></span></span><br><span class="line">(integer) 0 # setnx返回0代表塞值失败</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> get name</span></span><br><span class="line">"Jack"</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> setnx name2 <span class="string">"Bob"</span></span></span><br><span class="line">(integer) 1 # setnx返回1代表塞值成功</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> get name2</span></span><br><span class="line">"Bob"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提示:可以用keys命令来检验key是否已存在</span></span><br></pre></td></tr></table></figure><p>该命令可以用于分布式锁,只能赋值成功一次的场景: 把key当作是锁</p><h3 id="3-4-append命令"><a href="#3-4-append命令" class="headerlink" title="3.4 append命令"></a>3.4 append命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> sayhi <span class="string">"hello"</span></span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> append sayhi <span class="string">" world"</span></span></span><br><span class="line">(integer) 11 # 该数字代表当前value的长度</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> get sayhi</span></span><br><span class="line">"hello world"</span><br></pre></td></tr></table></figure><h3 id="3-5-strlen命令"><a href="#3-5-strlen命令" class="headerlink" title="3.5 strlen命令"></a>3.5 strlen命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> strlen sayhi</span></span><br><span class="line">(integer) 11</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 键不存在会返回0</span></span><br></pre></td></tr></table></figure><h3 id="3-6-同时设置多个值和获取多个值"><a href="#3-6-同时设置多个值和获取多个值" class="headerlink" title="3.6 同时设置多个值和获取多个值"></a>3.6 同时设置多个值和获取多个值</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mset k1 v1 k2 v2 k3 v3</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> mget k1 k2 k3</span></span><br><span class="line">1) "v1"</span><br><span class="line">2) "v2"</span><br><span class="line">3) "v3"</span><br></pre></td></tr></table></figure><h3 id="3-7-del命令"><a href="#3-7-del命令" class="headerlink" title="3.7 del命令"></a>3.7 del命令</h3><p>del命令是根据key来删除的,所以5种数据类型通用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> del name</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><h3 id="3-8-判断一个key是否存在"><a href="#3-8-判断一个key是否存在" class="headerlink" title="3.8 判断一个key是否存在"></a>3.8 判断一个key是否存在</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> exists k1</span></span><br><span class="line">(integer) 1 # 存在</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> exists k9</span></span><br><span class="line">(integer) 0 # 不存在</span><br></pre></td></tr></table></figure><h3 id="3-9-给一个key重命名"><a href="#3-9-给一个key重命名" class="headerlink" title="3.9 给一个key重命名"></a>3.9 给一个key重命名</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rename k1 k11</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> keys k*</span></span><br><span class="line">1) "k3"</span><br><span class="line">2) "k11"</span><br><span class="line">3) "k2"</span><br></pre></td></tr></table></figure><h3 id="3-10-判断一个value的类型"><a href="#3-10-判断一个value的类型" class="headerlink" title="3.10 判断一个value的类型"></a>3.10 判断一个value的类型</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">type</span> k11</span></span><br><span class="line">string</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">type</span> list1</span></span><br><span class="line">list</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">type</span> tom</span></span><br><span class="line">hash</span><br></pre></td></tr></table></figure><h3 id="3-11-设置缓存过期时间-生存时间"><a href="#3-11-设置缓存过期时间-生存时间" class="headerlink" title="3.11 设置缓存过期时间(生存时间)"></a>3.11 设置缓存过期时间(生存时间)</h3><p><code>Redis</code>在实际使用过程中,更多的用作缓存.然而缓存的数据一般都是需要设置生存时间的.</p><p>即:到期后数据销毁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> expire key seconds 设置生存时间(秒)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> expire key milliseconds (毫秒)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ttl key            查看key剩余生存时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> persist key        清除生存时间(永生)</span></span><br></pre></td></tr></table></figure><h2 id="四、Redis数据类型"><a href="#四、Redis数据类型" class="headerlink" title="四、Redis数据类型"></a>四、Redis数据类型</h2><h3 id="4-1-String类型"><a href="#4-1-String类型" class="headerlink" title="4.1 String类型"></a>4.1 String类型</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 赋值</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> name tom</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取值</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> get name</span></span><br><span class="line">"tom"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取值并赋值(取出老的值并赋予新的值)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> getset name Jack</span></span><br><span class="line">"tom"</span><br><span class="line"><span class="meta">$</span><span class="bash"> get name</span></span><br><span class="line">"Jack"</span><br></pre></td></tr></table></figure><h4 id="4-1-1-String类型递增数字"><a href="#4-1-1-String类型递增数字" class="headerlink" title="4.1.1 String类型递增数字"></a>4.1.1 String类型递增数字</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果我们key的value是可以转换成正整数的字符串</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 那么就可以使用incr命令来实现自增</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 该操作是原子性的,可用于分布式系统的唯一ID生成</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> ID <span class="string">"10"</span></span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> incr ID</span></span><br><span class="line">(integer) 11</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> get ID</span></span><br><span class="line">"11"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> incr还可以指定增幅:使用incrby命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> incrby ID 10</span></span><br><span class="line">(integer) 21</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 递减</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> decr ID</span></span><br><span class="line">(integer) 20</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 递减并指定幅度</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> decrby ID 10</span></span><br><span class="line">(integer) 10</span><br></pre></td></tr></table></figure><h3 id="4-2-Hash类型"><a href="#4-2-Hash类型" class="headerlink" title="4.2 Hash类型"></a>4.2 Hash类型</h3><p>Hash类型使用<code>hset</code>命令,<strong>不区分插入和更新操作</strong>,当执行插入操作的时候返回1;当执行更新操作的时候返回0</p><p>该类型可以理解为他的value是一个<code>map</code>,即: 键 - (属性:值)</p><p>属性就可以理解为map的key;值则是map的值</p><p>这样的数据结构更能体现Java对象的特征</p><p><strong>语法:</strong> hset key field value</p><p><strong>注意事项:</strong> 存储对象属性经常发生增删改操作的数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hset <span class="string">"tom"</span> age 20</span></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> hset <span class="string">"tom"</span> addr beijing</span></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> hget tom age</span></span><br><span class="line">"20"</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> hget tom addr</span></span><br><span class="line">"beijing"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当然hmset和hmget可以实现多个操作,例如:</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hmget tom age addr</span></span><br><span class="line">1) "20"</span><br><span class="line">2) "beijing"</span><br></pre></td></tr></table></figure><h4 id="4-2-1-Hash类型递增数字"><a href="#4-2-1-Hash类型递增数字" class="headerlink" title="4.2.1 Hash类型递增数字"></a>4.2.1 Hash类型递增数字</h4><p>同样,hash类型也是可以递增数字的,例如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 不存在hincr命令,只有hincrby</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hincrby tom age 2</span></span><br><span class="line">(integer) 22</span><br></pre></td></tr></table></figure><h4 id="4-2-2-判断属性是否存在"><a href="#4-2-2-判断属性是否存在" class="headerlink" title="4.2.2 判断属性是否存在"></a>4.2.2 判断属性是否存在</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexists tom age</span></span><br><span class="line">(integer) 1 # 存在</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexists tom name</span></span><br><span class="line">(integer) 0 # 不存在</span><br></pre></td></tr></table></figure><h4 id="4-2-3-获取所有的field或所有的值"><a href="#4-2-3-获取所有的field或所有的值" class="headerlink" title="4.2.3 获取所有的field或所有的值"></a>4.2.3 获取所有的field或所有的值</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hkeys tom</span></span><br><span class="line">1) "age"</span><br><span class="line">2) "addr"</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> hvals tom</span></span><br><span class="line">1) "22"</span><br><span class="line">2) "beijing"</span><br></pre></td></tr></table></figure><h4 id="4-2-4-获取所有的field和所有的值"><a href="#4-2-4-获取所有的field和所有的值" class="headerlink" title="4.2.4 获取所有的field和所有的值"></a>4.2.4 获取所有的field和所有的值</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hgetall tom</span></span><br><span class="line">1) "age"</span><br><span class="line">2) "22"</span><br><span class="line">3) "addr"</span><br><span class="line">4) "beijing"</span><br></pre></td></tr></table></figure><h4 id="4-2-5-获取字段数"><a href="#4-2-5-获取字段数" class="headerlink" title="4.2.5 获取字段数"></a>4.2.5 获取字段数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hlen tom</span></span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><h3 id="4-3-List类型"><a href="#4-3-List类型" class="headerlink" title="4.3 List类型"></a>4.3 List类型</h3><p>内部实现是<strong>双向链表</strong>,所以向两端添加元素的时间复杂度为O(1),获取<strong>越接近两端的元素速度就越快</strong>.</p><p>这意味着,即使是一个有几千万个元素的列表,获取头部和尾部的10条记录也是极快的.</p><h4 id="4-3-1-向列表增加和查看列表"><a href="#4-3-1-向列表增加和查看列表" class="headerlink" title="4.3.1 向列表增加和查看列表"></a>4.3.1 向列表增加和查看列表</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 向列表左边增加元素</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lpush list1 1 2 3 4 5</span></span><br><span class="line">(integer) 5</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 因为依次向左边添加元素,因此目前的列表应该是</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5,4,3,2,1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 遍历该列表</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 索引可以是负数,-1代表最后一个元素</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lrange list1 0 4</span></span><br><span class="line">1) "5"</span><br><span class="line">2) "4"</span><br><span class="line">3) "3"</span><br><span class="line">4) "2"</span><br><span class="line">5) "1"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从右边增加元素则是使用rpush,示例省略</span></span><br></pre></td></tr></table></figure><h4 id="4-3-2-从列表两端弹出元素"><a href="#4-3-2-从列表两端弹出元素" class="headerlink" title="4.3.2 从列表两端弹出元素"></a>4.3.2 从列表两端弹出元素</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lpop list1</span></span><br><span class="line">"5"</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> lrange list1 0 -1</span></span><br><span class="line">1) "4"</span><br><span class="line">2) "3"</span><br><span class="line">3) "2"</span><br><span class="line">4) "1"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从右边删除元素则是使用rpop,示例省略</span></span><br></pre></td></tr></table></figure><p>利用列表,从一端添加,从另一端pop就可以实现消息队列的效果</p><h4 id="4-3-3-获取列表长度"><a href="#4-3-3-获取列表长度" class="headerlink" title="4.3.3 获取列表长度"></a>4.3.3 获取列表长度</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> llen list1</span></span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure><h4 id="4-3-4-删除列表中指定的值-且指定删除的个数"><a href="#4-3-4-删除列表中指定的值-且指定删除的个数" class="headerlink" title="4.3.4 删除列表中指定的值(且指定删除的个数)"></a>4.3.4 删除列表中指定的值(且指定删除的个数)</h4><p>语法: lrem 列表 个数 值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除前</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lrange list1 0 -1</span></span><br><span class="line">1) "2"</span><br><span class="line">2) "4"</span><br><span class="line">3) "3"</span><br><span class="line">4) "2"</span><br><span class="line">5) "1"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从list1当中删除1个2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lrem list1 1 2</span></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除后</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lrange list1 0 -1</span></span><br><span class="line">1) "4"</span><br><span class="line">2) "3"</span><br><span class="line">3) "2"</span><br><span class="line">4) "1"</span><br></pre></td></tr></table></figure><h4 id="4-3-5-获取指定索引的元素值"><a href="#4-3-5-获取指定索引的元素值" class="headerlink" title="4.3.5 获取指定索引的元素值"></a>4.3.5 获取指定索引的元素值</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lrange list1 0 -1</span></span><br><span class="line">1) "4"</span><br><span class="line">2) "3"</span><br><span class="line">3) "2"</span><br><span class="line">4) "1"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取索引为1的元素值</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lindex list1 1</span></span><br><span class="line">"3"</span><br></pre></td></tr></table></figure><h4 id="4-3-6-将列表中元素插入另一个列表"><a href="#4-3-6-将列表中元素插入另一个列表" class="headerlink" title="4.3.6 将列表中元素插入另一个列表"></a>4.3.6 将列表中元素插入另一个列表</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lrange list1 0 -1</span></span><br><span class="line">1) "4"</span><br><span class="line">2) "3"</span><br><span class="line">3) "2"</span><br><span class="line">4) "1"</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> rpoplpush list1 newlist</span></span><br><span class="line">"1"</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> lrange newlist 0 -1</span></span><br><span class="line">1) "1"</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> lrange list1 0 -1</span></span><br><span class="line">1) "4"</span><br><span class="line">2) "3"</span><br><span class="line">3) "2"</span><br></pre></td></tr></table></figure><h3 id="4-4-Set类型"><a href="#4-4-Set类型" class="headerlink" title="4.4 Set类型"></a>4.4 Set类型</h3><p>不可重复(去重)</p><h4 id="4-4-1-新增-amp-删除"><a href="#4-4-1-新增-amp-删除" class="headerlink" title="4.4.1 新增&amp;删除"></a>4.4.1 新增&amp;删除</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sadd s1 1 2 3 4 5</span></span><br><span class="line">(integer) 5 # 该数字表示此次插入成功的元素个数</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 补充:因为<span class="built_in">set</span>类型具备去重的特性,如果sadd的值已存在,则会出现add数字为0的情况</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看key下的所有值</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> smembers s1</span></span><br><span class="line">1) "1"</span><br><span class="line">2) "2"</span><br><span class="line">3) "3"</span><br><span class="line">4) "4"</span><br><span class="line">5) "5"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除元素</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> srem s1 4</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><h4 id="4-4-2-判断集合中是否存在该元素"><a href="#4-4-2-判断集合中是否存在该元素" class="headerlink" title="4.4.2 判断集合中是否存在该元素"></a>4.4.2 判断集合中是否存在该元素</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sismember s1 6</span></span><br><span class="line">(integer) 1 # 表示存在</span><br><span class="line"><span class="meta">$</span><span class="bash"> sismember s1 7</span></span><br><span class="line">(integer) 0 # 表示不存在</span><br></pre></td></tr></table></figure><h4 id="4-4-3-集合运算"><a href="#4-4-3-集合运算" class="headerlink" title="4.4.3 集合运算"></a>4.4.3 集合运算</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 已知:</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> smembers s1</span></span><br><span class="line">1) "1"</span><br><span class="line">2) "2"</span><br><span class="line">3) "3"</span><br><span class="line">4) "4"</span><br><span class="line">5) "5"</span><br><span class="line">6) "6"</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> smembers s2</span></span><br><span class="line">1) "2"</span><br><span class="line">2) "4"</span><br><span class="line">3) "6"</span><br><span class="line">4) "8"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 交集运算</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sinter s1 s2</span></span><br><span class="line">1) "2"</span><br><span class="line">2) "4"</span><br><span class="line">3) "6"</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sinter s2 s1</span></span><br><span class="line">1) "2"</span><br><span class="line">2) "4"</span><br><span class="line">3) "6"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 差集运算</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 即:从[前者]里面减去[前者]和[后者]同时存在的值</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sdiff s1 s2</span></span><br><span class="line">1) "1"</span><br><span class="line">2) "3"</span><br><span class="line">3) "5"</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sdiff s2 s1</span></span><br><span class="line">1) "8"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 并集运算</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sunion s1 s2</span></span><br><span class="line">1) "1"</span><br><span class="line">2) "2"</span><br><span class="line">3) "3"</span><br><span class="line">4) "4"</span><br><span class="line">5) "5"</span><br><span class="line">6) "6"</span><br><span class="line">7) "8"</span><br></pre></td></tr></table></figure><h4 id="4-4-4-获取集合中元素的个数"><a href="#4-4-4-获取集合中元素的个数" class="headerlink" title="4.4.4 获取集合中元素的个数"></a>4.4.4 获取集合中元素的个数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> scard s1</span></span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure><h4 id="4-4-5-从集合中弹出一个元素"><a href="#4-4-5-从集合中弹出一个元素" class="headerlink" title="4.4.5 从集合中弹出一个元素"></a>4.4.5 从集合中弹出一个元素</h4><p>必须要注意的是,此处的弹出(删除)是随机的.因此可以使用它来实现抽奖系统等</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 传递的数字代表要弹出几个元素,而不是弹出什么元素</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> spop s1 6</span></span><br><span class="line">1) "1"</span><br><span class="line">2) "2"</span><br><span class="line">3) "3"</span><br><span class="line">4) "4"</span><br><span class="line">5) "5"</span><br><span class="line">6) "6"</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> smembers s1</span></span><br><span class="line">(empty list or set)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sadd s1 1 2 3 4 5 6</span></span><br><span class="line">(integer) 6</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> scard s1</span></span><br><span class="line">(integer) 6</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> spop s1</span></span><br><span class="line">"6"</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> spop s1</span></span><br><span class="line">"3"</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> spop s1</span></span><br><span class="line">"1"</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> scard s1</span></span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> spop s1 2</span></span><br><span class="line">1) "5"</span><br><span class="line">2) "2"</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> scard s1</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><h3 id="4-5-SortedSet类型-别名-ZSet"><a href="#4-5-SortedSet类型-别名-ZSet" class="headerlink" title="4.5 SortedSet类型(别名:ZSet)"></a>4.5 SortedSet类型(别名:ZSet)</h3><p>有序集合实现排序的方式:通过给每一个元素指定一个分数,然后基于分数进行排名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 语法:zadd 集合名 分数 元素</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> zadd z1 80 Jerry 100 Tom 75 Jack</span></span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 排名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认:从小到大</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> zrange z1 0 -1</span></span><br><span class="line">1) "Jack"</span><br><span class="line">2) "Jerry"</span><br><span class="line">3) "Tom"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 降序</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> zrevrange z1 0 -1</span></span><br><span class="line">1) "Tom"</span><br><span class="line">2) "Jerry"</span><br><span class="line">3) "Jack"</span><br></pre></td></tr></table></figure><h4 id="4-5-1-获取元素的分数"><a href="#4-5-1-获取元素的分数" class="headerlink" title="4.5.1 获取元素的分数"></a>4.5.1 获取元素的分数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> zscore z1 Jack</span></span><br><span class="line">"75"</span><br></pre></td></tr></table></figure><h4 id="4-5-2-删除元素"><a href="#4-5-2-删除元素" class="headerlink" title="4.5.2 删除元素"></a>4.5.2 删除元素</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> zrem z1 Jack</span></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> zrange z1 0 -1</span></span><br><span class="line">1) "Jerry"</span><br><span class="line">2) "Tom"</span><br></pre></td></tr></table></figure><h2 id="五、Redis事务"><a href="#五、Redis事务" class="headerlink" title="五、Redis事务"></a>五、Redis事务</h2><h3 id="5-1-Redis事务介绍"><a href="#5-1-Redis事务介绍" class="headerlink" title="5.1 Redis事务介绍"></a>5.1 Redis事务介绍</h3><ul><li>Redis事务是通过<code>MULTI</code>、<code>EXEC</code>、<code>DISCARD</code>和<code>WATCH</code>这四个命令实现的</li><li>Redis的单个命令都是<strong>原子性</strong>的,所以这里确保事务性的对象是<strong>命令集合</strong></li><li>Redis将命令集合序列化并确保处于同一事务的命令集合<strong>连续且不被打断</strong>的执行</li><li>不支持事务回滚</li></ul><h3 id="5-2-命令介绍"><a href="#5-2-命令介绍" class="headerlink" title="5.2 命令介绍"></a>5.2 命令介绍</h3><h4 id="5-2-1-MULTI命令"><a href="#5-2-1-MULTI命令" class="headerlink" title="5.2.1 MULTI命令"></a>5.2.1 MULTI命令</h4><p>用于<strong>标记一个事务块的开始</strong></p><p>Redis会将后续的命令逐个放入队列中,然后才能使用EXEC命令原子化地执行这个序列</p><h4 id="5-2-2-EXEC命令"><a href="#5-2-2-EXEC命令" class="headerlink" title="5.2.2 EXEC命令"></a>5.2.2 EXEC命令</h4><p>在一个事务中执行所以先前放入命令队列中的命令,然后恢复正常的连接状态</p><h4 id="5-2-3-DISCARD命令"><a href="#5-2-3-DISCARD命令" class="headerlink" title="5.2.3 DISCARD命令"></a>5.2.3 DISCARD命令</h4><p>清除所有在先前一个事务中放入命令队列中的命令,然后恢复正常的连接状态</p><h4 id="5-2-4-WATCH命令"><a href="#5-2-4-WATCH命令" class="headerlink" title="5.2.4 WATCH命令"></a>5.2.4 WATCH命令</h4><p>当某个事务需要按条件执行时,就要使用这个命令.将给定的键设置为受监控的</p><p>使用这个命令可以实现Redis的<code>乐观锁</code></p><p>使用<code>unwatch</code>清除所有先前为一个事务监控的键</p><h4 id="5-2-5-示例"><a href="#5-2-5-示例" class="headerlink" title="5.2.5 示例"></a>5.2.5 示例</h4><p>演示事务开启并取消:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> MULTI <span class="comment"># 开启事务命令集合</span></span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> s111 v111 <span class="comment"># 往命令队列中添加命令1</span></span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> s222 v222 <span class="comment"># 往命令队列中添加命令2</span></span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> DISCARD <span class="comment"># 取消命令队列中的命令</span></span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">exec</span></span></span><br><span class="line">(error) ERR EXEC without MULTI</span><br></pre></td></tr></table></figure><p>演示事务开启并执行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> MULTI <span class="comment"># 开启事务命令集合</span></span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> s111 v111 <span class="comment"># 往命令队列中添加命令1</span></span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> s222 v222 <span class="comment"># 往命令队列中添加命令2</span></span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">exec</span> <span class="comment"># 开始依次执行命令集合中的命令</span></span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br></pre></td></tr></table></figure><p>演示WATCH乐观锁:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检视初始值</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> get s1</span></span><br><span class="line">"111"</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> get s2</span></span><br><span class="line">"222"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开始监控s1的状态:如果s1的值发生变化,则事务不执行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> watch s1</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启事务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> MULTI</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> s2 999</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 由于s1的值在其他地方被改变,事务执行失败</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">exec</span></span></span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> s2的值没有被修改</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> get s2</span></span><br><span class="line">"222"</span><br></pre></td></tr></table></figure><h3 id="5-3-Redis事务失败"><a href="#5-3-Redis事务失败" class="headerlink" title="5.3 Redis事务失败"></a>5.3 Redis事务失败</h3><ul><li>Redis语法错误</li><li>Redis类型错误</li></ul><h4 id="5-3-1-为什么Redis不支持事务回滚"><a href="#5-3-1-为什么Redis不支持事务回滚" class="headerlink" title="5.3.1 为什么Redis不支持事务回滚?"></a>5.3.1 为什么Redis不支持事务回滚?</h4><ol><li>大多数事务失败是因为语法错误或类型错误,这两种错误都可以在开发阶段预见</li><li>Redis为了性能方面忽略了事务回滚</li></ol><h2 id="六、Redis实现分布式锁"><a href="#六、Redis实现分布式锁" class="headerlink" title="六、Redis实现分布式锁"></a>六、Redis实现分布式锁</h2><h3 id="6-1-锁的处理"><a href="#6-1-锁的处理" class="headerlink" title="6.1 锁的处理"></a>6.1 锁的处理</h3><ul><li><p>单应用中使用锁：单进程多线程</p><p>Synchronize、Lock</p></li><li><p>分布式应用中使用锁：多进程</p></li></ul><h3 id="6-2-分布式锁的实现方式"><a href="#6-2-分布式锁的实现方式" class="headerlink" title="6.2 分布式锁的实现方式"></a>6.2 分布式锁的实现方式</h3><ul><li>数据库的乐观锁</li><li>基于Zookeeper的分布式锁</li><li>基于Redis的分布式锁</li></ul><h3 id="6-3-分布式锁的注意事项"><a href="#6-3-分布式锁的注意事项" class="headerlink" title="6.3 分布式锁的注意事项"></a>6.3 分布式锁的注意事项</h3><ul><li>互斥性：在任意时刻，只有一个客户端能持有锁</li><li>同一性：加锁和解锁必须是同一个客户端，客户端不能把别人加的锁</li><li>避免死锁：即使有一个客户端持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端加锁</li></ul><h3 id="6-4-实现分布式锁"><a href="#6-4-实现分布式锁" class="headerlink" title="6.4 实现分布式锁"></a>6.4 实现分布式锁</h3><h4 id="6-4-1-获取锁"><a href="#6-4-1-获取锁" class="headerlink" title="6.4.1 获取锁"></a>6.4.1 获取锁</h4><p>在<strong>SET</strong>命令中，有很多选项可用来修改命令的行为，以下是<strong>SET</strong>命令可用的基本语法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> SET key value [EX seconds] [PX milliseconds] [NX|XX]</span></span><br></pre></td></tr></table></figure><ul><li>EX seconds：设置指定的到期时间（以秒为单位）。</li><li>PX milliseconds：设置指定的到期时间（以毫秒为单位）。</li><li>NX：仅在键不存在的时候设置键。</li><li>XX：仅在键已存在的时候才设置。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 方式1 使用redis的set命令实现获取分布式锁</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> lockKey   可以就是锁</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> requestId请求ID，保证同一性</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> expireTime过期时间，避免死锁</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getLock</span><span class="params">(String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// NX:保证互斥性</span></span><br><span class="line">  String result = jedis.set(lockKey, requestId, <span class="string">"NX"</span>, <span class="string">"EX"</span>, expireTime);</span><br><span class="line">  <span class="keyword">if</span>(<span class="string">"OK"</span>.equals(result)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 方式2（使用setnx命令实现）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getLock</span><span class="params">(String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">Long result = jedis.setnx(lockKey, requestId);</span><br><span class="line"><span class="keyword">if</span>(result == <span class="number">1</span>) &#123;</span><br><span class="line">jedis.expire(lockKey, expireTime);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-4-2-释放锁"><a href="#6-4-2-释放锁" class="headerlink" title="6.4.2 释放锁"></a>6.4.2 释放锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 方式1 del命令实现 释放分布式锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">(String lockKey,String requestId)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (requestId.equals(jedis.get(lockKey))) &#123;</span><br><span class="line">    jedis.del(lockKey);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 方式2（redis+lua脚本实现）--推荐</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseLock</span><span class="params">(String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line">String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result.equals(<span class="number">1L</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、持久化方案"><a href="#七、持久化方案" class="headerlink" title="七、持久化方案"></a>七、持久化方案</h2><p>Redis是一个内存数据库，为了保证数据的持久性，它提供了两种持久化方案：</p><ul><li>RDB方式（默认）</li><li>AOF方式</li></ul><h3 id="7-1-RDB方式"><a href="#7-1-RDB方式" class="headerlink" title="7.1 RDB方式"></a>7.1 RDB方式</h3><h4 id="7-1-1-介绍"><a href="#7-1-1-介绍" class="headerlink" title="7.1.1 介绍"></a>7.1.1 介绍</h4><ul><li>RDB是Redis<strong>默认</strong>采用的持久化方式</li><li>RDB方式是通过<strong>快照</strong>（snapshotting）完成的，当<strong>符合一定条件</strong>时Redis会自动将内存中的数据进行快照并持久化到硬盘。默认保存在dump.rdb文件中。（本机位置：/usr/local/bin/dump.rdb）</li><li>Redis会在<strong>指定的情况</strong>下触发快照<ol><li>符合自定义配置的快照规则</li><li>执行save或者bgsave命令</li><li>执行flushall命令</li><li>执行主从复制操作</li></ol></li></ul><h4 id="7-1-2-配置dbfilename指定rdb快照文件的名称"><a href="#7-1-2-配置dbfilename指定rdb快照文件的名称" class="headerlink" title="7.1.2 配置dbfilename指定rdb快照文件的名称"></a>7.1.2 配置dbfilename指定rdb快照文件的名称</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># The filename where to dump the DB</span><br><span class="line">dbfilename dump.rdb</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ol><li>redis在进行快照的过程中不会修改RDB文件，只有快照结束后才会将旧的文件替换成新的，也就是说任何时候RDB文件都是完整的。 </li><li>这就使得我们可以通过定时备份RDB文件来实现redis数据库的备份， RDB文件是经过压缩的二进制文件，占用的空间会小于内存中的数据，更加利于传输。</li></ol><h4 id="7-1-3-自定义快照规则"><a href="#7-1-3-自定义快照规则" class="headerlink" title="7.1.3 自定义快照规则"></a>7.1.3 自定义快照规则</h4><p>在redis.conf中设置自定义快照规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式：save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">save 900 1    ： 表示15分钟（900秒钟）内至少1个键被更改则进行快照。</span><br><span class="line">save 300 10   ： 表示5分钟（300秒）内至少10个键被更改则进行快照。</span><br><span class="line">save 60 10000 ： 表示1分钟内至少10000个键被更改则进行快照。</span><br><span class="line"></span><br><span class="line">可以配置多个条件（每行配置一个条件），每个条件之间是“或”的关系。</span><br></pre></td></tr></table></figure><p><strong>特别说明：</strong></p><pre><code>1. Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。 2. 根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将记录一千万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20～30秒钟。</code></pre><h4 id="7-1-4-RDB的优缺点"><a href="#7-1-4-RDB的优缺点" class="headerlink" title="7.1.4 RDB的优缺点"></a>7.1.4 RDB的优缺点</h4><p>优点：</p><p>RDB可以最大化Redis的性能：父进程在保存RDB文件时唯一要做的就是fork出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无序执行任何磁盘I/O操作。同时这个也是一个缺点，如果数据集比较大的时候，fork可以能比较耗时，造成服务器在一段时间内停止处理客户端的请求</p><p>缺点：</p><p>使用RDB方式实现持久化，一旦Redis异常退出，<strong>就会丢失最后一次快照以后更改的所有数据</strong>。这个时候我们就需要根据具体的应用场景，通过<strong>组合设置自动快照条件的方式</strong>来将可能发生的数据损失控制在能够接受范围。如果数据相对来说比较重要，希望将损失降到最小，则可以使用AOF方式进行持久化</p><h3 id="7-2-AOF方式"><a href="#7-2-AOF方式" class="headerlink" title="7.2 AOF方式"></a>7.2 AOF方式</h3><h4 id="7-2-1-介绍"><a href="#7-2-1-介绍" class="headerlink" title="7.2.1 介绍"></a>7.2.1 介绍</h4><ul><li>默认情况下Redis没有开启AOF（append only file）方式的持久化</li><li>开启AOF持久化后每执行一条会<strong>更改</strong>Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件，这一过程显然会降低Redis的性能，但大部分情况下这个影响是能够接受的，另外使用较快的硬盘可以提高AOF的性能。</li><li>可以通过修改redis.conf配置文件中的appendonly参数开启</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><p>AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的。</p><p>默认的文件名是appendonly.aof，可以通过appendfilename参数修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfilename appendonly.aof</span><br></pre></td></tr></table></figure><h4 id="7-2-2-参数说明"><a href="#7-2-2-参数说明" class="headerlink" title="7.2.2 参数说明"></a>7.2.2 参数说明</h4><ul><li><p><strong>auto-aof-rewrite-percentage 100</strong>  表示当前aof文件大小超过上一次aof文件大小的百分之多少的时候会进行重写。如果之前没有重写过，以启动时aof文件大小为准</p></li><li><p><strong>auto-aof-rewrite-min-size 64mb</strong>   限制允许重写最小aof文件大小，也就是文件大小小于64mb的时候，不需要进行优化</p></li></ul><h4 id="7-2-3-同步磁盘数据"><a href="#7-2-3-同步磁盘数据" class="headerlink" title="7.2.3 同步磁盘数据"></a>7.2.3 同步磁盘数据</h4><p>Redis每次更改数据的时候， aof机制都会将命令记录到aof文件，但是实际上由于操作系统的缓存机制，数据并没有实时写入到硬盘，而是进入硬盘缓存。再通过硬盘缓存机制去刷新到保存到文件。</p><p><strong>参数说明：</strong></p><p><strong>appendfsync always</strong>  每次执行写入都会进行同步  ， 这个是最安全但是是效率比较低的方式</p><p><strong>appendfsync everysec</strong>   每一秒执行（默认）</p><p><strong>appendfsync no</strong>  不主动进行同步操作，由操作系统去执行，这个是最快但是最不安全的方式</p><h4 id="7-2-4-AOF文件损坏以后如何修复"><a href="#7-2-4-AOF文件损坏以后如何修复" class="headerlink" title="7.2.4 AOF文件损坏以后如何修复"></a>7.2.4 AOF文件损坏以后如何修复</h4><p>服务器可能在程序正在对 AOF 文件进行写入时停机， 如果停机造成了 AOF 文件出错（corrupt）， 那么 Redis 在重启时会拒绝载入这个 AOF 文件， 从而确保数据的一致性不会被破坏。</p><p><strong>当发生这种情况时，</strong> <strong>可以用以下方法来修复出错的 AOF 文件：</strong></p><ol><li><p>为现有的 AOF 文件创建一个<strong>备份</strong>。</p></li><li><p>使用 Redis 附带的 <strong>redis-check-aof</strong> 程序，对原来的 AOF 文件进行修复。</p></li></ol><p>redis-check-aof –fix readonly.aof</p><p>重启 Redis 服务器，等待服务器载入修复后的 AOF 文件，并进行数据恢复。</p><h3 id="7-3-如何选择RDB和AOF"><a href="#7-3-如何选择RDB和AOF" class="headerlink" title="7.3 如何选择RDB和AOF"></a>7.3 如何选择RDB和AOF</h3><ul><li><p>一般来说,如果对数据的安全性要求非常高的话，应该同时使用两种持久化功能。</p></li><li><p>如果可以承受数分钟以内的数据丢失，那么可以只使用 RDB 持久化。</p></li><li><p>有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快 。</p></li><li><p>两种持久化策略可以同时使用，也可以使用其中一种。如果同时使用的话， 那么Redis重启时，会优先<strong>使用AOF文件</strong>来还原数据</p></li></ul><h2 id="八、Redis主从复制"><a href="#八、Redis主从复制" class="headerlink" title="八、Redis主从复制"></a>八、Redis主从复制</h2><p>持久化保证了即使redis服务重启也不会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，但是当redis服务器的硬盘损坏了可能会导致数据丢失，不过通过redis的主从复制机制就可以避免这种单点故障。</p><p><strong>说明：</strong></p><ul><li><p>主redis中的数据有两个副本（replication）即从redis1和从redis2，即使一台redis服务器宕机其它两台redis服务也可以继续提供服务。</p></li><li><p>主redis中的数据和从redis上的数据保持实时同步，当主redis写入数据时通过主从复制机制会复制到两个从redis服务上。</p></li><li><p>只有一个主redis，可以有多个从redis。</p></li><li><p>主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求</p></li><li><p>一个redis可以即是主又是从</p></li></ul><h3 id="8-1-主从配置"><a href="#8-1-主从配置" class="headerlink" title="8.1 主从配置"></a>8.1 主从配置</h3><h4 id="8-1-1-主redis配置"><a href="#8-1-1-主redis配置" class="headerlink" title="8.1.1 主redis配置"></a>8.1.1 主redis配置</h4><p>无需特殊配置。</p><h4 id="8-1-2-从redis配置"><a href="#8-1-2-从redis配置" class="headerlink" title="8.1.2 从redis配置"></a>8.1.2 从redis配置</h4><p>修改从服务器上的redis.conf文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure><h3 id="8-2-实现原理"><a href="#8-2-实现原理" class="headerlink" title="8.2 实现原理"></a>8.2 实现原理</h3><ul><li><p>Redis的主从同步，分为全量同步和增量同步。</p></li><li><p>只有从机第一次连接上主机是全量同步</p></li><li><p>断线重连有可能触发全量同步也有可能是增量同步（master判断runid是否一致）</p></li><li><p>除此之外的情况都是增量同步</p></li></ul><h4 id="8-2-1-全量同步"><a href="#8-2-1-全量同步" class="headerlink" title="8.2.1 全量同步"></a>8.2.1 全量同步</h4><p>Redis的全量同步过程主要分三个阶段：</p><ol><li><p>同步快照阶段：Master创建并发送<strong>快照</strong>给Slave,Slave载入并解析快照。Master同时将此阶段所产生的新的写命令存储到缓冲区。</p></li><li><p>同步写缓冲阶段：Master向Slave同步存储在缓冲区的写操作命令。</p></li><li><p>同步增量阶段：Master向Slave同步写操作命令。</p></li></ol><h4 id="8-2-2-增量同步"><a href="#8-2-2-增量同步" class="headerlink" title="8.2.2 增量同步"></a>8.2.2 增量同步</h4><ul><li><p>Redis增量同步主要指<strong>Slave完成初始化后开始正常工作</strong>时，<strong>Master发生的写操作同步到Slave的过程</strong>。</p></li><li><p>通常情况下，Master每执行一个写命令就会向Slave发送相同的<strong>写命令</strong>，然后Slave接收并执行。</p></li></ul><h2 id="九、Redis-Sentinel哨兵机制"><a href="#九、Redis-Sentinel哨兵机制" class="headerlink" title="九、Redis Sentinel哨兵机制"></a>九、Redis Sentinel哨兵机制</h2><p>Redis主从复制的缺点：没有办法对master进行动态选举，需要使用Sentinel机制完成动态选举。</p><p><strong>说明：</strong></p><ul><li><p>Sentinel(哨兵)进程是用于<strong>监控redis集群中Master主服务器工作的状态</strong></p></li><li><p>在Master主服务器发生故障的时候，可以实现Master和Slave服务器的切换，保证系统的高可用（HA）</p></li><li><p>其已经被集成在redis2.6+的版本中，Redis的哨兵模式到了2.8版本之后就稳定了下来。</p></li></ul><h3 id="9-1-哨兵进程的作用"><a href="#9-1-哨兵进程的作用" class="headerlink" title="9.1 哨兵进程的作用"></a>9.1 哨兵进程的作用</h3><ol><li><p><strong>监控(Monitoring):</strong> 哨兵(sentinel) 会不断地检查你的Master和Slave是否运作正常。</p></li><li><p><strong>提醒(Notification)</strong>： 当被监控的某个Redis节点出现问题时, 哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。</p></li><li><p><strong>自动故障迁移(Automatic failover)</strong>：当<strong>一个Master不能正常工作</strong>时，哨兵(sentinel) 会开始<strong>一次自动故障迁移操作</strong>。</p></li></ol><p>它会将失效Master的其中一个Slave升级为新的Master, 并让失效Master的其他Slave改为复制新的Master；</p><p>当客户端试图连接失效的Master时，集群也会向客户端返回新Master的地址，使得集群可以使用现在的Master替换失效Master。</p><p>Master和Slave服务器切换后，Master的redis.conf、Slave的redis.conf和sentinel.conf的配置文件的内容都会发生相应的改变，即，Master主服务器的redis.conf配置文件中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换。</p><h3 id="9-2-哨兵进程的工作方式"><a href="#9-2-哨兵进程的工作方式" class="headerlink" title="9.2 哨兵进程的工作方式"></a>9.2 哨兵进程的工作方式</h3><ol><li><p>每个Sentinel（哨兵）进程以<strong>每秒钟一次</strong>的频率向整个集群中的<strong>Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程</strong>发送一个 PING 命令。</p></li><li><p>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为<strong>主观下线</strong>（<strong>SDOWN</strong>）。</p></li><li><p>如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的<strong>所有 Sentinel（哨兵）</strong>进程要以每秒一次的频率<strong>确认Master主服务器</strong>的确<strong>进入了主观下线状态</strong>。</p></li><li><p>当<strong>有足够数量的 Sentinel（哨兵）</strong>进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为<strong>客观下线（ODOWN）</strong>。</p></li><li><p>在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。</p></li><li><p>当Master主服务器被 Sentinel（哨兵）进程标记为<strong>客观下线（ODOWN）</strong>时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</p></li></ol><p>若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。</p><h3 id="9-3-案例演示"><a href="#9-3-案例演示" class="headerlink" title="9.3 案例演示"></a>9.3 案例演示</h3><p>修改从机的sentinel.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#sentinel monitor &lt;master-name&gt; &lt;master ip&gt; &lt;master port&gt; &lt;quorum&gt;</span><br><span class="line">sentinel monitor mymaster 192.168.10.133 6379 1</span><br></pre></td></tr></table></figure><p><strong>其他配置项说明：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"># Example sentinel.conf</span><br><span class="line"> </span><br><span class="line"># 哨兵sentinel实例运行的端口 默认26379</span><br><span class="line">port 26379</span><br><span class="line"> </span><br><span class="line"># 哨兵sentinel的工作目录</span><br><span class="line">dir /tmp</span><br><span class="line"> </span><br><span class="line"># 哨兵sentinel监控的redis主节点的 ip port </span><br><span class="line"># master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span><br><span class="line"># quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span><br><span class="line"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br><span class="line">  sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"> </span><br><span class="line"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span><br><span class="line"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span><br><span class="line"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span><br><span class="line"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"> </span><br><span class="line"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span><br><span class="line">这个数字越小，完成failover所需的时间就越长，</span><br><span class="line">但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span><br><span class="line">可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="line"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面： </span><br><span class="line">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span><br><span class="line">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span><br><span class="line">#3.当想要取消一个正在进行的failover所需要的时间。  </span><br><span class="line">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span><br><span class="line"># 默认三分钟</span><br><span class="line"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"> </span><br><span class="line"># SCRIPTS EXECUTION</span><br><span class="line"> </span><br><span class="line">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span><br><span class="line">#对于脚本的运行结果有以下规则：</span><br><span class="line">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span><br><span class="line">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span><br><span class="line">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span><br><span class="line">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span><br><span class="line"> </span><br><span class="line">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，</span><br><span class="line">这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，</span><br><span class="line">一个是事件的类型，</span><br><span class="line">一个是事件的描述。</span><br><span class="line">如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span><br><span class="line">#通知脚本</span><br><span class="line"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span><br><span class="line">  sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"> </span><br><span class="line"># 客户端重新配置主节点参数脚本</span><br><span class="line"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span><br><span class="line"># 以下参数将会在调用脚本时传给脚本:</span><br><span class="line"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span><br><span class="line"># 目前&lt;state&gt;总是“failover”,</span><br><span class="line"># &lt;role&gt;是“leader”或者“observer”中的一个。 </span><br><span class="line"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span><br><span class="line"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span><br><span class="line"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span><br><span class="line"> sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br></pre></td></tr></table></figure><p>通过redis-sentinel启动哨兵服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-sentinel sentinel.conf</span><br></pre></td></tr></table></figure><h2 id="十、Redis-Cluster集群"><a href="#十、Redis-Cluster集群" class="headerlink" title="十、Redis Cluster集群"></a>十、Redis Cluster集群</h2><p>redis3.0以后推出的redis cluster 集群方案，redis cluster集群保证了高可用、高性能、高可扩展性。</p><p>架构细节:</p><p>(1)所有的redis节点彼此互联(<strong>PING-PONG机制</strong>),内部使用二进制协议优化传输速度和带宽.</p><p>(2)节点的fail是通过集群中超过半数的节点检测失效时才生效.</p><p>(3)客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可</p><p>(4)redis-cluster把所有的物理节点映射到[0-16383]<strong>slot</strong>上,cluster 负责维护</p><blockquote><p>Redis 集群中内置了 <strong>16384 个哈希槽</strong>，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点</p></blockquote><p>最小节点数：<strong>3台</strong></p><p>(1)<strong>节点失效判断</strong>：集群中所有master参与投票,如果<strong>半数以上master节点</strong>与其中一个master节点通信超过<strong>(cluster-node-timeout)</strong>,认为该master节点挂掉.</p><p>(2)<strong>集群失效判断</strong>:什么时候整个集群不可用(cluster_state:fail)? </p><p>Ø 如果集群任意master挂掉,且当前master没有slave，则集群进入fail状态。也可以理解成集群的[0-16383]slot映射不完全时进入fail状态。</p><p>如果集群超过半数以上master挂掉，无论是否有slave，集群进入fail状态。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis系统学习&quot;&gt;&lt;a href=&quot;#Redis系统学习&quot; class=&quot;headerlink&quot; title=&quot;Redis系统学习&quot;&gt;&lt;/a&gt;Redis系统学习&lt;/h1&gt;&lt;h2 id=&quot;一、什么是Redis&quot;&gt;&lt;a href=&quot;#一、什么是Redis&quot; class=&quot;headerlink&quot; title=&quot;一、什么是Redis?&quot;&gt;&lt;/a&gt;一、什么是Redis?&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Redis是用C语言开发的一个开源、免费、高性能&lt;strong&gt;键值对&lt;/strong&gt;内存数据库&lt;/li&gt;
&lt;li&gt;它提供5种数据类型来&lt;strong&gt;存储值&lt;/strong&gt;:字符串类型、散列类型、列表类型、集合类型、有序集合类型&lt;/li&gt;
&lt;li&gt;他是一种NoSQL数据库&lt;/li&gt;
&lt;li&gt;可用于缓存、内存数据库、消息队列等&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;1-1-什么是NoSQL&quot;&gt;&lt;a href=&quot;#1-1-什么是NoSQL&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是NoSQL?&quot;&gt;&lt;/a&gt;1.1 什么是NoSQL?&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;NoSQL,即Not-Only-SQL,泛指&lt;strong&gt;非关系型数据库&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;NoSQL数据库为了解决&lt;strong&gt;高并发&lt;/strong&gt;、&lt;strong&gt;高可用&lt;/strong&gt;、&lt;strong&gt;高可拓展&lt;/strong&gt;、&lt;strong&gt;大数据存储&lt;/strong&gt;问题而产生的数据库解决方案&lt;/li&gt;
&lt;li&gt;NoSQL可以作为关系型数据库的良好补充,但&lt;strong&gt;不是替代关系型数据库&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-2-NoSQL数据库分类&quot;&gt;&lt;a href=&quot;#1-2-NoSQL数据库分类&quot; class=&quot;headerlink&quot; title=&quot;1.2 NoSQL数据库分类&quot;&gt;&lt;/a&gt;1.2 NoSQL数据库分类&lt;/h3&gt;&lt;h4 id=&quot;1-2-1-键值存储数据库&quot;&gt;&lt;a href=&quot;#1-2-1-键值存储数据库&quot; class=&quot;headerlink&quot; title=&quot;1.2.1 键值存储数据库&quot;&gt;&lt;/a&gt;1.2.1 键值存储数据库&lt;/h4&gt;&lt;p&gt;相关产品: Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB&lt;/p&gt;
&lt;p&gt;典型应用: 内容&lt;strong&gt;缓存&lt;/strong&gt;,主要处理大量数据的&lt;strong&gt;高访问负载&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据模型: 一系列键值对&lt;/p&gt;
&lt;p&gt;优势: 快速&lt;strong&gt;查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;劣势: 存储的数据缺少结构化&lt;/p&gt;
&lt;h4 id=&quot;1-2-2-列存储数据库&quot;&gt;&lt;a href=&quot;#1-2-2-列存储数据库&quot; class=&quot;headerlink&quot; title=&quot;1.2.2 列存储数据库&quot;&gt;&lt;/a&gt;1.2.2 列存储数据库&lt;/h4&gt;&lt;p&gt;相关产品: Cassardra、HBase、Riak&lt;/p&gt;
&lt;p&gt;典型应用: &lt;strong&gt;分布式&lt;/strong&gt;的文件系统&lt;/p&gt;
&lt;p&gt;数据模型: 以列簇式存储,将同一列数据存在一起&lt;/p&gt;
&lt;p&gt;优势: 查找速度快、可拓展性强,更容易进行分布式拓展&lt;/p&gt;
&lt;p&gt;劣势: 功能相对局限&lt;/p&gt;
&lt;h4 id=&quot;1-2-3-文档型数据库&quot;&gt;&lt;a href=&quot;#1-2-3-文档型数据库&quot; class=&quot;headerlink&quot; title=&quot;1.2.3 文档型数据库&quot;&gt;&lt;/a&gt;1.2.3 文档型数据库&lt;/h4&gt;&lt;p&gt;说明: 与Key-Value类似,Value是&lt;strong&gt;结构化&lt;/strong&gt;的,即&lt;strong&gt;可嵌套&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相关产品: Mongo DB、Couch DB&lt;/p&gt;
&lt;p&gt;典型应用: Web应用&lt;/p&gt;
&lt;p&gt;数据模型: 一系列键值对&lt;/p&gt;
&lt;p&gt;优势: 数据结构要求不严格&lt;/p&gt;
&lt;h3 id=&quot;1-3-Redis的应用场景&quot;&gt;&lt;a href=&quot;#1-3-Redis的应用场景&quot; class=&quot;headerlink&quot; title=&quot;1.3 Redis的应用场景&quot;&gt;&lt;/a&gt;1.3 Redis的应用场景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;内存数据库(登陆信息、购物车信息、用户浏览记录等)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存服务器&lt;/strong&gt;(商品数据、广告数据等)&lt;/li&gt;
&lt;li&gt;解决分布式集群架构中的session分离问题(session共享)&lt;/li&gt;
&lt;li&gt;任务队列(秒杀、抢购、12306等)&lt;/li&gt;
&lt;li&gt;支持发布-订阅的消息模式&lt;/li&gt;
&lt;li&gt;应用排行榜&lt;/li&gt;
&lt;li&gt;网站访问统计&lt;/li&gt;
&lt;li&gt;数据过期处理(精确到毫秒)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;二、安装启动&quot;&gt;&lt;a href=&quot;#二、安装启动&quot; class=&quot;headerlink&quot; title=&quot;二、安装启动&quot;&gt;&lt;/a&gt;二、安装启动&lt;/h2&gt;&lt;h3 id=&quot;2-1-解压二进制安装包&quot;&gt;&lt;a href=&quot;#2-1-解压二进制安装包&quot; class=&quot;headerlink&quot; title=&quot;2.1 解压二进制安装包&quot;&gt;&lt;/a&gt;2.1 解压二进制安装包&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; tar -xf redis-3.2.9.tar.gz &lt;span class=&quot;comment&quot;&gt;# 加上-z参数可以显示解压进度&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; redis-3.2.9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; make &lt;span class=&quot;comment&quot;&gt;# 需要安装GCC&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; make install PREFIX=/redis &lt;span class=&quot;comment&quot;&gt;# 指定安装目录安装&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;2-2-启动&quot;&gt;&lt;a href=&quot;#2-2-启动&quot; class=&quot;headerlink&quot; title=&quot;2.2 启动&quot;&gt;&lt;/a&gt;2.2 启动&lt;/h3&gt;&lt;h4 id=&quot;2-2-1-前端启动&quot;&gt;&lt;a href=&quot;#2-2-1-前端启动&quot; class=&quot;headerlink&quot; title=&quot;2.2.1 前端启动&quot;&gt;&lt;/a&gt;2.2.1 前端启动&lt;/h4&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 直接运行bin/redis-server将以前端模式启动&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; ./redis-server&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; ctrl + c关闭&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;2-2-2-守护进程启动&quot;&gt;&lt;a href=&quot;#2-2-2-守护进程启动&quot; class=&quot;headerlink&quot; title=&quot;2.2.2 守护进程启动&quot;&gt;&lt;/a&gt;2.2.2 守护进程启动&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;修改&lt;code&gt;redis-conf&lt;/code&gt;配置文件,将文件中的&lt;code&gt;daemonize&lt;/code&gt;项改为&lt;code&gt;yes&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;bind 127.0.0.1改为bind &amp;lt;redis实例所在机器的真实IP&amp;gt;，如：bind 192.168.10.133（本地测试忽略）&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 指定配置文件位置启动&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; redis-server /usr/&lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt;/bin/redis.conf&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 检查是否启动成功&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; ps -ef | grep redis&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 关闭redis&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; ./redis-cli shutdown&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="NoSQL" scheme="http://yoursite.com/tags/NoSQL/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Git使用上手</title>
    <link href="http://yoursite.com/2019/11/24/Git%E4%BD%BF%E7%94%A8%E4%B8%8A%E6%89%8B/"/>
    <id>http://yoursite.com/2019/11/24/Git使用上手/</id>
    <published>2019-11-24T13:59:30.000Z</published>
    <updated>2019-11-24T14:07:40.158Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git使用上手"><a href="#Git使用上手" class="headerlink" title="Git使用上手"></a>Git使用上手</h1><h2 id="一、起步"><a href="#一、起步" class="headerlink" title="一、起步"></a>一、起步</h2><h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><p>Windows、Linux请自行前往<a href="https://git-scm.com/" target="_blank" rel="noopener">官网</a>,按照说明完成</p><p>这里说一下Mac版本,分两种情况:</p><ol><li>使用Apple提供的git发行版:这种情况使用的是Xcode内的<code>Command Line Tools</code></li><li>使用homebrew安装,强烈建议.因为Xcode内的git工具不太完整,缺少<code>gitk</code>、HTML格式的文档等</li></ol><h3 id="1-2-最小化配置"><a href="#1-2-最小化配置" class="headerlink" title="1.2 最小化配置"></a>1.2 最小化配置</h3><p>配置user.name和user.email</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name 'your_name'</span><br><span class="line">git config --global user.email 'your_email@domain.com'</span><br></pre></td></tr></table></figure><h4 id="1-2-1-config的三个作用域"><a href="#1-2-1-config的三个作用域" class="headerlink" title="1.2.1 config的三个作用域"></a>1.2.1 config的三个作用域</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --local  # 只针对某仓库</span><br><span class="line">git config --global # 对当前用户的所有仓库有效</span><br><span class="line">git config --system # 对该系统所有登陆的用户有效</span><br></pre></td></tr></table></figure><p>显示config的配置,加<code>--list</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --list --local</span><br><span class="line">git config --list --global</span><br><span class="line">git config --list --system</span><br></pre></td></tr></table></figure><h3 id="1-3-使用本地HTML文档"><a href="#1-3-使用本地HTML文档" class="headerlink" title="1.3 使用本地HTML文档"></a>1.3 使用本地HTML文档</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 例如查看git <span class="built_in">log</span>命令的使用文档</span></span><br><span class="line">git help log --web</span><br></pre></td></tr></table></figure><h2 id="二、建一个Git仓库"><a href="#二、建一个Git仓库" class="headerlink" title="二、建一个Git仓库"></a>二、建一个Git仓库</h2><h3 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1 初始化"></a>2.1 初始化</h3><p>此时存在两种场景:</p><ol><li>项目代码已经存在,要把项目加入Git版本控制</li><li>新建一个项目并使用Git来管理</li></ol><p>针对第一种情况,我们使用如下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 项目代码所在的文件夹</span><br><span class="line">git init</span><br></pre></td></tr></table></figure><p>针对第二种情况,则是使用如下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd 某个文件夹</span><br><span class="line">git init your_project # git会在当前目录下创建和项目名称同名的文件夹</span><br><span class="line">cd your_project</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-2-将文件加入Git版本控制"><a href="#2-2-将文件加入Git版本控制" class="headerlink" title="2.2 将文件加入Git版本控制"></a>2.2 将文件加入Git版本控制</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add 文件名 # 如果不将文件纳入版本控制,后续操作则会报错</span><br></pre></td></tr></table></figure><p>然后查看一下当前的状态:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status # 可查看当前git项目的状态,如哪些文件被修改,而哪些文件未被版本管理</span><br></pre></td></tr></table></figure><p>此时的文件,是存在于临时的缓存(<strong>暂存区</strong>)当中,要真正提交还需要执行以下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m "变更说明"</span><br></pre></td></tr></table></figure><p>这样我们就真正的将一个文件提交进版本了,我们还可以看一下当前的日志:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> git <span class="built_in">log</span>还有几种使用方法,例如</span></span><br><span class="line">git log 分支名     # 查看指定分支的历史;默认显示当前分支</span><br><span class="line">git log --all     # 显示所有分支的版本历史;默认显示当前分支</span><br><span class="line">git log --oneline # 简洁显示变更历史,每次变更只显示一行</span><br><span class="line">git log -n2       # 显示最近的两次变更</span><br><span class="line">git log --all --graph # 在上面的基础上,添加图形化的版本演进</span><br></pre></td></tr></table></figure><h4 id="2-2-1-新建和切换分支"><a href="#2-2-1-新建和切换分支" class="headerlink" title="2.2.1 新建和切换分支"></a>2.2.1 新建和切换分支</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 分支名</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个命令其实相当于创建分支和切换分支两条命令(因为-b参数)</span></span><br><span class="line">git branch 分支名   # 创建分支</span><br><span class="line">git checkout 分支名 # 切换分支</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前工作分支</span></span><br><span class="line">git branch -av</span><br></pre></td></tr></table></figure><h3 id="2-3-回退修改"><a href="#2-3-回退修改" class="headerlink" title="2.3 回退修改"></a>2.3 回退修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard # 彻底回退,暂存区和所有未提交的变更记录都会被清理</span><br></pre></td></tr></table></figure><h3 id="2-4-文件重命名"><a href="#2-4-文件重命名" class="headerlink" title="2.4 文件重命名"></a>2.4 文件重命名</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv 文件原名 文件现名</span><br></pre></td></tr></table></figure><h3 id="2-5-比较版本的差异"><a href="#2-5-比较版本的差异" class="headerlink" title="2.5 比较版本的差异"></a>2.5 比较版本的差异</h3><p>我们可以先查看一下历史:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --oneline</span></span><br><span class="line"></span><br><span class="line">af289f0 (HEAD -&gt; master) add OnlyMaster.rs</span><br><span class="line">1f39a38 add Hello.c</span><br><span class="line">1d294ca (test) hello.py renamed to Hello.py</span><br><span class="line">5f06285 add hello.py</span><br><span class="line">7499e49 add ReadMe</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff 7499e49 5f06285</span></span><br><span class="line"></span><br><span class="line">diff --git a/hello.py b/hello.py</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..ce47b77</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/hello.py</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+print("hello")</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><p>如果是使用当前版本进行比较,我们可以使用HEAD来指代:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff 5f06285 HEAD</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 和当前版本的上一个版本比较</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD~1 HEAD <span class="comment"># 其中数字可以替换,也可以使用~~来代表~2</span></span></span><br></pre></td></tr></table></figure><h3 id="2-6-删除分支"><a href="#2-6-删除分支" class="headerlink" title="2.6 删除分支"></a>2.6 删除分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d &lt;BranchName&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 有时候-d会删除不了,如果确认没有风险,可以使用-D</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -D &lt;BranchName&gt;</span></span><br></pre></td></tr></table></figure><h2 id="三、工作区与暂存区的认识"><a href="#三、工作区与暂存区的认识" class="headerlink" title="三、工作区与暂存区的认识"></a>三、工作区与暂存区的认识</h2><p>在<code>Git</code>当中,如果仅对文件作了<code>add</code>,但没有执行<code>commit</code>的话,文件会被存储进<strong>暂存区</strong>,而我们对文件进行创作修改的区域被称为<strong>工作区</strong></p><p>当我们将文件提交进<strong>暂存区</strong>后,依然可以在<strong>工作区</strong>继续修改我们的文件,而此时暂存区内的文件是<strong>独立于工作区</strong>的</p><p>这也就意味着,我们随时可以用<strong>暂存区</strong>内的版本<strong>覆盖工作区</strong>(如对工作区的修改不满意),而又不需要提交到版本控制,这在实践当中非常实用</p><p>补充:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -u # 将项目中所有工作区的文件一起提交到暂存区,而不需要一个个写文件名</span><br></pre></td></tr></table></figure><h2 id="四、图形化工具的介绍"><a href="#四、图形化工具的介绍" class="headerlink" title="四、图形化工具的介绍"></a>四、图形化工具的介绍</h2><p>直接在命令行输入<code>gitk</code>即可.</p><p>在MacOS上,如果使用的是Xcode提供的git是没有<code>gitk</code>工具的,需要使用brew安装一下</p><p>同时如果使用的是MacOS的暗主题,<code>gitk</code>的菜单栏上的文字会因为和底色相同的原因看不见,需要将鼠标移上去</p><h2 id="五、了解-git目录"><a href="#五、了解-git目录" class="headerlink" title="五、了解.git目录"></a>五、了解.git目录</h2><h3 id="5-1-HEAD文件"><a href="#5-1-HEAD文件" class="headerlink" title="5.1 HEAD文件"></a>5.1 HEAD文件</h3><p>首先,我们进入<code>.git</code>目录,尝试查看一下<code>HEAD</code>文件的内容:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat HEAD</span></span><br><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure><p>我们会发现<code>HEAD</code>文件其实是一个引用,而且指向的位置和当前工作的分支有关,如当前工作分支为<code>master</code></p><p>而假设我们当前切换分支到了<code>test</code>,那么此时HEAD文件就会指向<code>test</code>分支</p><h3 id="5-2-config文件"><a href="#5-2-config文件" class="headerlink" title="5.2 config文件"></a>5.2 config文件</h3><p>该文件下除了保存了该仓库下的核心配置之外,如果设置了仓库级别的用户配置,也会写入该文件</p><p>例如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --local user.username "test" # 修改当前仓库的用户名</span><br></pre></td></tr></table></figure><p>该文件内的内容则会变为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">repositoryformatversion = 0</span><br><span class="line">filemode = true</span><br><span class="line">bare = false</span><br><span class="line">logallrefupdates = true</span><br><span class="line">ignorecase = true</span><br><span class="line">precomposeunicode = true</span><br><span class="line">[user]</span><br><span class="line">username = test</span><br></pre></td></tr></table></figure><h3 id="5-3-refs目录"><a href="#5-3-refs目录" class="headerlink" title="5.3 refs目录"></a>5.3 refs目录</h3><p>在refs目录中,存在两个子目录:</p><ol><li>heads:里面有各个分支的子文件</li><li>tags:里面有各个标签(可看作是里程碑)的子文件</li></ol><p>先看heads目录,我们先查看一下master文件的内容:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat master</span></span><br><span class="line">1d294ca4f3dd9a0d2adef1528f18afd8ef3ca3d3</span><br></pre></td></tr></table></figure><p>我们还可以查看该文件是什么类型的:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -t master <span class="comment"># -t参数可以查看类型</span></span></span><br><span class="line">commit</span><br></pre></td></tr></table></figure><p>同样的,在tag目录下的文件里面存放的也是hash值,文件类型属于<code>tag</code></p><p>通过以下命令可以查看该<code>tag</code>是存放的哪一个<code>commit</code>对象:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -p tag名或tag的hash # -p参数可以查看内容</span><br></pre></td></tr></table></figure><h3 id="5-4-objects目录"><a href="#5-4-objects目录" class="headerlink" title="5.4 objects目录"></a>5.4 objects目录</h3><p>我们进入objects目录后,会看到很多两个字符组成的文件夹,以及pack(打包目录)</p><p>例如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -la</span></span><br><span class="line">.</span><br><span class="line">..</span><br><span class="line">06</span><br><span class="line">1d</span><br><span class="line">3d</span><br><span class="line">3e</span><br><span class="line">info</span><br><span class="line">pack</span><br></pre></td></tr></table></figure><p>我们随便挑选一个两个字符的目录进去,会发现内部文件是这样的:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> 06</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -la</span></span><br><span class="line">.</span><br><span class="line">..</span><br><span class="line">0fede4878a49e95fc444e9a243fa77edc710f4</span><br></pre></td></tr></table></figure><p>此时我们可以使用命令查看一下该对象的<strong>类型</strong>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 注意:此处的<span class="built_in">hash</span>为[两位长度的目录名 + 目录内文件名]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -t 060fede4878a49e95fc444e9a243fa77edc710f4</span></span><br><span class="line">tree</span><br></pre></td></tr></table></figure><p><code>tree</code>即目录类型</p><p>然后,我们可以查看该对象的<strong>内容</strong>,使用以下命令(参数: -p):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p 060fede4878a49e95fc444e9a243fa77edc710f4</span></span><br><span class="line">100644 blob 827ae020300b109c1e0e7ee58891e592d85df66cREADME.md</span><br><span class="line">100644 blob ce47b771f4fdb0c612745ca4b7c36695f3853f7chello.py</span><br></pre></td></tr></table></figure><p><code>blob</code>即是文件对象类型</p><p>我们可以进一步查看该<code>blob</code>类型:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -t 827ae020300b109c1e0e7ee58891e592d85df66c <span class="comment"># 查看类型</span></span></span><br><span class="line">blob</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p 827ae020300b109c1e0e7ee58891e592d85df66c <span class="comment"># 查看内容</span></span></span><br><span class="line">版本1:</span><br><span class="line">1+1=2</span><br></pre></td></tr></table></figure><p>至此,我们已经接触了git的如下几种类型:</p><ol><li>commit</li><li>tag</li><li>tree</li><li>blob</li></ol><p><strong>提示:</strong> 在<code>git</code>中,只要两个文件内容相同,那么对于git就是唯一的一个<code>blob</code></p><h4 id="5-4-1-commit、tree、blob三者的关系"><a href="#5-4-1-commit、tree、blob三者的关系" class="headerlink" title="5.4.1 commit、tree、blob三者的关系"></a>5.4.1 commit、tree、blob三者的关系</h4><p>我们可以通过<code>git log</code>命令查询到每一次的commit的hash,如果我们查询某次commit的内容:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p 7499e499b62642764e31475f <span class="comment"># hash不需要输入完整,只要能让git唯一找到目标就可以</span></span></span><br><span class="line">tree 3d5799c550fa4b815545f0255ad83d16debce7f0</span><br><span class="line">author SherlockGy &lt;sherlockgy@live.com&gt; 1574435790 +0800</span><br><span class="line">committer SherlockGy &lt;sherlockgy@live.com&gt; 1574435790 +0800</span><br><span class="line"></span><br><span class="line">add ReadMe</span><br></pre></td></tr></table></figure><p>我们会发现,commit对象中永远存储了一个tree,该tree代表截止该的commit为止,此git项目的所有内容,我们可以继续查看该tree的内容:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p 3d5799c550fa4b815545f02</span></span><br><span class="line">100644 blob 827ae020300b109c1e0e7ee58891e592d85df66cREADME.md</span><br></pre></td></tr></table></figure><p>也就是说,此commit提交后,我们的git项目中仅有一个文件,因此显示为一个<code>blob</code>对象;如果此时还有子目录的话,会显示为一个<code>tree</code>对象</p><p>这就是三种对象的关系</p><h2 id="六、使用分离头指针"><a href="#六、使用分离头指针" class="headerlink" title="六、使用分离头指针"></a>六、使用分离头指针</h2><p>现在假设有这样一个场景,我们要基于master的倒数第二个commit来创建一个分支,由于我们并不是基于最新的commit,所以要先<strong>把分支切换到commit上</strong>,而不是branch上,这就是<code>分离头指针</code></p><p>不过千万要谨慎操作,因为分离后的branch是没有名字的,如果不赋予名字,后面会导致修改丢失.</p><p>示例如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换到一个commit上,而不是branch,从而实现分离头指针</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout 1d294ca4f3dd9a0d2adef1528f18afd8ef3ca3d3</span></span><br><span class="line"></span><br><span class="line">注意：正在切换到 '1d294ca4f3dd9a0d2adef1528f18afd8ef3ca3d3'。</span><br><span class="line"></span><br><span class="line">您正处于分离头指针状态。您可以查看、做试验性的修改及提交，并且您可以在切换</span><br><span class="line">回一个分支时，丢弃在此状态下所做的提交而不对分支造成影响。</span><br><span class="line"></span><br><span class="line">如果您想要通过创建分支来保留在此状态下所做的提交，您可以通过在 switch 命令</span><br><span class="line">中添加参数 -c 来实现（现在或稍后）。例如：</span><br><span class="line"></span><br><span class="line">  git switch -c &lt;新分支名&gt;</span><br><span class="line"></span><br><span class="line">或者撤销此操作：</span><br><span class="line"></span><br><span class="line">  git switch -</span><br><span class="line"></span><br><span class="line">通过将配置变量 advice.detachedHead 设置为 false 来关闭此建议</span><br><span class="line"></span><br><span class="line">HEAD 目前位于 1d294ca hello.py renamed to Hello.py</span><br></pre></td></tr></table></figure><p>然后我们查看一下当前branch的情况:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"></span><br><span class="line">* (头指针分离于 1d294ca)</span><br><span class="line">  master</span><br><span class="line">  test</span><br><span class="line">  test2</span><br></pre></td></tr></table></figure><p>现在让我们来创建一个分离后的文件吧:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"我是分离头指针版本独有的文件内容"</span> &gt; 分离头指针.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add 分离头指针.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"add 分离头指针.txt"</span></span></span><br></pre></td></tr></table></figure><p>此时我们的新分支是没有名字的,如果我们切换到其他分支,有可能会导致该分支上的修改失效</p><p>这里我们尝试切换到master分支:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"></span><br><span class="line">警告：您正丢下 1 个提交，未和任何分支关联：</span><br><span class="line"></span><br><span class="line">  718daed add 分离头指针.txt</span><br><span class="line"></span><br><span class="line">如果您想要通过创建新分支保存它，这可能是一个好时候。</span><br><span class="line">如下操作：</span><br><span class="line"></span><br><span class="line"> git branch &lt;新分支名&gt; 718daed</span><br><span class="line"></span><br><span class="line">切换到分支 'master'</span><br></pre></td></tr></table></figure><p>所以这里我们按照提示,给没有名字的新分支一个名字:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch 实验分离头指针分支 718daed</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"></span><br><span class="line">* master</span><br><span class="line">  test</span><br><span class="line">  test2</span><br><span class="line">  实验分离头指针分支</span><br></pre></td></tr></table></figure><p>然后我们来一起看一下当前的log:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --all --graph</span></span><br><span class="line"></span><br><span class="line">* commit 718daedc590da60e771debf95657de8639d4e1db (实验分离头指针分支)</span><br><span class="line">| Author: SherlockGy &lt;sherlockgy@live.com&gt;</span><br><span class="line">| Date:   Sun Nov 24 15:58:00 2019 +0800</span><br><span class="line">|</span><br><span class="line">|     add 分离头指针.txt</span><br><span class="line">|</span><br><span class="line">| * commit af289f05ffcba29d35eaaa30e6105244ed67b0ed (HEAD -&gt; master)</span><br><span class="line">| | Author: SherlockGy &lt;sherlockgy@live.com&gt;</span><br><span class="line">| | Date:   Sun Nov 24 15:51:37 2019 +0800</span><br><span class="line">| |</span><br><span class="line">| |     add OnlyMaster.rs</span><br><span class="line">| |</span><br><span class="line">| | * commit 5467beb8fdc754ddb14e31dfcd58790dfd9337fb (test2)</span><br><span class="line">| |/  Author: SherlockGy &lt;sherlockgy@live.com&gt;</span><br><span class="line">| |   Date:   Sun Nov 24 15:48:25 2019 +0800</span><br><span class="line">| |</span><br><span class="line">| |       add HelloAgain.go</span><br><span class="line">| |</span><br><span class="line">| * commit 1f39a383ff3c1140affc1e128b0de17b1c909238</span><br><span class="line">|/  Author: SherlockGy &lt;sherlockgy@live.com&gt;</span><br><span class="line">|   Date:   Sun Nov 24 15:22:02 2019 +0800</span><br><span class="line">|</span><br><span class="line">|       add Hello.c</span><br><span class="line">|</span><br><span class="line">* commit 1d294ca4f3dd9a0d2adef1528f18afd8ef3ca3d3 (test)</span><br><span class="line">| Author: SherlockGy &lt;sherlockgy@live.com&gt;</span><br><span class="line">| Date:   Sat Nov 23 20:26:10 2019 +0800</span><br><span class="line">|</span><br><span class="line">|     hello.py renamed to Hello.py</span><br><span class="line">|</span><br><span class="line">* commit 5f0628574c79dbc9ebfb1856ec882a80e5946c2b</span><br><span class="line">| Author: SherlockGy &lt;sherlockgy@live.com&gt;</span><br><span class="line">| Date:   Sat Nov 23 19:37:30 2019 +0800</span><br><span class="line">|</span><br><span class="line">|     add hello.py</span><br><span class="line">|</span><br><span class="line">* commit 7499e499b62642764e31475f4119dc253ca2f151</span><br><span class="line">  Author: SherlockGy &lt;sherlockgy@live.com&gt;</span><br><span class="line">  Date:   Fri Nov 22 23:16:30 2019 +0800</span><br><span class="line"></span><br><span class="line">      add ReadMe</span><br></pre></td></tr></table></figure><p>由此可见,我们顺利得在master之前的版本上创建了分支</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Git使用上手&quot;&gt;&lt;a href=&quot;#Git使用上手&quot; class=&quot;headerlink&quot; title=&quot;Git使用上手&quot;&gt;&lt;/a&gt;Git使用上手&lt;/h1&gt;&lt;h2 id=&quot;一、起步&quot;&gt;&lt;a href=&quot;#一、起步&quot; class=&quot;headerlink&quot; title=&quot;一、起步&quot;&gt;&lt;/a&gt;一、起步&lt;/h2&gt;&lt;h3 id=&quot;1-1-安装&quot;&gt;&lt;a href=&quot;#1-1-安装&quot; class=&quot;headerlink&quot; title=&quot;1.1 安装&quot;&gt;&lt;/a&gt;1.1 安装&lt;/h3&gt;&lt;p&gt;Windows、Linux请自行前往&lt;a href=&quot;https://git-scm.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;,按照说明完成&lt;/p&gt;
&lt;p&gt;这里说一下Mac版本,分两种情况:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用Apple提供的git发行版:这种情况使用的是Xcode内的&lt;code&gt;Command Line Tools&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用homebrew安装,强烈建议.因为Xcode内的git工具不太完整,缺少&lt;code&gt;gitk&lt;/code&gt;、HTML格式的文档等&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;1-2-最小化配置&quot;&gt;&lt;a href=&quot;#1-2-最小化配置&quot; class=&quot;headerlink&quot; title=&quot;1.2 最小化配置&quot;&gt;&lt;/a&gt;1.2 最小化配置&lt;/h3&gt;&lt;p&gt;配置user.name和user.email&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.name &#39;your_name&#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.email &#39;your_email@domain.com&#39;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;1-2-1-config的三个作用域&quot;&gt;&lt;a href=&quot;#1-2-1-config的三个作用域&quot; class=&quot;headerlink&quot; title=&quot;1.2.1 config的三个作用域&quot;&gt;&lt;/a&gt;1.2.1 config的三个作用域&lt;/h4&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git config --local  # 只针对某仓库&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global # 对当前用户的所有仓库有效&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --system # 对该系统所有登陆的用户有效&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;显示config的配置,加&lt;code&gt;--list&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git config --list --local&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --list --global&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --list --system&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;1-3-使用本地HTML文档&quot;&gt;&lt;a href=&quot;#1-3-使用本地HTML文档&quot; class=&quot;headerlink&quot; title=&quot;1.3 使用本地HTML文档&quot;&gt;&lt;/a&gt;1.3 使用本地HTML文档&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 例如查看git &lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;命令的使用文档&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git help log --web&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;二、建一个Git仓库&quot;&gt;&lt;a href=&quot;#二、建一个Git仓库&quot; class=&quot;headerlink&quot; title=&quot;二、建一个Git仓库&quot;&gt;&lt;/a&gt;二、建一个Git仓库&lt;/h2&gt;&lt;h3 id=&quot;2-1-初始化&quot;&gt;&lt;a href=&quot;#2-1-初始化&quot; class=&quot;headerlink&quot; title=&quot;2.1 初始化&quot;&gt;&lt;/a&gt;2.1 初始化&lt;/h3&gt;&lt;p&gt;此时存在两种场景:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;项目代码已经存在,要把项目加入Git版本控制&lt;/li&gt;
&lt;li&gt;新建一个项目并使用Git来管理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;针对第一种情况,我们使用如下命令:&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd 项目代码所在的文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git init&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;针对第二种情况,则是使用如下命令:&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd 某个文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git init your_project # git会在当前目录下创建和项目名称同名的文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd your_project&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="Git" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/"/>
    
    
      <category term="版本控制" scheme="http://yoursite.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Go语言实用库02——文本编码</title>
    <link href="http://yoursite.com/2019/10/21/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%94%A8%E5%BA%9302%E2%80%94%E2%80%94%E6%96%87%E6%9C%AC%E7%BC%96%E7%A0%81/"/>
    <id>http://yoursite.com/2019/10/21/Go语言实用库02——文本编码/</id>
    <published>2019-10-21T12:53:56.000Z</published>
    <updated>2019-10-26T16:49:26.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h2><p>假设有一文本，编码为<code>GBK</code>，文本内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你好，中国</span><br><span class="line">我爱你，中国！</span><br></pre></td></tr></table></figure><p>由于<code>Go</code>默认按照<code>utf-8</code>的码表去解析，所以会导致乱码</p><p>在<code>Go</code>官方提供的库里面，有一个库可以解决这个问题，但是不包含在标准库内，需要使用<code>go get golang.org/x/text</code>下载</p><blockquote><p><strong>提醒：</strong>下载之前请一定配置代理，可参考<a href="https://sherlockgy.github.io/2019/09/24/Go%E8%AF%AD%E8%A8%80%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">这篇文章</a></p></blockquote><p>使用方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"golang.org/x/text/encoding/simplifiedchinese"</span></span><br><span class="line"><span class="string">"golang.org/x/text/transform"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="string">"/Users/sherlockgy/Desktop/test.txt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, e := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"打开文件错误！"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码转换</span></span><br><span class="line">newReader := transform.NewReader(file, simplifiedchinese.GBK.NewDecoder())</span><br><span class="line"></span><br><span class="line">newBytes, e := ioutil.ReadAll(newReader)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"读取内容错误！"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, newBytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编码猜测"><a href="#编码猜测" class="headerlink" title="编码猜测"></a>编码猜测</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="string">"/Users/sherlockgy/Desktop/test.txt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, e := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"打开文件错误！"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码猜测</span></span><br><span class="line">encoding := determineEncoding(file)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码转换</span></span><br><span class="line">newReader := transform.NewReader(file, encoding.NewDecoder())</span><br><span class="line"></span><br><span class="line">newBytes, e := ioutil.ReadAll(newReader)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"读取内容错误！"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, newBytes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 猜测编码类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">determineEncoding</span><span class="params">(r io.Reader)</span> <span class="title">encoding</span>.<span class="title">Encoding</span></span> &#123;</span><br><span class="line">bytes, err := bufio.NewReader(r).Peek(<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">encoding, name, certain := charset.DetermineEncoding(bytes, <span class="string">""</span>)</span><br><span class="line">fmt.Printf(<span class="string">"编码类型为：%s\n是否确定：%v\n"</span>, name, certain)</span><br><span class="line"><span class="keyword">return</span> encoding</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编码转换&quot;&gt;&lt;a href=&quot;#编码转换&quot; class=&quot;headerlink&quot; title=&quot;编码转换&quot;&gt;&lt;/a&gt;编码转换&lt;/h2&gt;&lt;p&gt;假设有一文本，编码为&lt;code&gt;GBK&lt;/code&gt;，文本内容为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;你好，中国&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;我爱你，中国！&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于&lt;code&gt;Go&lt;/code&gt;默认按照&lt;code&gt;utf-8&lt;/code&gt;的码表去解析，所以会导致乱码&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Go&lt;/code&gt;官方提供的库里面，有一个库可以解决这个问题，但是不包含在标准库内，需要使用&lt;code&gt;go get golang.org/x/text&lt;/code&gt;下载&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;提醒：&lt;/strong&gt;下载之前请一定配置代理，可参考&lt;a href=&quot;https://sherlockgy.github.io/2019/09/24/Go%E8%AF%AD%E8%A8%80%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用方法：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;golang.org/x/text/encoding/simplifiedchinese&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;golang.org/x/text/transform&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;io/ioutil&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;os&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; path = &lt;span class=&quot;string&quot;&gt;&quot;/Users/sherlockgy/Desktop/test.txt&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	file, e := os.Open(path)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; e != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;panic&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;打开文件错误！&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 编码转换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	newReader := transform.NewReader(file, simplifiedchinese.GBK.NewDecoder())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	newBytes, e := ioutil.ReadAll(newReader)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; e != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;panic&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;读取内容错误！&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fmt.Printf(&lt;span class=&quot;string&quot;&gt;&quot;%s\n&quot;&lt;/span&gt;, newBytes)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;编码猜测&quot;&gt;&lt;a href=&quot;#编码猜测&quot; class=&quot;headerlink&quot; title=&quot;编码猜测&quot;&gt;&lt;/a&gt;编码猜测&lt;/h2&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; path = &lt;span class=&quot;string&quot;&gt;&quot;/Users/sherlockgy/Desktop/test.txt&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	file, e := os.Open(path)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; e != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;panic&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;打开文件错误！&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 编码猜测&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	encoding := determineEncoding(file)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 编码转换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	newReader := transform.NewReader(file, encoding.NewDecoder())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	newBytes, e := ioutil.ReadAll(newReader)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; e != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;panic&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;读取内容错误！&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fmt.Printf(&lt;span class=&quot;string&quot;&gt;&quot;%s\n&quot;&lt;/span&gt;, newBytes)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 猜测编码类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;determineEncoding&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(r io.Reader)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;encoding&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Encoding&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	bytes, err := bufio.NewReader(r).Peek(&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;panic&lt;/span&gt;(err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	encoding, name, certain := charset.DetermineEncoding(bytes, &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fmt.Printf(&lt;span class=&quot;string&quot;&gt;&quot;编码类型为：%s\n是否确定：%v\n&quot;&lt;/span&gt;, name, certain)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; encoding&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="Golang" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Golang/"/>
    
    
      <category term="Golang" scheme="http://yoursite.com/tags/Golang/"/>
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Go语言实用库01——正则表达式</title>
    <link href="http://yoursite.com/2019/10/21/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%94%A8%E5%BA%9301%E2%80%94%E2%80%94%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/10/21/Go语言实用库01——正则表达式/</id>
    <published>2019-10-21T12:53:56.000Z</published>
    <updated>2019-10-25T17:11:17.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go语言中的正则表达式"><a href="#Go语言中的正则表达式" class="headerlink" title="Go语言中的正则表达式"></a>Go语言中的正则表达式</h1><h2 id="一、正则表达式匹配"><a href="#一、正则表达式匹配" class="headerlink" title="一、正则表达式匹配"></a>一、正则表达式匹配</h2><h3 id="1-1-匹配单个子串"><a href="#1-1-匹配单个子串" class="headerlink" title="1.1 匹配单个子串"></a>1.1 匹配单个子串</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"my email is sherlockjgy@gmail.com"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 正则表达式规则声明，解析正则表达式</span></span><br><span class="line"><span class="comment">// 返回Regexp对象，用于后续操作</span></span><br><span class="line">compile, err := regexp.Compile(<span class="string">`[A-Za-z0-9]+@[A-Za-z0-9]+\.[A-Za-z0-9]+`</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"你的正则表达式存在语法错误！"</span>)</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 从目标字符串当中查找是否存在符合正则表达式规则的字符子串</span></span><br><span class="line">    <span class="comment">// 返回true or false</span></span><br><span class="line">isMatch := compile.MatchString(str)</span><br><span class="line">fmt.Printf(<span class="string">"目标字符串中是否存在符合规则的子串：%v\n"</span>, isMatch) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从目标字符串当中查找并返回符合正则表达式规则的字符子串</span></span><br><span class="line">    <span class="comment">// 若不存在，则返回空串</span></span><br><span class="line">matchString := compile.FindString(str)</span><br><span class="line">fmt.Println(matchString) <span class="comment">// sherlockjgy@gmail.com</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>提醒：</strong>建议将正则表达式规则书写在【`】引号（键盘1左边的按键）中，这样Go语言不会解析表达式中的转义字符，否则每个斜杠都需要双斜杠代替</p></blockquote><h3 id="1-2-匹配多个子串"><a href="#1-2-匹配多个子串" class="headerlink" title="1.2 匹配多个子串"></a>1.2 匹配多个子串</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">`my email are sherlockjgy@gmail.com</span></span><br><span class="line"><span class="string">and shelockgy@live.com`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 正则表达式规则声明，解析正则表达式</span></span><br><span class="line"><span class="comment">// 返回Regexp对象，用于后续操作</span></span><br><span class="line">compile, err := regexp.Compile(<span class="string">`[A-Za-z0-9]+@[A-Za-z0-9]+\.[A-Za-z0-9]+`</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"你的正则表达式存在语法错误！"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从目标字符串当中查找并返回【多个】符合正则表达式规则的字符子串</span></span><br><span class="line">    <span class="comment">// 第二个参数代表需要查询多少个符合要求的子串，-1代表查询所有</span></span><br><span class="line">matchString := compile.FindAllString(str, <span class="number">-1</span>)</span><br><span class="line">fmt.Println(matchString, <span class="built_in">len</span>(matchString)) <span class="comment">// [sherlockjgy@gmail.com shelockgy@live.com] 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-字符串匹配并分组"><a href="#1-3-字符串匹配并分组" class="headerlink" title="1.3 字符串匹配并分组"></a>1.3 字符串匹配并分组</h3><p>在正则表达式中运用小括号，可以对被匹配成功对子串进行分组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">`my email are sherlockjgy@gmail.com</span></span><br><span class="line"><span class="string">and shelockgy@live.com</span></span><br><span class="line"><span class="string">and helloworld@test.com.cn`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 正则表达式规则声明，解析正则表达式</span></span><br><span class="line"><span class="comment">// 返回Regexp对象，用于后续操作</span></span><br><span class="line">compile, err := regexp.Compile(<span class="string">`([A-Za-z0-9]+)@([A-Za-z0-9]+)([.A-Za-z0-9]+)`</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"你的正则表达式存在语法错误！"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个二维数组</span></span><br><span class="line">matchString := compile.FindAllStringSubmatch(str, <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> matchString &#123;</span><br><span class="line">fmt.Println(value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[sherlockjgy@gmail.com sherlockjgy gmail .com]</span><br><span class="line">[shelockgy@live.com shelockgy live .com]</span><br><span class="line">[helloworld@test.com.cn helloworld test .com.cn]</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Go语言中的正则表达式&quot;&gt;&lt;a href=&quot;#Go语言中的正则表达式&quot; class=&quot;headerlink&quot; title=&quot;Go语言中的正则表达式&quot;&gt;&lt;/a&gt;Go语言中的正则表达式&lt;/h1&gt;&lt;h2 id=&quot;一、正则表达式匹配&quot;&gt;&lt;a href=&quot;#一、正则表达式匹配&quot; class=&quot;headerlink&quot; title=&quot;一、正则表达式匹配&quot;&gt;&lt;/a&gt;一、正则表达式匹配&lt;/h2&gt;&lt;h3 id=&quot;1-1-匹配单个子串&quot;&gt;&lt;a href=&quot;#1-1-匹配单个子串&quot; class=&quot;headerlink&quot; title=&quot;1.1 匹配单个子串&quot;&gt;&lt;/a&gt;1.1 匹配单个子串&lt;/h3&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; str = &lt;span class=&quot;string&quot;&gt;&quot;my email is sherlockjgy@gmail.com&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 正则表达式规则声明，解析正则表达式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 返回Regexp对象，用于后续操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	compile, err := regexp.Compile(&lt;span class=&quot;string&quot;&gt;`[A-Za-z0-9]+@[A-Za-z0-9]+\.[A-Za-z0-9]+`&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;panic&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;你的正则表达式存在语法错误！&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 从目标字符串当中查找是否存在符合正则表达式规则的字符子串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 返回true or false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	isMatch := compile.MatchString(str)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fmt.Printf(&lt;span class=&quot;string&quot;&gt;&quot;目标字符串中是否存在符合规则的子串：%v\n&quot;&lt;/span&gt;, isMatch) &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 从目标字符串当中查找并返回符合正则表达式规则的字符子串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 若不存在，则返回空串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	matchString := compile.FindString(str)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fmt.Println(matchString) &lt;span class=&quot;comment&quot;&gt;// sherlockjgy@gmail.com&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;提醒：&lt;/strong&gt;建议将正则表达式规则书写在【`】引号（键盘1左边的按键）中，这样Go语言不会解析表达式中的转义字符，否则每个斜杠都需要双斜杠代替&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-2-匹配多个子串&quot;&gt;&lt;a href=&quot;#1-2-匹配多个子串&quot; class=&quot;headerlink&quot; title=&quot;1.2 匹配多个子串&quot;&gt;&lt;/a&gt;1.2 匹配多个子串&lt;/h3&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; str = &lt;span class=&quot;string&quot;&gt;`my email are sherlockjgy@gmail.com&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;and shelockgy@live.com`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 正则表达式规则声明，解析正则表达式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 返回Regexp对象，用于后续操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	compile, err := regexp.Compile(&lt;span class=&quot;string&quot;&gt;`[A-Za-z0-9]+@[A-Za-z0-9]+\.[A-Za-z0-9]+`&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;panic&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;你的正则表达式存在语法错误！&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 从目标字符串当中查找并返回【多个】符合正则表达式规则的字符子串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 第二个参数代表需要查询多少个符合要求的子串，-1代表查询所有&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	matchString := compile.FindAllString(str, &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fmt.Println(matchString, &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;(matchString)) &lt;span class=&quot;comment&quot;&gt;// [sherlockjgy@gmail.com shelockgy@live.com] 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;1-3-字符串匹配并分组&quot;&gt;&lt;a href=&quot;#1-3-字符串匹配并分组&quot; class=&quot;headerlink&quot; title=&quot;1.3 字符串匹配并分组&quot;&gt;&lt;/a&gt;1.3 字符串匹配并分组&lt;/h3&gt;&lt;p&gt;在正则表达式中运用小括号，可以对被匹配成功对子串进行分组&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; str = &lt;span class=&quot;string&quot;&gt;`my email are sherlockjgy@gmail.com&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;and shelockgy@live.com&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;and helloworld@test.com.cn`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 正则表达式规则声明，解析正则表达式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 返回Regexp对象，用于后续操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	compile, err := regexp.Compile(&lt;span class=&quot;string&quot;&gt;`([A-Za-z0-9]+)@([A-Za-z0-9]+)([.A-Za-z0-9]+)`&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;panic&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;你的正则表达式存在语法错误！&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 返回一个二维数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	matchString := compile.FindAllStringSubmatch(str, &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; _, value := &lt;span class=&quot;keyword&quot;&gt;range&lt;/span&gt; matchString &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		fmt.Println(value)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[sherlockjgy@gmail.com sherlockjgy gmail .com]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[shelockgy@live.com shelockgy live .com]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[helloworld@test.com.cn helloworld test .com.cn]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="Golang" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Golang/"/>
    
    
      <category term="Golang" scheme="http://yoursite.com/tags/Golang/"/>
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到实战（二）</title>
    <link href="http://yoursite.com/2019/09/28/Go%E8%AF%AD%E8%A8%80%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2019/09/28/Go语言从入门到实战（二）/</id>
    <published>2019-09-27T17:23:02.000Z</published>
    <updated>2019-09-28T14:48:40.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go语言从入门到实战（二）"><a href="#Go语言从入门到实战（二）" class="headerlink" title="Go语言从入门到实战（二）"></a>Go语言从入门到实战（二）</h1><h2 id="一、变量与常量"><a href="#一、变量与常量" class="headerlink" title="一、变量与常量"></a>一、变量与常量</h2><h3 id="1-1-变量"><a href="#1-1-变量" class="headerlink" title="1.1 变量"></a>1.1 变量</h3><p>我们先来看一下<code>Go</code>语言当中的标准变量声明方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">"tom"</span></span><br></pre></td></tr></table></figure><p>其中，<code>var</code>是声明变量的关键字，而<code>name</code>就是我们的变量名。需要特别注意的是，作为类型的<code>string</code>被放在了变量名的后面。这样设计主要是为了引导程序员使用<strong>类型自动推导</strong>，从而省略变量类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用类型推导</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"tom"</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>拓展：</strong>这种类型后置的设计在现代编程语言当中已经非常常见了，如<code>Scala</code>、<code>Kotlin</code>、<code>Swift</code>、<code>Rust</code>等</p></blockquote><p>而当我们需要一次性声明多个变量的时候，则可以使用代码块来做：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">name    <span class="keyword">string</span></span><br><span class="line">age     <span class="keyword">int</span></span><br><span class="line">address <span class="keyword">string</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当我们的变量是局部变量的时候，我们还可以使用<code>简短声明</code>的方法来声明变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">name := <span class="string">"tom"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们有几个注意点需要强调：</p><ol><li>简短声明<strong>仅可使用于局部</strong>，全局变量必须使用<code>var</code>关键字声明</li><li><strong>局部变量</strong>一经声明必须被使用，否则将会编译错误；如果需要丢弃该变量，则使用<strong>下划线</strong><code>_</code>命名变量</li><li>全局变量是<code>包</code>级别的变量，而不是以单个文件作为作用域；全局变量可以声明但不使用</li><li>局部变量如果是不同类型（包括int32与int64也不是相同类型），无论如何都不能直接运算，而需要显式类型转换</li></ol><h3 id="1-2-常量"><a href="#1-2-常量" class="headerlink" title="1.2 常量"></a>1.2 常量</h3><p><code>Go</code>语言的常量使用<code>const</code>关键字进行声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name <span class="keyword">string</span> = <span class="string">"tom"</span></span><br></pre></td></tr></table></figure><p>同样，变量类型是可以省略的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">"tom"</span></span><br></pre></td></tr></table></figure><p>当我们需要一次性声明多个常量的时候，同样可以使用代码块来做：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">name = <span class="string">"tom"</span></span><br><span class="line">age  = <span class="number">11</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>关于常量，我们也有几点需要强调的：</p><ol><li>常量声明<strong>必须使用关键字的方式</strong>，不能使用简短声明</li><li>常量可以声明后不使用</li><li>常量如果是以<strong>省略变量类型的方式</strong>声明的，<code>整型</code>和<code>浮点型</code>变量之间可以直接运算</li></ol><h3 id="1-3-基于常量的枚举类型"><a href="#1-3-基于常量的枚举类型" class="headerlink" title="1.3 基于常量的枚举类型"></a>1.3 基于常量的枚举类型</h3><p><code>Go</code>并不提供专门的枚举类型关键字，如其他语言当中常见的<code>enum</code>。而是通过常量的关键字<code>const</code> + <code>iota</code>的方式，实现枚举</p><p>我们先来看一段示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a = <span class="number">9</span>     <span class="comment">// iota值为0，虽然没有被使用，iota依然存在</span></span><br><span class="line">b = <span class="literal">iota</span>  <span class="comment">// iota值为1，所以b为1</span></span><br><span class="line">c         <span class="comment">// iota值为2，c继续使用b的表达式，所以c为2</span></span><br><span class="line">d = <span class="number">10</span>    <span class="comment">// iota值为3，虽然没有被使用，iota依然存在</span></span><br><span class="line">e = <span class="literal">iota</span>  <span class="comment">// iota值为4，所以e为4</span></span><br><span class="line">f = <span class="string">"abc"</span> <span class="comment">// iota值为5，f为"abc"</span></span><br><span class="line">g         <span class="comment">// iota值为6，g继续使用f的表达式，所以g为"abc"</span></span><br><span class="line">h = <span class="literal">iota</span>  <span class="comment">// iota值为7，所以h为7</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> i = <span class="literal">iota</span> <span class="comment">// 新的const，iota重制为0，所以i为0</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"a = %v, b = %v, c = %v, "</span>, a, b, c)</span><br><span class="line">fmt.Printf(<span class="string">"d = %v, e = %v, f = %v, "</span>, d, e, f)</span><br><span class="line">fmt.Printf(<span class="string">"g = %v, h = %v, i = %v"</span>, g, h, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 9, b = 1, c = 2, d = 10, e = 4, f = abc, g = abc, h = 7, i = 0</span><br></pre></td></tr></table></figure><p>通过上述例子，可以总结为：</p><ol><li><code>iota</code>不管是否被使用，在同一个<code>const</code>代码块内，都会从0开始不断自增；如果遇到新的<code>const</code>，则重制为0</li><li>如果<code>枚举项</code>没有声明表达式，则继承上一个<code>枚举项</code>的表达式</li></ol><h2 id="二、Go语言的数据类型"><a href="#二、Go语言的数据类型" class="headerlink" title="二、Go语言的数据类型"></a>二、Go语言的数据类型</h2><h3 id="2-1-布尔与字符串类型"><a href="#2-1-布尔与字符串类型" class="headerlink" title="2.1 布尔与字符串类型"></a>2.1 布尔与字符串类型</h3><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">bool</td><td style="text-align:center">布尔类型（true、flase）</td></tr><tr><td style="text-align:center">string</td><td style="text-align:center">字符串</td></tr></tbody></table><h3 id="2-2-无符号整数类型"><a href="#2-2-无符号整数类型" class="headerlink" title="2.2 无符号整数类型"></a>2.2 无符号整数类型</h3><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">uint</td><td style="text-align:center">长度由系统架构类型决定</td></tr><tr><td style="text-align:center">uint8</td><td style="text-align:center">长度为8位，即1字节（0～255）</td></tr><tr><td style="text-align:center">uint16</td><td style="text-align:center">长度为16位，即2字节（0 到 65535）</td></tr><tr><td style="text-align:center">uint32</td><td style="text-align:center">长度为32位，即4字节（0 到 4294967295）</td></tr><tr><td style="text-align:center">uint64</td><td style="text-align:center">长度为64位，即8字节（0 到 18446744073709551615）</td></tr><tr><td style="text-align:center">uintptr</td><td style="text-align:center">长度为8位，即1字节（0～255）</td></tr></tbody></table><h3 id="2-3-有符号整数类型"><a href="#2-3-有符号整数类型" class="headerlink" title="2.3 有符号整数类型"></a>2.3 有符号整数类型</h3><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">int</td><td style="text-align:center">长度由系统架构类型决定</td></tr><tr><td style="text-align:center">int8</td><td style="text-align:center">长度为8位，即1字节（-128 到 127）</td></tr><tr><td style="text-align:center">int16</td><td style="text-align:center">长度为16位，即2字节（-32768 到 32767）</td></tr><tr><td style="text-align:center">int32</td><td style="text-align:center">长度为32位，即4字节（-2147483648 到 2147483647）</td></tr><tr><td style="text-align:center">int64</td><td style="text-align:center">长度为64位，即8字节（-9223372036854775808 到 9223372036854775807）</td></tr></tbody></table><p><strong>注意：</strong>虽然<code>int</code>类型和<code>uint</code>类型长度没有指定，但是不代表它们可以像<code>Python</code>这种语言一样不限制<code>int</code>的大小。例如在64位操作系统上，<code>int</code>和<code>uint</code>的最大值就是<code>int64</code>和<code>uint64</code>的最大值</p><p>我们也可以在代码中轻松获得每个数值类型的最大最小值，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(math.MaxInt8)</span><br><span class="line">fmt.Println(math.MinInt8)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那如果我们需要操作的数字的大小，<code>int64</code>已经无法满足了，要怎么办呢？</p><p>我们可以使用<code>math/big</code>包下的函数进行处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a, _ := <span class="built_in">new</span>(big.Int).SetString(<span class="string">"999999999999999999999999999999999999"</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这一点，此处就不再多说了，毕竟这不是目前的重点。如果需要更多内容，可以直接查找相关API文档</p><h3 id="2-4-浮点数类型"><a href="#2-4-浮点数类型" class="headerlink" title="2.4 浮点数类型"></a>2.4 浮点数类型</h3><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">float32</td><td style="text-align:center">长度为4个字节，IEEE-754 32位浮点型数</td></tr><tr><td style="text-align:center">float64</td><td style="text-align:center">长度为8个字节，IEEE-754 64位浮点型数</td></tr></tbody></table><p>不同于整型当中的<code>int</code>类型，浮点数类型要么是<code>float32</code>要么就是<code>float64</code>，不存在<code>float</code>这个类型</p><p>在使用<code>简短声明</code>的时候，编译器会根据当前计算机的架构自动进行推断，从而决定使用<code>float32</code>还是<code>float64</code></p><h4 id="2-4-1-浮点数与字符串类型的转换"><a href="#2-4-1-浮点数与字符串类型的转换" class="headerlink" title="2.4.1 浮点数与字符串类型的转换"></a>2.4.1 浮点数与字符串类型的转换</h4><p>浮点数转换为字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> f64 <span class="keyword">float64</span> = <span class="number">1.12</span></span><br><span class="line">str := strconv.FormatFloat(f64, <span class="string">'E'</span>, <span class="number">-1</span>, <span class="number">64</span>)</span><br><span class="line">str2 := fmt.Sprintf(<span class="string">"%v"</span>, f64)</span><br><span class="line">fmt.Println(str)  <span class="comment">// 1.12E+00</span></span><br><span class="line">fmt.Println(str2) <span class="comment">// 1.12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串转换为浮点数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">"3.1415926"</span></span><br><span class="line">float, _ := strconv.ParseFloat(s, <span class="number">64</span>)</span><br><span class="line">fmt.Println(float)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-复数类型"><a href="#2-5-复数类型" class="headerlink" title="2.5 复数类型"></a>2.5 复数类型</h3><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">complex64</td><td style="text-align:center">32 位复数（实部与虚部分别32位）</td></tr><tr><td style="text-align:center">complex128</td><td style="text-align:center">64 位实数和虚数（实部与虚部分别64位）</td></tr></tbody></table><h3 id="2-6-别名类型"><a href="#2-6-别名类型" class="headerlink" title="2.6 别名类型"></a>2.6 别名类型</h3><h4 id="2-6-1-byte和rune"><a href="#2-6-1-byte和rune" class="headerlink" title="2.6.1 byte和rune"></a>2.6.1 byte和rune</h4><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">字节类型，uint8类型的别名</td></tr><tr><td style="text-align:center">rune</td><td style="text-align:center">字符类型，int32类型的别名</td></tr></tbody></table><p>因为<code>Go</code>语言的<code>rune</code>和其他语言的<code>char</code>还是有较大差异，所以我们在这里针对<code>rune</code>类型，多做一些介绍</p><p>我们先看一下<code>Go</code>语言源码中，对于<code>rune</code>类型的注释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rune is an alias for int32 and is equivalent to int32 in all ways. It is</span></span><br><span class="line"><span class="comment">// used, by convention, to distinguish character values from integer values.</span></span><br><span class="line"><span class="comment">// 符文是int32的别名，在所有方面都等同于int32。按照惯例，用于区分字符值和整数值。</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br></pre></td></tr></table></figure><p>因此，<code>rune</code>其实并不是一个独立的类型，它只是<code>int32</code>类型的另一个称呼罢了。所以，<code>rune</code>类型可以和<code>int32</code>类型直接做计算，而不需要任何转换。</p><p>如果我们直接将<code>rune</code>类型的值打印出来，那么它就是一个数字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="string">'a'</span></span><br><span class="line">fmt.Println(c)       <span class="comment">// 97</span></span><br><span class="line">fmt.Printf(<span class="string">"%c\n"</span>, c) <span class="comment">// a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>rune</code>类型的类型转换，下面给出两个示例：</p><p><strong>例1:</strong></p><p>将<code>rune</code>类型转换为字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="string">'a'</span></span><br><span class="line">  <span class="comment">// 方法1</span></span><br><span class="line">fmt.Println(<span class="keyword">string</span>(c))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法2</span></span><br><span class="line">str := fmt.Sprintf(<span class="string">"%c"</span>, c)</span><br><span class="line">fmt.Println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例2：</strong></p><p>将<code>rune</code>类型所代表的数字，转换为字符串：</p><p>这个问题其实可以等价为，将整型转换为字符串。在其他语言当中，如<code>Python</code>，我们是直接使用<code>str()</code>函数进行转换的，但是因为<code>Go</code>语言的<code>rune</code>类型的存在，如果直接使用<code>string()</code>函数，就会得到该<strong>数字对应的字符</strong>，而不是数字本身的字符串格式。这显然不是我们想要的。</p><p>正确的做法应为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">97</span></span><br><span class="line">  <span class="comment">// 方法1</span></span><br><span class="line">fmt.Println(strconv.Itoa(i)) <span class="comment">// 97</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 方法2 可以同时进行进制转换</span></span><br><span class="line">  fmt.Println(strconv.FormatInt(<span class="keyword">int64</span>(i), <span class="number">10</span>)) <span class="comment">// 97</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-2-类型定义与类型别名"><a href="#2-6-2-类型定义与类型别名" class="headerlink" title="2.6.2 类型定义与类型别名"></a>2.6.2 类型定义与类型别名</h4><p>这两个概念我们需要重点区分：<code>类型定义</code>和<code>类型别名</code></p><p>什么是<code>类型定义</code>？举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i myInt = <span class="number">100</span></span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子当中，<code>myInt</code>这个类型就是我们新定义的。那为什么说是新定义的呢？因为，它和<code>int</code>类型其实并不是一个类型。他只是与<code>int</code>类型有共同的实现、共同的能力罢了。</p><p>我们知道<code>Go</code>是一个强类型语言，且不存在类型隐式转换。只要不是同一个类型，就不能直接运算，如下面的代码是不能编译成功的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i myInt = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> j = <span class="number">100</span>        <span class="comment">// 默认为int类型</span></span><br><span class="line">fmt.Println(i + j) <span class="comment">// invalid operation: i + j (mismatched types myInt and int)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果我们直接与字面量运算，还是没有问题的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i myInt = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> j = i + <span class="number">100</span></span><br><span class="line">fmt.Println(j) <span class="comment">// 200 并且此时的j也是myInt类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过使用<code>类型定义</code>这个特性来拓展原有类型的能力：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们给新的整数类型myInt赋予了自动翻倍的能力</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t myInt)</span> <span class="title">double</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(t * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">100</span></span><br><span class="line">newNum := myInt(i).double()</span><br><span class="line">fmt.Println(newNum) <span class="comment">// 200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>类型别名</code>像我们上述提到<code>type</code>和<code>rune</code>时介绍的一样，并不是一个新的类型，只是叫法不同。这个特性是在Go1.9版本时引入的。</p><p>不同于<code>类型定义</code>，我们无法对别名类型的能力进行拓展，因为本来就是同一种类型</p><h2 id="三、条件与循环语句"><a href="#三、条件与循环语句" class="headerlink" title="三、条件与循环语句"></a>三、条件与循环语句</h2><h3 id="3-1-if条件语句"><a href="#3-1-if条件语句" class="headerlink" title="3.1 if条件语句"></a>3.1 if条件语句</h3><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">10</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"大于10"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> a &gt; <span class="number">5</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"a大于5"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"a小于5"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><code>Go</code>语言的<code>if</code>语句，其条件不需要放在括号中</p><h3 id="3-2-switch语句"><a href="#3-2-switch语句" class="headerlink" title="3.2 switch语句"></a>3.2 switch语句</h3><h4 id="3-2-1-基础switch"><a href="#3-2-1-基础switch" class="headerlink" title="3.2.1 基础switch"></a>3.2.1 基础switch</h4><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">5</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>:</span><br><span class="line">fmt.Println(<span class="string">"10以内的偶数"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>:</span><br><span class="line">fmt.Println(<span class="string">"10以内的奇数"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"不是10以内的自然数"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10以内的奇数</span><br></pre></td></tr></table></figure><p>这里应该能看出<code>Go</code>和其他主流编程语言的诸多不同，我们这里一一列举：</p><ol><li><code>Go</code>语言的switch语句可以用来匹配任何类型，包括结构体</li><li>每个<code>case</code>都可以匹配多个值</li><li>每个<code>case</code>都默认自带<code>break</code>，如果需要实现<code>switch穿透</code>，则在需要穿透的<code>case</code>结尾加上<code>fallthrough</code></li></ol><p>除此之外，<code>switch</code>还可以作为<code>if-else if</code>结构的简写版本：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> a &gt; <span class="number">10</span>:</span><br><span class="line">fmt.Println(<span class="string">"大于10"</span>)</span><br><span class="line"><span class="keyword">case</span> a &gt; <span class="number">5</span>:</span><br><span class="line">fmt.Println(<span class="string">"a大于5"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"a小于5"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-type-switch"><a href="#3-2-2-type-switch" class="headerlink" title="3.2.2 type switch"></a>3.2.2 type switch</h4><p>type switch主要用于对变量类型进行判断的场景，使用方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125; = <span class="string">"123"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> a.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">fmt.Println(<span class="string">"int"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">fmt.Println(<span class="string">"string"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"other"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要说明的是，<code>type switch</code>只能对<code>interface{}</code>类型使用，<code>interface{}</code>类型是一个<code>接口</code>，<code>Go</code>当中所有类型都实现了该接口，所以<code>type switch</code>其实就是判断一个<code>interface{}</code>的实现到底是什么类型</p><p>提到了<code>type switch</code>，就不能不提<code>type assertion</code>。<code>type assertion</code>是一个类型断言，他能帮助我们先校验类型，后执行操作。</p><p>如下面这个<code>s</code>就可以顺利作为参数传递给<code>println()</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">interface</span>&#123;&#125; = <span class="string">"123"</span></span><br><span class="line">fmt.Println(s.(<span class="keyword">string</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-循环语句"><a href="#3-3-循环语句" class="headerlink" title="3.3 循环语句"></a>3.3 循环语句</h3><p><code>Go</code>只有<code>for</code>循，但是存在多种不同的使用方式。比如其他语言当中的<code>while</code>循环，在<code>Go</code>语言中也是通过<code>for</code>来实现</p><h4 id="3-3-1-经典for循环"><a href="#3-3-1-经典for循环" class="headerlink" title="3.3.1 经典for循环"></a>3.3.1 经典for循环</h4><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中注意点和<code>if</code>是一样的，即不需要使用括号来包围条件</p><h4 id="3-3-2-for循环变体"><a href="#3-3-2-for循环变体" class="headerlink" title="3.3.2 for循环变体"></a>3.3.2 for循环变体</h4><p><code>Go</code>中既然没有<code>while</code>循环，那么怎么实现<code>while</code>循环的效果呢？其实只要把<code>for</code>当作<code>while</code>就可以了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="number">10</span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for</code>还可以轻松实现无限循环，相比其他语言的<code>while(true)</code>更加简洁：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"forever"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-3-for…range"><a href="#3-3-3-for…range" class="headerlink" title="3.3.3 for…range"></a>3.3.3 for…range</h4><p>当我们需要遍历一个集合或者字符串的时候，使用经典<code>for</code>循环显然是太啰嗦了，我们可以使用<code>for...range</code>语句来简化语法，但是要注意，在某些场景下，<code>for...range</code>不仅仅是帮助我们简化了语法，还多做了一些人性化的事情，后面会详细讲到的。</p><p>经典<code>for</code>循环遍历数组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Go语言从入门到实战（二）&quot;&gt;&lt;a href=&quot;#Go语言从入门到实战（二）&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到实战（二）&quot;&gt;&lt;/a&gt;Go语言从入门到实战（二）&lt;/h1&gt;&lt;h2 id=&quot;一、变量与常量&quot;&gt;&lt;a href=&quot;#一、
      
    
    </summary>
    
      <category term="程序人生" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="Golang" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Golang/"/>
    
    
      <category term="Golang" scheme="http://yoursite.com/tags/Golang/"/>
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Go语言从入门到实战（一）</title>
    <link href="http://yoursite.com/2019/09/24/Go%E8%AF%AD%E8%A8%80%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2019/09/24/Go语言从入门到实战（一）/</id>
    <published>2019-09-24T13:50:37.000Z</published>
    <updated>2019-09-24T19:34:56.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go语言从入门到实战（一）"><a href="#Go语言从入门到实战（一）" class="headerlink" title="Go语言从入门到实战（一）"></a>Go语言从入门到实战（一）</h1><h2 id="一、为什么要学习Go语言"><a href="#一、为什么要学习Go语言" class="headerlink" title="一、为什么要学习Go语言"></a>一、为什么要学习Go语言</h2><p>在开始我们的学习旅程之前，我们先来了解一下Go语言，通过建立一个宏观的印象，来熟悉一下Go这门语言，消除陌生的感觉。</p><p>首先要强调的是，Go是一门<strong>通用语言</strong>，这也就意味着，不管是<code>Java</code>、<code>C#</code>、<code>Python</code>还是<code>PHP</code>，这些语言可以做到的事情，理论上<code>Go</code>都可以做；Go可以做到的事情，理论上这些语言也都可以做到。</p><p>因此，我们在选择一门技术的时候，都是选择去看他<strong>最擅长</strong>的方面。</p><p>但是先别急，我们不妨先去探究一下，<code>Go</code>为什么会被发明？或者说，<code>Go</code>是为了解决什么样的问题而诞生的呢？当我们搞清楚这个问题，<code>Go</code>语言擅长做什么这个问题，也就不言自明了。</p><p>2007年前后，软件开发迎来了新挑战，主要包括：</p><ul><li>摩尔定律逐渐失效，多核硬件架构的广泛应用</li><li>超大规模分布式计算集群</li><li>Web模式导致的前所未有的开发规模和更新速度</li></ul><p>而为了解决这些问题，Google的三位大牛合作创造了Go语言：Rob Pike、Ken Thompson、Robert Griesemer。</p><ul><li><p>Rob Pike：Unix早期开发者、UTF-8创始人、Plan9操作系统创始人</p></li><li><p>Ken Thompson：Unix创始人、B语言创始人、UTF-8创始人、参与设计正则表达式、1983年图灵奖获得者</p></li><li><p>Robert Griesemer：Google V8 JS Engine开发者、Java Hot Spot开发者</p></li></ul><p>所以我们学习Go语言，其最主要的应用场景就是上面所提到的：多核架构下，超大规模集群的项目的开发。</p><p>而天生目标明确的Go语言，毫无疑问的具备鲜明的特点，让我们来一一了解。</p><h2 id="二、Go语言的特点"><a href="#二、Go语言的特点" class="headerlink" title="二、Go语言的特点"></a>二、Go语言的特点</h2><h3 id="2-1-简约"><a href="#2-1-简约" class="headerlink" title="2.1 简约"></a>2.1 简约</h3><p>Go语言所倡导的思想是“Less is more”，他的创造者们希望能用尽量简单的方法，去完成我们的工作，但是Go语言的简约不等于其简单，他的威力丝毫没有因为其简约的设计而弱于其他的编程语言。</p><p>Go语言设计的简约性可以体现在以下几个方面：</p><p>首先，就是关键字的数量：</p><table><thead><tr><th style="text-align:center">C</th><th style="text-align:center">Go</th><th style="text-align:center">C++ 11</th></tr></thead><tbody><tr><td style="text-align:center">37</td><td style="text-align:center">25</td><td style="text-align:center">84</td></tr></tbody></table><p>我们都知道<code>C</code>是一门简单而强大的系统级语言，而<code>Go</code>甚至做到了关键字的数量比他还要少；而<code>C++</code>是与<code>Go</code>语言的理念截然相反的，<code>C++</code>几乎吸收了所有他能吸收的特性，导致了他虽然功能强大，但是过于复杂。</p><h3 id="2-2-性能"><a href="#2-2-性能" class="headerlink" title="2.2 性能"></a>2.2 性能</h3><p>Go语言的特点不仅仅在于简约的设计，更少不了的是他强大的执行速度。</p><p>大家都知道<code>Python</code>也是一门上手迅速的编程语言，深受很多程序员的喜爱，然而他的问题就在于作为一门<code>解释性语言</code>性能较弱，因此，<code>Python</code>常用于一些对性能要求不高的地方，如充当“胶水语言”。</p><p>而<code>Go</code>作为一门编译型语言，其拥有超越<code>Java</code>的执行速度；又因为他的简约的设计，他还拥有接近<code>Python</code>的开发速度。同时具备这两个特性，使得Go语言充满了吸引力。</p><h3 id="2-3-组合的编程思想"><a href="#2-3-组合的编程思想" class="headerlink" title="2.3 组合的编程思想"></a>2.3 组合的编程思想</h3><p><code>组合</code>是一种比起传统<code>面向对象</code>编程语言当中的<code>继承</code>更加灵活的编程思想。</p><p><code>组合</code>是<code>has-a</code>的关系，而<code>继承</code>是<code>is-a</code>的关系。这种设计的优越性在于可以进一步的降低<code>耦合</code>，实现更小的<code>封装</code>从而保证功能的专注和单一。我们会在后面的学习中更加深入地感受到这种设计的优越性。</p><p>当然，没有最好的设计，只有更适合的设计。<code>组合</code>并不能全盘否定<code>继承</code>的价值。不过对于<code>Go</code>语言来说，<code>组合</code>更加接近其设计思想。</p><p>因此，我们在学习和使用<code>Go</code>的过程中，需要训练自己使用<code>组合</code>的方式来思考问题，而不是把<code>Go</code>的代码，写成了<code>Go</code>语法版本的<code>Java</code></p><h2 id="三、Go语言的Killer-Application"><a href="#三、Go语言的Killer-Application" class="headerlink" title="三、Go语言的Killer Application"></a>三、Go语言的Killer Application</h2><p>对于一门技术来说，最为重要的除了其即将能创造的价值以外，还有就是已经创造的价值。对一门编程语言来说，如果它曾经实现过<strong>杀手级应用</strong>，那么毫无疑问，对于该语言的推动与发展都是大有裨益的。</p><p>因为，这一方面杀手级应用证明了该语言开发复杂系统的能力，而不仅仅是一个大牛开发的玩具；另一方面，杀手级应用可以将部分应用自身的用户转化为开发该应用的技术的使用者。</p><blockquote><p><strong>杀手级应用</strong>（<strong>Killer application</strong>）是指一个极具价值的计算机程序或服务，消费者愿意为这个程序或服务购买特定硬件、软件产品或服务。——中文维基</p></blockquote><p><code>Go</code>语言就拥有数个杀手级应用：</p><p>用于云计算的两个关键应用是Go语言开发：</p><ul><li>Docker</li><li>Kubernetes</li></ul><p>用于区块链的杀手级应用和Go兼容最好：</p><ul><li>Ethereum</li><li>Hyperledger</li></ul><p>以及不得不提的：Go语言自身的编译器也是使用Go语言实现。这样的方式被称为：<strong>自举</strong></p><h2 id="四、Go语言的安装和准备工作"><a href="#四、Go语言的安装和准备工作" class="headerlink" title="四、Go语言的安装和准备工作"></a>四、Go语言的安装和准备工作</h2><h3 id="4-1-下载Go安装程序"><a href="#4-1-下载Go安装程序" class="headerlink" title="4.1 下载Go安装程序"></a>4.1 下载Go安装程序</h3><p>因为Google退出中国大陆的原因，我们正常无法直接从官方网站下载<code>Go</code>安装程序，推荐前往地址：<a href="https://studygolang.com/dl" target="_blank" rel="noopener">Go语言中文网</a>下载。</p><p>如果是Mac OS的用户，可以使用<code>home brew</code>安装。</p><h3 id="4-2-官网与文档"><a href="#4-2-官网与文档" class="headerlink" title="4.2 官网与文档"></a>4.2 官网与文档</h3><p>Golang的官网是<a href="https://golang.org" target="_blank" rel="noopener">https://golang.org</a>，不过因为上面提到的原因，国内不能正常访问，那么替代方案有这么几种：</p><ul><li><p>方案一：<a href="https://golang.google.cn/" target="_blank" rel="noopener">Google CN提供的镜像网站</a>：该网站最大的好处就是原版英文，可以获得等同于原官网的体验</p></li><li><p>方案二：<a href="https://go-zh.org/" target="_blank" rel="noopener">中文版官网</a>：该网站已经部分汉化了，可以帮助阅读英文有困难的同学们</p></li><li><p>方案三：使用Golang起一个本地服务：安装Golang后，在命令行里输入<code>godoc -http=:8080</code>，并在浏览器访问<code>http://localhost:8080/</code>即可访问本地官网（英文），8080是端口号，可以更改，这种方式优点在于不依赖网络</p></li><li><p>方案四：<a href="https://tip.golang.org/" target="_blank" rel="noopener">https://tip.golang.org/</a>是golang.org的完全限定域名，由Google提供，目前中国大陆可以正常访问</p></li></ul><p><strong>提醒：</strong>针对上面的【方案三】，需要补充说明一点：新版的<code>Go</code>安装程序已经不在包含<code>godoc</code>，必须自行安装<code>godoc</code>（中国大陆需要代理）。</p><h3 id="4-3-Go环境配置"><a href="#4-3-Go环境配置" class="headerlink" title="4.3 Go环境配置"></a>4.3 Go环境配置</h3><p>在此之前，我们先学习两个命令：</p><ol><li>查看当前Go语言版本：<code>go version</code></li><li>查看当前Go语言环境设置：<code>go env</code></li></ol><p>好，那我们开始吧：</p><p>配置环境变量<code>GOPATH</code>是至关重要的一个环节。所谓<code>GOPATH</code>，就是我们存放代码、编译程序的工作目录。</p><p>可以自己随意选择一个目录作为“GoPath”，然后将其配置到环境变量当中（具体配置方法可以参考【4.4设置代理】）</p><p>GoPath路径下的目录结构应该是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GOPATH</span><br><span class="line">|-src（必要，请自行创建）</span><br><span class="line">|-pkg</span><br><span class="line">|-bin</span><br></pre></td></tr></table></figure><p>其中，我们的代码就存放在<code>src</code>目录下，包括我们从网络上拉取的第三方包，也会存放在这里。</p><p><strong>建议：</strong>将<code>你的GoPath路径/bin</code>【追加】到环境变量<code>PATH</code>里（请自行解决），以确保可以调用<code>Go</code>语言开发的工具</p><p><strong>提示：</strong>从版本1.11开始，我们并不一定要将自己的代码写在GoPath目录下，具体请参见后面介绍“Go Mod”的文章</p><h3 id="4-4-设置代理"><a href="#4-4-设置代理" class="headerlink" title="4.4 设置代理"></a>4.4 设置代理</h3><p><code>Go</code>为我们提供了非常好用的工具<code>go get</code>，可以直接从网络拉取依赖包（例如：github），但是由于下载速度并不理想，且部分存放在Google服务器上的包文件无法正常获取（中国大陆），我们还是通过配置代理来解决吧。</p><p><strong>推荐方法：</strong></p><p>如果你的<code>Go</code>版本大于等于1.13，可以直接使用以下命令配置代理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go env -w GOPROXY=https://goproxy.cn,direct</span></span><br></pre></td></tr></table></figure><p><strong>通用方法：</strong></p><p>如果上述推荐方法不适用，或者没有效果，那么我们可以手工配置：</p><ul><li>Windows：添加系统环境变量，<code>GOPROXY</code>，值为<code>https://goproxy.cn</code>；如果你的版本大于等于1.13，值则为<code>https://goproxy.cn,direct</code></li><li>Mac：在目录<code>~/.bash_profile</code>文件下添加：<code>export GOPROXY=https://goproxy.cn</code>，保存并退出；如果你的版本大于等于1.13，则为<code>export GOPROXY=https://goproxy.cn,direct</code></li><li>Mac（补充）：如果你的shell不是<code>bash</code>而是<code>zsh</code>，那么则是在该文件下操作：<code>~/.zshrc</code>。或者，依然在<code>~/.bash_profile</code>文件下操作，但是必须将<code>source ~/.bash_profile</code>配置添加入<code>~/.zshrc</code></li><li>Mac（提醒）：你可以执行<code>source ~/.bash_profile</code>或<code>~/.zshrc</code>使环境变量配置立刻生效</li></ul><p>至此，你的<code>go get</code>命令可以正常工作了。</p><h3 id="4-5-开发工具"><a href="#4-5-开发工具" class="headerlink" title="4.5 开发工具"></a>4.5 开发工具</h3><p><code>Go</code>语言可以使用的开发工具还是比较丰富的，这里稍微列举几种：</p><ol><li>GoLand：Jetbrains家的专业IDE，和大名鼎鼎的Java IDE工具“intellij idea”同门。缺点：收费</li><li>liteide：由中国人自己开发的Go语言IDE工具，免费。<a href="https://github.com/visualfc/liteide/blob/master/liteidex/deploy/welcome/zh_CN/install.md" target="_blank" rel="noopener">下载说明</a>在此，建议下载二进制文件，而不是手动编译</li><li>Eclipse + Goclipse：经典IDE Eclipse通过安装插件支持Go语言开发，免费</li><li>VsCode、Atom、Sublime等 + 插件：代码编辑器（Editor）相比IDE更加轻量，同样免费</li><li>Vim、Emacs + 插件</li></ol><h2 id="五、Go快速上手"><a href="#五、Go快速上手" class="headerlink" title="五、Go快速上手"></a>五、Go快速上手</h2><p>在第一篇文章的最后，我们一起来快速上手一下<code>Go</code>代码的编写吧。</p><h3 id="5-1-Hello-World"><a href="#5-1-Hello-World" class="headerlink" title="5.1 Hello World"></a>5.1 Hello World</h3><ol><li><p>在你的GoPath目录下的src目录内，创建项目目录（名称自取）。</p></li><li><p>在项目目录下，创建文件hello.go（名称自取）</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明包</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入包</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 向控制台输出文本内容</span></span><br><span class="line">fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码：</p><p>在<code>.go</code>文件所在目录下，执行命令：<code>go run hello.go</code></p><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World</span><br></pre></td></tr></table></figure><h3 id="5-2-解释说明"><a href="#5-2-解释说明" class="headerlink" title="5.2 解释说明"></a>5.2 解释说明</h3><p><strong>第1行：</strong></p><p><code>Go</code>语言的单行注释，不参与程序执行</p><p>多行注释则为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fmt.Println("Hello World")</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>第2行：</strong></p><p><code>Go</code>和其他很多语言一样，使用<code>包</code>来管理和组织代码，其中规则如下：</p><ol><li>同一个目录下，所有<code>.go</code>文件的包名必须一致</li><li><code>main</code>包下，必须有且只能有一个<code>main</code>函数</li><li>目录的名称不一定非要和包名一致</li><li><code>main</code>方法所在的文件的文件名不要求是<code>main.go</code></li></ol><p><strong>第5、6、7行：</strong></p><p>导入依赖包，其中规则如下：</p><ol><li>当需要导入的包仅有一个时，可以简写成一行：<code>import &quot;fmt&quot;</code></li><li>包可以设置别名，如<code>import f &quot;fmt&quot;</code></li><li>导入的包，一般必须使用，否则编译不通过</li><li>如果不使用导入的包，且想要通过编译，需要将下划线<code>_</code>作为包别名：<code>import _ &quot;fmt&quot;</code></li></ol><p><strong>第10行：</strong></p><p><code>main函数</code>是整个程序的入口，具体规则如下：</p><ol><li>该示例中，<code>main函数</code>声明为唯一写法。即：没有参数列表、没有返回值</li><li><code>main</code>包下必须有一个<code>main函数</code>，并且只能有一个<code>main函数</code></li><li><code>Go</code>语言中，所有函数声明均是使用<code>func</code>关键字</li><li><code>Go</code>语言中，函数体使用<strong>花括号</strong>包围，且<strong>左花括号不能另起一行</strong></li></ol><p><strong>第12行：</strong></p><p>函数的调用，具体规则如下：</p><ol><li>函数&amp;表达式结尾均<strong>不需要添加分号</strong></li><li>一般情况下，调用包函数必须写上<code>包名.</code>。如果需要省略这个部分，可以使用点<code>.</code>作为包别名：<code>import . &quot;fmt&quot;</code></li><li><code>Go</code>语言中，函数名&amp;变量名的首字母大小写均代表<strong>包外可见性</strong>。大写代表可见，反之不可见</li></ol><h3 id="5-3-程序退出码"><a href="#5-3-程序退出码" class="headerlink" title="5.3 程序退出码"></a>5.3 程序退出码</h3><p>我们可以用程序<strong>退出码</strong>来表示程序的执行结果，如：返回0代表执行成功，其他则代表出现异常</p><p>由于<code>Go</code>语言<code>main函数</code>不支持返回值，所以我们需要给<code>os</code>包下的<code>Exit()</code>函数传值实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">  <span class="comment">// 设置程序退出码</span></span><br><span class="line">os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>这里的退出码范围为0～255，如果传递-1，则会当作255</p><h3 id="5-4-传递命令行参数"><a href="#5-4-传递命令行参数" class="headerlink" title="5.4 传递命令行参数"></a>5.4 传递命令行参数</h3><p>实用的命令行工具都需要传递参数给我们的程序，由于<code>Go</code>的<code>main函数</code>没有参数列表，所以需要使用<code>os</code>包下的<code>Args()</code>函数去接收命令行参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取并打印命令行参数</span></span><br><span class="line">fmt.Println(os.Args[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处<code>Args()</code>函数返回的是一个<code>字符串切片</code>，关于<code>字符串切片</code>我们后面会学习到。这里我们只需要明白，<code>[0]</code>代表取出列表中的第一个元素，而<code>[1]</code>就是取出第二个元素</p><p><code>Args()</code>函数返回的第一个元素（即下标0）永远是程序本身，而第二个元素（下标1）就是我们传入的第一个参数，以此类推…</p><p>执行上面的代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go run Hello.go haha</span></span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">haha</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Go语言从入门到实战（一）&quot;&gt;&lt;a href=&quot;#Go语言从入门到实战（一）&quot; class=&quot;headerlink&quot; title=&quot;Go语言从入门到实战（一）&quot;&gt;&lt;/a&gt;Go语言从入门到实战（一）&lt;/h1&gt;&lt;h2 id=&quot;一、为什么要学习Go语言&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="程序人生" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="Golang" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Golang/"/>
    
    
      <category term="Golang" scheme="http://yoursite.com/tags/Golang/"/>
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
