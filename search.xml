<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java多线程学习笔记]]></title>
    <url>%2F2020%2F07%2F27%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Java多线程学习笔记CAS compare and swap，比较并且交换，同compare and exchange CAS可以在没有加锁的情况下，保值多线程的一致性。 如何解决ABA问题： 加版本号 使用一个bool类型作标记 没有影响的话，可以不考虑此问题 CAS如何实现的 hotspot源码，cpp内，调用了汇编指令cmpxchg，如果是多核CPU，还需要lock 1lock cmpxchg 指令 所以，cmpxchg本身是非原子性的 硬件： lock指令在执行后面的时候锁定一个北桥信号，不采用锁总线的方式 对象在内存中的布局 new Object()在内存占多少字节 使用Open JDK的工具JOL（Java Object Layout），Maven导入 12Object o = new Object();System.out.println(ClassLayout.parseInstance(o).toPrintable()); 输出： 对象在内存中的布局： 普通对象说明： markword + 指针类型，加起来是对象头 关于锁（synchronized）的信息都存在markword中 指针类型指向所属的类 实例数据存的是成员变量 对齐是保证对象内存大小可以被8整除，使得总线读取更快 查看Java命令行参数： 123456$ java -XX:+PrintCommandLineFlags -version-XX:G1ConcRefinementThreads=4 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=134217728 -XX:MaxHeapSize=2147483648 -XX:MinHeapSize=6815736 -XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GCjava version "14" 2020-03-17Java(TM) SE Runtime Environment (build 14+36-1461)Java HotSpot(TM) 64-Bit Server VM (build 14+36-1461, mixed mode) 对new Object()内存布局的解释： 前两行：合计是markword，共8字节 第三行，指针，指向类，4字节（补充：64位系统指针应该是8字节，但是被ClassPoniter压缩至4字节） 第四行：补齐，由于不能被8整除，补齐4字节，即loss due to the next… 由于没有成员变量，实例数据部分0字节 面试题： 1Object o = new Object();在内存中占有多少字节？ -- 顺丰 答：管理synchronized等信息的markword 8字节；如果开启了ClassPointer的压缩，类型指针占4字节；成员变量没有，所以0字节；合计12字节，由于不能被8整除，补齐至16字节。如果没有开启ClassPointer的压缩，类型指针占8个，那么就正好16字节，不需要补齐。 分析这段代码的内存布局，和之前的new Object()作个对比： 123synchronized(o) &#123; System.out.println(ClassLayout.parseInstance(o).toPrintable());&#125; 输出： 注意第一行value的区别，说明锁信息是保存在对象的markword内的。 锁升级： new - 偏向锁 - 轻量级锁（无锁 == 自旋锁、自适应自旋）- 重量级锁 由上图可知，锁状态、GC标记、分代年龄都是存在对象的markword的8字节内的 分代年龄： 每次GC，如果对象没有被回收，则分代年龄+1，达到一定值（PS+PO GC默认15; CMS GC默认6），则对象从年轻代到老年代 注意： 由于分代年龄是4bit表示的，最大值是1111（二进制），即1 + 2 + 4 + 8 = 15，所以将值调到大于15是没有用的 自旋锁进一步升级的条件： 有线程自旋超过10次 在自旋的线程超过总核数的1/2 自适应自旋锁可以自动调整以上的两个值 用户态和内核态 用户态：ring3 应用程序大多跑着用户态 内核态：ring0 申请锁需要在内核态进行 在内核态申请到锁之后，线程会进入一个阻塞的队列，wait的线程不消耗资源，区别于自旋锁依赖频繁的CAS会消耗大量CPU资源 锁降级： 锁降级只存在在GC的时候，其他线程已经不持有锁，只发生在VMThread访问的时候，所以没意义，一般认为不存在降级 锁消除 举例说明： 1234public void add(String str1, String str2) &#123; StringBuffer sb = new StringBuffer(); sb.append(str1).append(str2);&#125; 解释： 虽然StringBuffer是线程安全的，即append()方法是被synchronized修饰的，但是在本add方法内，锁会被消除。原因是，sb是局部变量而不是成员变量（栈私有），不可能存在竞争，所以sb对象的锁会被JVM消除。 锁粗化 举例说明： 123456789public String test(String str) &#123; int i = 0; StringBuffer sb = new StringBuffer(); while(i &lt; 100) &#123; sb.append(str); i++; &#125; return sb.toString();&#125; 解释： JVM检测到一连串对同一对象的加锁和解锁，JVM会粗化加锁范围，使得锁只需要加1次。]]></content>
      <categories>
        <category>程序人生</category>
        <category>Java</category>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>锁机制</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅聊企业文化——读《浪潮之巅》有感]]></title>
    <url>%2F2020%2F05%2F25%2F%E6%B5%85%E8%81%8A%E4%BC%81%E4%B8%9A%E6%96%87%E5%8C%96%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85%E3%80%8B%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[背景在《浪潮之巅》第四版的下册中（原《硅谷之谜》），开篇第一章即是《挑战者——Google公司》。讨论Google总会给年轻人一种充满热血的感觉，因为这家企业确实是非常硅谷，非常叛逆。 它和其他的IT领域的大企业不同，不同于传统的IBM靠硬件设备赚钱；也不同于Microsoft和Oracle靠卖软件；Google几乎全部收入都来自于广告，也正是这样，Google才能始终贯彻自身的工程师文化，Google愿意将大把资金投入到回报遥遥无期的Google X Lab，去研发Google Glass和Waymo智能驾驶等未来项目。 X，前称为“Google X”，是一个谷歌公司运行的秘密实验室，位于加利福尼亚州旧金山湾区某处。 ——维基百科 据说在硅谷，Uber被称为一家996公司，而Google则是一家对员工无比关怀的”养老公司”。因为这些天才工程师们的目标是“改变世界”，而996并不能提升效率。所以Google的员工的工作氛围非常的轻松，如丰厚的零食和之前的20%time。 另一个说明Google重视自己员工的例子是“All-hands meeting”（每周全体员工和领导层一起交流的大会），虽然据说在2019年也已经被取消了，不过这就是后话了。 之前网络上甚至有些人使用“谷人希”（谷歌，人类的希望）来形容这家公司，虽然充满了些许夸张，但是确实可以看出在广大网民眼中，Google公司是创新金字塔顶端的存在，尤其是在Microsoft多年的封闭和百度的负面不断的背景下，Google的魔幻魅力吸引了大批崇拜者。 Google与工程师文化 Google的很多特点，追根溯源都可以归结为工程师文化。 吴军博士在《浪潮之巅》中分析称，不同的企业文化决定了他们的竞争优势和劣势。确实，Google的工程师文化为之吸纳了大量的人才，甚至是天才，尤其是在其早期阶段的时候。 拥有大量天才工程师的Google，几乎成为了开源界的灯塔，诸如V8、K8s这些改变行业和领域的软件都和Google的贡献密不可分。这也使Google获得了巨大的先发优势，没有人会想去取代V8，K8s也几乎是行业规范，还有其他一大批开源软件源自于Google的论文，如Hadoop。 但是一个公司的平均智商，总是会随着其体量不断增大而下降的，直到一个稳定线上。曾经的Google还没有如此庞大，以至于他们员工能够拥有20%的独立时间（如Go编程语言就是诞生于20%时间的业余项目）。随着平均智商的下降，Google的绝大部份员工的20%时间已经很难再创造出什么太有价值的东西。所以20%时间制度被取消可以认为是一种必然。当然，这肯定也和近几年Google单纯靠广告收入已经不再好过有关。 连Google自己的员工创办的公司都不使用Google的云计算服务。 相比于将顾客摆在第一位的Amazon，Google在企业服务方面显然是出了问题。Amazon虽然对待自己的员工抠门，但是AWS良好的服务却让他们的产品占据云计算市场的大半壁江山。 技术优势和天才工程师确实能够帮助Google称为科技行业的先锋，但是在云计算服务这个行业，Google的技术优势看起来比起Amazon并没有高出多少。在这样一个没有技术先发优势的情况下，显然重视客户服务的企业更容易获得市场。 通过Google的成与败，我们可以看到工程师文化确实如吴军博士说的，成为了Google的萧何，如今的Google，在云计算领域的对手有Microsoft和Amazon；在操作系统领域对手有Apple和Microsoft；在量子计算领域对手有IBM…无论何种方向，Google都难以找到10年前的技术统治地位，这或许也是为什么All-hands meeting会被取消吧，因为Google可能要重新在工程师的浪漫和客户服务之间，寻找新的平衡点了。 由工程师文化而思考编程语言之争 编程语言只有两种，被人骂的和没人用的。 确实在社区里面看到的对JavaScript的批评太多了，由于历史原因，js的早期版本存在大量的设计问题，直到如今也没有被全部解决。当然，这也为TypeScript的崛起提供了契机。 但是无论js被如何骂，谁也改变不了的事实就是，js已经成为了事实上的全栈“全能”语言。从web前端到服务端，从移动端到游戏，js已经处处可见了。 从工程师文化来说的话，有无数语言的设计比js更“优雅”，但是他们只能要么成为小众领域的选择，要么干脆成为玩具…… 即是对比Python和Ruby这两个非常相似的语言也可以得出一样的结论，无论Ruby是不是一款能让程序员”快乐”的语言，他都不能改变他市场占有率不断走低，而Py如日中天的事实。 产品经理 or 顾客至上 如果當初我去問顧客到底想要什麼，他們會回答說要一匹跑得更快的馬。——福特汽车创始人：亨利‧福特 吴军博士大致将企业文化分为如下几种，且一个公司很难同时拥有多种企业文化，因为无法兼顾： 工程师文化，代表是：Google、Microsoft、华为 产品经理文化，代表是：Apple、FaceBook、腾讯 销售文化，代表是：亚马逊、阿里巴巴 而按照三方利益分类，则是这样： 员工利益，代表是：星巴克、Google、腾讯 消费者利益，代表是：亚马逊、阿里巴巴 投资人利益，代表如巴菲特投资的一系列企业 个人则倾向于，在产品的设计方面，保持自己的核心审美，而不是一味讨好客户，因为客户口味总是不一样的，没有清晰的产品定位，一味听从客户意见，注定搞出四不像。 正如Go语言创始人之一，Rob Pike所说，Go语言的最大成就就是始终保证了对最初方向对坚持。仅从这个意义上说的话，他达成了他的使命——纠正C++，因为现代C++已经复杂到诸多行业精英都嫌弃了。。。 所以，顾客至上，应该是服务上的至上，而在提供什么样的产品上，产品经理应该保持独立的思考，而不是一味地询问你的顾客。]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java有意思的现象——执行注释后的代码]]></title>
    <url>%2F2020%2F05%2F08%2FJava%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%8E%B0%E8%B1%A1%E2%80%94%E2%80%94%E6%89%A7%E8%A1%8C%E6%B3%A8%E9%87%8A%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[今天看到这样一个有意思的图片，给大家分享下： 问题来了，为什么代码里面已经被注释的部分也可以执行呢？ 其实也很简单，查一下\u000d是个啥玩意就行了，果不其然，这个代表回车（CR：Return）；而另一个类似的\u000a则是换行（LF：Line Feed）。其实也就是\r和\n啦。 而Java在解析代码的时候，是会按照Unicode编码去解析，而不是把它当作字符串。因此，注释自然是无效啦～ 额外试了下其他语言，这个用法在Go、Python、Nim等语言中并不可以哦！]]></content>
      <categories>
        <category>程序人生</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>Java</tag>
        <tag>趣事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HHKB使用心得]]></title>
    <url>%2F2020%2F05%2F07%2FHHKB%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[这篇文章主要是在使用HHKB键盘的过程中的一些心得和技巧，属于不定期追加内容的形式 大小写切换很多Mac用户应该知道，如果我们使Mac的原生键盘的话，可以很方便地使用Caps Lock键来切换中英文。 但是由于HHKB键盘帮我们非常友好地把这个键给优化没了，所以我们只有两个选择了： 使用软件改键 使用默认的替换按键 其实HHKB并没有删除这个键的功能，可以通过fn + tab键的方式来起到相同的效果]]></content>
      <categories>
        <category>程序人生</category>
        <category>外设</category>
      </categories>
      <tags>
        <tag>HHKB</tag>
        <tag>键盘</tag>
        <tag>外设</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go实现最简单的超时控制]]></title>
    <url>%2F2020%2F05%2F07%2FGo%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122package mainimport ( "fmt" "time")func main() &#123; ch := make(chan int) go func(ch chan int) &#123; time.Sleep(time.Second * 10) ch &lt;- 1 &#125;(ch) select &#123; case &lt;-ch: fmt.Println("ok") case &lt;-time.After(time.Second * 5): fmt.Println("time out") &#125;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>示例代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go实现最简单的在线视频播放]]></title>
    <url>%2F2020%2F04%2F28%2FGo%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%9C%A8%E7%BA%BF%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%2F</url>
    <content type="text"><![CDATA[如下： 123456789101112131415161718192021222324252627package mainimport ( "log" "net/http" "os" "time")func video(response http.ResponseWriter, request *http.Request) &#123; response.Header().Set("Content-Type", "video/mp4") file, err := os.Open("/Users/sherlockgy/Downloads/1.mp4") if err != nil &#123; log.Println("文件打开异常...") return &#125; http.ServeContent(response, request, "test", time.Now(), file) defer file.Close()&#125;func main() &#123; http.HandleFunc("/video", video) // 设置访问的路由 err := http.ListenAndServe(":9090", nil) // 设置监听的端口 if err != nil &#123; log.Fatal("ListenAndServe: ", err) &#125;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F04%2F22%2F%E4%BD%BF%E7%94%A8ZK%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E5%8D%95%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2F</url>
    <content type="text"><![CDATA[使用ZK实现最简单分布式锁分布式锁也是ZK的常见应用场景。我们可以利用其临时节点来实现分布式锁。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F04%2F18%2F%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[云原生学习笔记 [TOC] 一、技术发展历史 2004～2007：Google大规模使用容器（cgroups）技术 2008.01：cgroups技术合并进Linux主干，为容器化打下基础 2013.03：Docker项目正式发布 2014.06：Kubernetes项目发布 2015.07：CNCF（云原生基金会）成立，22个创始成员，Kubernetes成为第一个CNCF项目 2017.07：CNCF成立2周年，170个会员，14个基金会项目 2018.07：CNCF成立3周年，195个会员，19个基金会项目，11个孵化项目 二、云原生的定义容器技术的革命性类似于集装箱的革命性。 容器技术可以使应用以自包含的方式定义，从而更敏捷、可拓展、可复制。 云原生是一条最佳路径（最佳实践）。这条路径能： 低心智负担的、 敏捷的、 以可拓展、可复制的方式 最大化地利用云的能力，发挥最大价值。 容器技术就是云原生技术的核心底盘。 三、云原生思想的两个理论基础1. 不可变基础设施目前实现：容器镜像 解释：我们的跑应用的基础设施应该是==不可变==的，是自包含、自描述且可以随时迁移的。 基础设施向云演进的过程传统应用的基础设施： 可变，如SSH连接到服务器，手动升级或降级软件包，逐个服务器调整配置文件，新代码直接部署到现有服务器上 对云友好的应用基础设施： 不可变，如部署完成之后基础设施不会被修改。如需更新，则更改公共镜像构建新服务以替换旧服务。验证后，新服务投入使用，旧服务退役。 2. 云应用编排理论目前实现：容器设计模式（Google提出） 四、容器与镜像容器与普通的操作系统进程，有什么区别呢？ 由于进程是共享同一份文件系统，导致权限较高的进程会影响到权限较低的进程的文件操作，形成相互干扰； 由于进程和进程间的依赖可能存在冲突，会给运维带来压力； 由于进程间使用同样的宿主机的资源，存在资源抢占，权限低的进程可能会因为抢占不到资源而无法提供服务。 什么是容器？容器，是一个视图隔离、资源可限制、独立文件系统的进程集合。 视图隔离 - 如能看见其他进程；独立主机名等等 控制资源使用率 - 如2G内存大小；CPU使用个数等等 什么是镜像？运行容器所需要的所有文件的集合，就是容器镜像 Dockerfile - 描述镜像构建步骤 构建步骤所产生出文件系统的变化 - changeset 类似disk snapshot 提高分发效率，减少磁盘压力 容器的生命周期单进程模型 init进程的生命周期 = 容器的生命周期 运行期间可以执行exec执行运维操作，exec进程也归init进程管理，当init进程退出，其管理的其他进程皆退出 数据持久化 独立于容器的生命周期 数据卷 - docker volume vs bind]]></content>
  </entry>
  <entry>
    <title><![CDATA[Golang与UTF-8]]></title>
    <url>%2F2020%2F04%2F17%2FGolang%E4%B8%8EUTF-8%2F</url>
    <content type="text"><![CDATA[Golang与UTF-8我们在浏览器抓包的时候，有时候会发现类似这样的一串字符串： \350\241\250\346\203\205 当然我们都知道这多半是UTF-8表示的汉字。那么在Go语言当中，我们要怎么转换他们呢？ 这里直接贴一下代码，以作记录。 注意：这里的数字其实是8进制表示的！ 12345678910111213141516171819202122package mainimport "fmt"func main() &#123; // 将这样的8进制表示的UTF-8字符串恢复成可读状态 str := "\350\241\250\346\203\205" fmt.Printf("%s\n", str) // out：表情 // 使用range遍历“表情”，会发现一个汉字就对应一个编码 str2 := "表情" for _, c := range str2 &#123; fmt.Printf("%o ", c) // 104150 60305 &#125; fmt.Println() // 使用fori遍历“表情”，每个汉字对应3个数字，正好和上面的一串字符吻合 for i := 0; i &lt; len(str2); i++ &#123; fmt.Printf("%o ", str2[i]) &#125; fmt.Println() // 350 241 250 346 203 205 &#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>编码</tag>
        <tag>UTF-8</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给macOS的访达（Finder）配置快捷键快速启动]]></title>
    <url>%2F2020%2F04%2F16%2F%E7%BB%99macOS%E7%9A%84%E8%AE%BF%E8%BE%BE%EF%BC%88Finder%EF%BC%89%E9%85%8D%E7%BD%AE%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[给macOS的访达（Finder）配置快捷键快速启动[TOC] 第一步，配置自动操作指令首先，打开macOS自带的这个小机器人工具： 然后点击新建文稿： 文稿类型选择快速操作： 选择实用工具 -&gt; 开启应用程序： 然后将开启应用程序拖拽进右侧。 将流程设置为如下参数，即：没有输入和任何应用程序： 在下面的开启应用程序中，选择新建变量，再点击其他： 然后选择系统 -&gt; 资源库 -&gt; coreServices -&gt; 访达： 至此，本步骤完成。可以把该指令起名为快捷启动访达，保存退出，以便后续配置快捷键。 第二步，给指令添加快捷键打开系统偏好设置中的键盘： 然后按下图配置快捷键即可： 建议：不要配置太简单的快捷键，如：command + E，避免部分应用程序的快捷键会冲突，如：Chrome 参考]]></content>
      <categories>
        <category>技巧分享</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>Mac</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang单元测试]]></title>
    <url>%2F2020%2F04%2F14%2FGolang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Golang单元测试[TOC] 一、约定的条件 包含单元测试的代码文件必须以_test.go结尾，否则测试框架并不会读区该文件作为测试代码。 单元测试文件名_test.go前面的部分建议是被测试的方法所在代码文件的文件名。 单元测试的函数名必须以Test开头，注意首字母是大写的。如果不满足则测试框架不会执行该函数。 函数名最好是Test+要测试的方法函数名，如TestAdd，表示测试的是Add这个这个函数。 测试函数的签名必须接收一个指向testing.T或testing.B类型的指针，且无返回值。 二、简单的样例测试文件：test/demo_test.go 代码为： 123456789101112131415package testimport ( "testing")func Add(a, b int) int &#123; return a + b&#125;func TestAdd(t *testing.T) &#123; if result := Add(1, 2); result != 3 &#123; t.Errorf("测试Add函数报错，参数分别是%v and %v，返回结果为%v，期望是%v", 1, 2, result, 4) &#125;&#125; 三、如果对测试函数的执行顺序有要求 将单个测试用例的首字母小写，这样这个用例就不会被测试框架调用了 我们将测试方法传递给t的Run()方法，从而实现指定顺序执行单元测试 1234567891011121314151617181920212223242526package testimport ( "testing")func Add(a, b int) int &#123; return a + b&#125;func testAdd1(t *testing.T) &#123; if result := Add(1, 2); result != 3 &#123; t.Errorf("测试Add函数报错，参数分别是%v and %v，返回结果为%v，期望是%v", 1, 2, result, 4) &#125;&#125;func testAdd2(t *testing.T) &#123; if result := Add(3, 4); result != 7 &#123; t.Errorf("测试Add函数报错，参数分别是%v and %v，返回结果为%v，期望是%v", 1, 2, result, 4) &#125;&#125;func TestAdd(t *testing.T) &#123; t.Run("test1", testAdd1) t.Run("test2", testAdd2)&#125; 四、测试开始前的统一初始化等操作如果我们需要在单元测试开始前进行统一的初始化操作，如：数据准备、连接数据库等，就需要用到*testing.M。 在现有用例的基础上增加这个函数： 1234func TestMain(m *testing.M) &#123; fmt.Println("统一初始化...") m.Run()&#125; 五、基准测试，测试性能–benchmark benchmark函数必须以Benchmark开头 benchmark的测试case一般会跑b.N次，并且每次执行都是这样 实际执行时，会调整b.N的次数，直到执行时间达到稳态 b.ResetTimer是重置计时器，这样可以避免for循环之前的初始化代码的干扰 被测试的代码要放到循环里 b.N是基准测试框架提供的，表示循环的次数，因为需要反复调用测试的代码，才可以评估性能 12345678910111213141516package testimport ( "fmt" "testing")func Print() &#123; fmt.Println("hello")&#125;func BenchmarkPrint(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; Print() &#125;&#125; 123# 以这样的方式进行执行# .表示运行所有的基准测试go test -bench=.]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决升级macOS catalina后VMware黑屏问题]]></title>
    <url>%2F2020%2F02%2F15%2F%E8%A7%A3%E5%86%B3%E5%8D%87%E7%BA%A7MacOS%20catalina%E5%90%8EVMware%E9%BB%91%E5%B1%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[VMware软件的Mac版本名为VMware Fusion，该软件在你的Mac电脑安装了目前最新的macOS系统：catalina后，会出现黑屏的问题，而当你挂起虚拟机后，又可以看到虚拟机画面。这是由于自从catalina版本开始，应用程序需要自主申请各项权限，而旧版的VMware并不会申请屏幕录制权限，这就导致了黑屏的问题。 要想解决该问题，有三种方法： 将操作系统回退到之前版本，如果你有时间机器的备份，这应该比较容易 升级VMware，但是如果你是破解版，会出现破解失败，需要付费的情况 手动赋予VMware屏幕录制权限 这里重点介绍如何手动赋予VMware屏幕录制权限： 一、关闭MacOS的rootless机制 重启你的Mac，同时在白色苹果logo弹出之前就按住command和r键 选择菜单（menu）上面的实用工具（Utilities），选择终端（Terminal） 输入以下命令关闭rootless机制，然后重启Mac 12# 关闭rootless机制$ csrutil disable 二、手动赋予VMware屏幕录制权限依次在终端键入以下命令： 1234567$ tccutil reset All com.vmware.fusion$ sudo sqlite3 "/Library/Application Support/com.apple.TCC/TCC.db" 'insert into access values ("kTCCServiceScreenCapture", "com.vmware.fusion", 0, 1, 1, "", "", "", "UNUSED", "", 0,1565595574)'$ sudo sqlite3 "/Library/Application Support/com.apple.TCC/TCC.db" 'insert into access values ("kTCCServiceListenEvent", "com.vmware.fusion", 0, 1, 1, "", "", "", "UNUSED", "", 0,1565595574)'$ sudo sqlite3 "/Library/Application Support/com.apple.TCC/TCC.db" 'insert into access values ("kTCCServicePostEvent", "com.vmware.fusion", 0, 1, 1, "", "", "", "UNUSED", "", 0,1565595574)' 此时黑屏问题应该已经解决，可检查设置 -&gt; 安全性和隐私 -&gt; 屏幕录制权限是否赋予给了VMware。如问题依然存在，麻烦查询其他方案解决。 三、重新打开rootless机制 重启你的Mac，同时在白色苹果logo弹出之前就按住command和r键 选择菜单（menu）上面的实用工具（Utilities），选择终端（Terminal） 输入以下命令启动rootless机制，然后重启Mac 12# 重新打开rootless机制$ csrutil enable 四、参考文章文章1文章1]]></content>
      <categories>
        <category>技巧分享</category>
        <category>问题fix</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Fix</tag>
        <tag>虚拟机</tag>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac如何卸载旧版Java]]></title>
    <url>%2F2020%2F02%2F09%2FMac%E5%A6%82%E4%BD%95%E5%8D%B8%E8%BD%BD%E6%97%A7%E7%89%88Java%2F</url>
    <content type="text"><![CDATA[卸载步骤： 删除终端命令： 12sudo rm -fr /Library/Internet\ Plug-Ins/JavaAppletPlugin.pluginsudo rm -fr /Library/PreferencesPanes/JavaControlPanel.prefPane 删除JDK包 先查看已安装了哪些版本的Java 1ls /Library/Java/JavaVirtualMachines/ 再进入目录，删除对应版本的Java 12cd /Library/Java/JavaVirtualMachines/sudo rm -rf jdk[_update].jdk 删除偏好设置面板图标 1sudo rm -fr /Library/PreferencePanes/JavaControlPanel.prefPane]]></content>
      <categories>
        <category>程序人生</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>踩坑</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java踩坑——Double类型转String变成了科学计数法怎么解决]]></title>
    <url>%2F2019%2F11%2F28%2FJava%E8%B8%A9%E5%9D%91%E2%80%94%E2%80%94Double%E8%BD%ACString%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[现在有一个场景,需要将一个Double类型的字段转换成字符串然后写入文件,不过在某些时候,数字会出现以科学计数法的形式来表示: 1234double scale = 0.0005;System.out.println(String.valueOf(scale)); // 5.0E-4System.out.println(scale + ""); // 5.0E-4System.out.println(scale); // 5.0E-4 如上,在尝试了几种容易想到的方法后,发现均不可行.后来经过搜索和更多次尝试,整理出几种方案: 方案一使用java.math包的BigDecimal类.效果如下: 123double scale = 0.0005;BigDecimal bigDecimal = new BigDecimal(scale);System.out.println(bigDecimal); // 0.0005000000000000000104083408558608425664715468883514404296875 由于BigDecimal直接使用不符合我们对小数点后长度的需求,就需要使用String.format()的方式进行转换: 123double scale = 0.0005;BigDecimal bigDecimal = new BigDecimal(scale);System.out.println(String.format("%.4f", bigDecimal)); // 0.0005 至此问题貌似是解决了,但是依然很不放心.主要原因在于这种方式还是有可能导致误差:毕竟本来我的数字就是标准的0.0005,而BigDecimal因为精度原因需要做截取. 虽然目前看似没有问题,但是如果出现BigDecimal将结果输出成:0.0004999999999999之类的怎么办呢? 这个时候又想到了四舍五入之类的方法,但是总感觉与真正的方法相去越来越远:这么简单的一个转换,不应该搞得这么复杂,于是有了方案二 方案二这一次是使用java.text包下的DecimalFormat类,具体实现如下: 123double scale = 0.0005;DecimalFormat decimalFormat = new DecimalFormat("#.####");System.out.println(decimalFormat.format(scale)); // 0.0005 方案三后来想起来,发现其实上面两种方法都是庸人自扰,属于脑子一下没转过弯来才会干的事…因为实际上问题可以非常简单地解决: 123double scale = 0.0005;String scaleStr = String.format("%.4f", scale);System.out.println(scaleStr); // 0.0005 好吧,果然这种问题的解决办法一定是非常简单的…]]></content>
      <categories>
        <category>程序人生</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis系统学习]]></title>
    <url>%2F2019%2F11%2F28%2FRedis%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Redis系统学习一、什么是Redis? Redis是用C语言开发的一个开源、免费、高性能键值对内存数据库 它提供5种数据类型来存储值:字符串类型、散列类型、列表类型、集合类型、有序集合类型 他是一种NoSQL数据库 可用于缓存、内存数据库、消息队列等 1.1 什么是NoSQL? NoSQL,即Not-Only-SQL,泛指非关系型数据库 NoSQL数据库为了解决高并发、高可用、高可拓展、大数据存储问题而产生的数据库解决方案 NoSQL可以作为关系型数据库的良好补充,但不是替代关系型数据库 1.2 NoSQL数据库分类1.2.1 键值存储数据库相关产品: Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB 典型应用: 内容缓存,主要处理大量数据的高访问负载 数据模型: 一系列键值对 优势: 快速查询 劣势: 存储的数据缺少结构化 1.2.2 列存储数据库相关产品: Cassardra、HBase、Riak 典型应用: 分布式的文件系统 数据模型: 以列簇式存储,将同一列数据存在一起 优势: 查找速度快、可拓展性强,更容易进行分布式拓展 劣势: 功能相对局限 1.2.3 文档型数据库说明: 与Key-Value类似,Value是结构化的,即可嵌套 相关产品: Mongo DB、Couch DB 典型应用: Web应用 数据模型: 一系列键值对 优势: 数据结构要求不严格 1.3 Redis的应用场景 内存数据库(登陆信息、购物车信息、用户浏览记录等) 缓存服务器(商品数据、广告数据等) 解决分布式集群架构中的session分离问题(session共享) 任务队列(秒杀、抢购、12306等) 支持发布-订阅的消息模式 应用排行榜 网站访问统计 数据过期处理(精确到毫秒) 二、安装启动2.1 解压二进制安装包1234$ tar -xf redis-3.2.9.tar.gz # 加上-z参数可以显示解压进度$ cd redis-3.2.9$ make # 需要安装GCC$ make install PREFIX=/redis # 指定安装目录安装 2.2 启动2.2.1 前端启动1234# 直接运行bin/redis-server将以前端模式启动$ ./redis-server# ctrl + c关闭 2.2.2 守护进程启动 修改redis-conf配置文件,将文件中的daemonize项改为yes bind 127.0.0.1改为bind &lt;redis实例所在机器的真实IP&gt;，如：bind 192.168.10.133（本地测试忽略） 12345678# 指定配置文件位置启动$ redis-server /usr/local/bin/redis.conf# 检查是否启动成功$ ps -ef | grep redis# 关闭redis$ ./redis-cli shutdown 2.3 其他命令介绍 redis-server: 启动Redis服务 redis-cli: 进入Redis命令客户端 redis-benchmark: 性能测试工具 redis-check-aof: aof文件进行检查的工具 redis-check-dump: rdb文件进行检查的工具 redis-sentinel: 启动哨兵监控服务 2.4 Redis客户端2.4.1 自带的命令客户端12345# 默认进入当前机器的6379端口所在的Redis$ ./redis-cli# 指定机器和端口(host port)$ ./redis-cli -h IP地址 -p 端口 2.4.2 程序客户端-Jedis Redis不仅可以使用命令客户端进行操作,还可以使用程序客户端进行操作 现在的主流语言都有客户端支持,比如:Java、C、C#、C++、PHP、Node.js、Go等 Java的客户端有: Jedis、Redisson、Jredis、JDBC-Redis 2.4.3 多数据库支持默认一共是16个数据库，每个数据库之间是相互隔离（但是可以使用flushall一次清空所有的库）。数据库的数量是在redis.conf中配置的。 切换数据库使用命令：select 数据库编号（0-15） 例如：select 1 三、通用命令3.1 set &amp; get命令12345# redis通过set key value的方式塞值set name tom# redis通过get key的方式取值get name 3.2 keys命令1234567891011# 返回满足给定pattern的所有key# 语法:keys pattern$ keys *1) "age"2) "id"3) "Category"4) "name"5) "ID"$ keys i*1) "id" 3.3 setnx命令1234567891011121314151617# setnx只能在key不存在的场景下可以塞值成功$ get name"Jack"$ setnx name "Bob"(integer) 0 # setnx返回0代表塞值失败$ get name"Jack"$ setnx name2 "Bob"(integer) 1 # setnx返回1代表塞值成功$ get name2"Bob"# 提示:可以用keys命令来检验key是否已存在 该命令可以用于分布式锁,只能赋值成功一次的场景: 把key当作是锁 3.4 append命令12345678$ set sayhi "hello"OK$ append sayhi " world"(integer) 11 # 该数字代表当前value的长度$ get sayhi"hello world" 3.5 strlen命令1234$ strlen sayhi(integer) 11# 键不存在会返回0 3.6 同时设置多个值和获取多个值1234567$ mset k1 v1 k2 v2 k3 v3OK$ mget k1 k2 k31) "v1"2) "v2"3) "v3" 3.7 del命令del命令是根据key来删除的,所以5种数据类型通用 12$ del name(integer) 1 3.8 判断一个key是否存在12345$ exists k1(integer) 1 # 存在$ exists k9(integer) 0 # 不存在 3.9 给一个key重命名1234567$ rename k1 k11OK$ keys k*1) "k3"2) "k11"3) "k2" 3.10 判断一个value的类型12345678$ type k11string$ type list1list$ type tomhash 3.11 设置缓存过期时间(生存时间)Redis在实际使用过程中,更多的用作缓存.然而缓存的数据一般都是需要设置生存时间的. 即:到期后数据销毁 1234# expire key seconds 设置生存时间(秒)# expire key milliseconds (毫秒)# ttl key 查看key剩余生存时间# persist key 清除生存时间(永生) 四、Redis数据类型4.1 String类型12345678910111213# 赋值$ set name tomOK# 取值$ get name"tom"# 取值并赋值(取出老的值并赋予新的值)$ getset name Jack"tom"$ get name"Jack" 4.1.1 String类型递增数字1234567891011121314151617181920212223# 如果我们key的value是可以转换成正整数的字符串# 那么就可以使用incr命令来实现自增# 该操作是原子性的,可用于分布式系统的唯一ID生成$ set ID "10"OK$ incr ID(integer) 11$ get ID"11"# incr还可以指定增幅:使用incrby命令$ incrby ID 10(integer) 21# 递减$ decr ID(integer) 20# 递减并指定幅度$ decrby ID 10(integer) 10 4.2 Hash类型Hash类型使用hset命令,不区分插入和更新操作,当执行插入操作的时候返回1;当执行更新操作的时候返回0 该类型可以理解为他的value是一个map,即: 键 - (属性:值) 属性就可以理解为map的key;值则是map的值 这样的数据结构更能体现Java对象的特征 语法: hset key field value 注意事项: 存储对象属性经常发生增删改操作的数据 12345678910111213141516$ hset "tom" age 20(integer) 1$ hset "tom" addr beijing(integer) 1$ hget tom age"20"$ hget tom addr"beijing"# 当然hmset和hmget可以实现多个操作,例如:$ hmget tom age addr1) "20"2) "beijing" 4.2.1 Hash类型递增数字同样,hash类型也是可以递增数字的,例如: 123# 不存在hincr命令,只有hincrby$ hincrby tom age 2(integer) 22 4.2.2 判断属性是否存在12345$ hexists tom age(integer) 1 # 存在$ hexists tom name(integer) 0 # 不存在 4.2.3 获取所有的field或所有的值1234567$ hkeys tom1) "age"2) "addr"$ hvals tom1) "22"2) "beijing" 4.2.4 获取所有的field和所有的值12345$ hgetall tom1) "age"2) "22"3) "addr"4) "beijing" 4.2.5 获取字段数12$ hlen tom(integer) 2 4.3 List类型内部实现是双向链表,所以向两端添加元素的时间复杂度为O(1),获取越接近两端的元素速度就越快. 这意味着,即使是一个有几千万个元素的列表,获取头部和尾部的10条记录也是极快的. 4.3.1 向列表增加和查看列表1234567891011121314151617# 向列表左边增加元素$ lpush list1 1 2 3 4 5(integer) 5# 因为依次向左边添加元素,因此目前的列表应该是# 5,4,3,2,1# 遍历该列表# 索引可以是负数,-1代表最后一个元素$ lrange list1 0 41) "5"2) "4"3) "3"4) "2"5) "1"# 从右边增加元素则是使用rpush,示例省略 4.3.2 从列表两端弹出元素12345678910$ lpop list1"5"$ lrange list1 0 -11) "4"2) "3"3) "2"4) "1"# 从右边删除元素则是使用rpop,示例省略 利用列表,从一端添加,从另一端pop就可以实现消息队列的效果 4.3.3 获取列表长度12$ llen list1(integer) 4 4.3.4 删除列表中指定的值(且指定删除的个数)语法: lrem 列表 个数 值 123456789101112131415161718# 删除前$ lrange list1 0 -11) "2"2) "4"3) "3"4) "2"5) "1"# 从list1当中删除1个2$ lrem list1 1 2(integer) 1# 删除后$ lrange list1 0 -11) "4"2) "3"3) "2"4) "1" 4.3.5 获取指定索引的元素值123456789$ lrange list1 0 -11) "4"2) "3"3) "2"4) "1"# 获取索引为1的元素值$ lindex list1 1"3" 4.3.6 将列表中元素插入另一个列表12345678910111213141516$ lrange list1 0 -11) "4"2) "3"3) "2"4) "1"$ rpoplpush list1 newlist"1"$ lrange newlist 0 -11) "1"$ lrange list1 0 -11) "4"2) "3"3) "2" 4.4 Set类型不可重复(去重) 4.4.1 新增&amp;删除12345678910111213141516$ sadd s1 1 2 3 4 5(integer) 5 # 该数字表示此次插入成功的元素个数# 补充:因为set类型具备去重的特性,如果sadd的值已存在,则会出现add数字为0的情况# 查看key下的所有值$ smembers s11) "1"2) "2"3) "3"4) "4"5) "5"# 删除元素$ srem s1 4(integer) 1 4.4.2 判断集合中是否存在该元素1234$ sismember s1 6(integer) 1 # 表示存在$ sismember s1 7(integer) 0 # 表示不存在 4.4.3 集合运算123456789101112131415161718192021222324252627282930313233343536373839404142434445# 已知:$ smembers s11) "1"2) "2"3) "3"4) "4"5) "5"6) "6"$ smembers s21) "2"2) "4"3) "6"4) "8"# 交集运算$ sinter s1 s21) "2"2) "4"3) "6"$ sinter s2 s11) "2"2) "4"3) "6"# 差集运算# 即:从[前者]里面减去[前者]和[后者]同时存在的值$ sdiff s1 s21) "1"2) "3"3) "5"$ sdiff s2 s11) "8"# 并集运算$ sunion s1 s21) "1"2) "2"3) "3"4) "4"5) "5"6) "6"7) "8" 4.4.4 获取集合中元素的个数12$ scard s1(integer) 6 4.4.5 从集合中弹出一个元素必须要注意的是,此处的弹出(删除)是随机的.因此可以使用它来实现抽奖系统等 1234567891011121314151617181920212223242526272829303132333435363738# 传递的数字代表要弹出几个元素,而不是弹出什么元素# 例1$ spop s1 61) "1"2) "2"3) "3"4) "4"5) "5"6) "6"$ smembers s1(empty list or set)# 例2$ sadd s1 1 2 3 4 5 6(integer) 6$ scard s1(integer) 6$ spop s1"6"$ spop s1"3"$ spop s1"1"$ scard s1(integer) 3$ spop s1 21) "5"2) "2"$ scard s1(integer) 1 4.5 SortedSet类型(别名:ZSet)有序集合实现排序的方式:通过给每一个元素指定一个分数,然后基于分数进行排名 12345678910111213141516# 语法:zadd 集合名 分数 元素$ zadd z1 80 Jerry 100 Tom 75 Jack(integer) 3# 排名# 默认:从小到大$ zrange z1 0 -11) "Jack"2) "Jerry"3) "Tom"# 降序$ zrevrange z1 0 -11) "Tom"2) "Jerry"3) "Jack" 4.5.1 获取元素的分数12$ zscore z1 Jack"75" 4.5.2 删除元素123456$ zrem z1 Jack(integer) 1$ zrange z1 0 -11) "Jerry"2) "Tom" 五、Redis事务5.1 Redis事务介绍 Redis事务是通过MULTI、EXEC、DISCARD和WATCH这四个命令实现的 Redis的单个命令都是原子性的,所以这里确保事务性的对象是命令集合 Redis将命令集合序列化并确保处于同一事务的命令集合连续且不被打断的执行 不支持事务回滚 5.2 命令介绍5.2.1 MULTI命令用于标记一个事务块的开始 Redis会将后续的命令逐个放入队列中,然后才能使用EXEC命令原子化地执行这个序列 5.2.2 EXEC命令在一个事务中执行所以先前放入命令队列中的命令,然后恢复正常的连接状态 5.2.3 DISCARD命令清除所有在先前一个事务中放入命令队列中的命令,然后恢复正常的连接状态 5.2.4 WATCH命令当某个事务需要按条件执行时,就要使用这个命令.将给定的键设置为受监控的 使用这个命令可以实现Redis的乐观锁 使用unwatch清除所有先前为一个事务监控的键 5.2.5 示例演示事务开启并取消: 1234567891011121314$ MULTI # 开启事务命令集合OK$ set s111 v111 # 往命令队列中添加命令1QUEUED$ set s222 v222 # 往命令队列中添加命令2QUEUED$ DISCARD # 取消命令队列中的命令OK$ exec(error) ERR EXEC without MULTI 演示事务开启并执行: 123456789101112$ MULTI # 开启事务命令集合OK$ set s111 v111 # 往命令队列中添加命令1QUEUED$ set s222 v222 # 往命令队列中添加命令2QUEUED$ exec # 开始依次执行命令集合中的命令1) OK2) OK 演示WATCH乐观锁: 12345678910111213141516171819202122232425# 检视初始值$ get s1"111"$ get s2"222"# 开始监控s1的状态:如果s1的值发生变化,则事务不执行$ watch s1OK# 开启事务$ MULTIOK$ set s2 999QUEUED# 由于s1的值在其他地方被改变,事务执行失败$ exec(nil)# s2的值没有被修改$ get s2"222" 5.3 Redis事务失败 Redis语法错误 Redis类型错误 5.3.1 为什么Redis不支持事务回滚? 大多数事务失败是因为语法错误或类型错误,这两种错误都可以在开发阶段预见 Redis为了性能方面忽略了事务回滚 六、Redis实现分布式锁6.1 锁的处理 单应用中使用锁：单进程多线程 Synchronize、Lock 分布式应用中使用锁：多进程 6.2 分布式锁的实现方式 数据库的乐观锁 基于Zookeeper的分布式锁 基于Redis的分布式锁 6.3 分布式锁的注意事项 互斥性：在任意时刻，只有一个客户端能持有锁 同一性：加锁和解锁必须是同一个客户端，客户端不能把别人加的锁 避免死锁：即使有一个客户端持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端加锁 6.4 实现分布式锁6.4.1 获取锁在SET命令中，有很多选项可用来修改命令的行为，以下是SET命令可用的基本语法。 1$ SET key value [EX seconds] [PX milliseconds] [NX|XX] EX seconds：设置指定的到期时间（以秒为单位）。 PX milliseconds：设置指定的到期时间（以毫秒为单位）。 NX：仅在键不存在的时候设置键。 XX：仅在键已存在的时候才设置。 123456789101112131415/** * 方式1 使用redis的set命令实现获取分布式锁 * @param lockKey 可以就是锁 * @param requestId 请求ID，保证同一性 * @param expireTime 过期时间，避免死锁 * @return */public static boolean getLock(String lockKey, String requestId, int expireTime) &#123; // NX:保证互斥性 String result = jedis.set(lockKey, requestId, "NX", "EX", expireTime); if("OK".equals(result)) &#123; return true; &#125; return false;&#125; 1234567891011/** * 方式2（使用setnx命令实现） */public static boolean getLock(String lockKey, String requestId, int expireTime) &#123; Long result = jedis.setnx(lockKey, requestId); if(result == 1) &#123; jedis.expire(lockKey, expireTime); return true; &#125; return false;&#125; 6.4.2 释放锁12345678/** * 方式1 del命令实现 释放分布式锁 */public static void releaseLock(String lockKey,String requestId) &#123; if (requestId.equals(jedis.get(lockKey))) &#123; jedis.del(lockKey); &#125;&#125; 123456789101112/** * 方式2（redis+lua脚本实现）--推荐 */public static boolean releaseLock(String lockKey, String requestId) &#123; String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"; Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId)); if (result.equals(1L)) &#123; return true; &#125; return false;&#125; 七、持久化方案Redis是一个内存数据库，为了保证数据的持久性，它提供了两种持久化方案： RDB方式（默认） AOF方式 7.1 RDB方式7.1.1 介绍 RDB是Redis默认采用的持久化方式 RDB方式是通过快照（snapshotting）完成的，当符合一定条件时Redis会自动将内存中的数据进行快照并持久化到硬盘。默认保存在dump.rdb文件中。（本机位置：/usr/local/bin/dump.rdb） Redis会在指定的情况下触发快照 符合自定义配置的快照规则 执行save或者bgsave命令 执行flushall命令 执行主从复制操作 7.1.2 配置dbfilename指定rdb快照文件的名称12# The filename where to dump the DBdbfilename dump.rdb 注意事项 redis在进行快照的过程中不会修改RDB文件，只有快照结束后才会将旧的文件替换成新的，也就是说任何时候RDB文件都是完整的。 这就使得我们可以通过定时备份RDB文件来实现redis数据库的备份， RDB文件是经过压缩的二进制文件，占用的空间会小于内存中的数据，更加利于传输。 7.1.3 自定义快照规则在redis.conf中设置自定义快照规则： 12345678格式：save &lt;seconds&gt; &lt;changes&gt; 示例：save 900 1 ： 表示15分钟（900秒钟）内至少1个键被更改则进行快照。save 300 10 ： 表示5分钟（300秒）内至少10个键被更改则进行快照。save 60 10000 ： 表示1分钟内至少10000个键被更改则进行快照。可以配置多个条件（每行配置一个条件），每个条件之间是“或”的关系。 特别说明： 1. Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。 2. 根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将记录一千万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20～30秒钟。 7.1.4 RDB的优缺点优点： RDB可以最大化Redis的性能：父进程在保存RDB文件时唯一要做的就是fork出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无序执行任何磁盘I/O操作。同时这个也是一个缺点，如果数据集比较大的时候，fork可以能比较耗时，造成服务器在一段时间内停止处理客户端的请求 缺点： 使用RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。这个时候我们就需要根据具体的应用场景，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受范围。如果数据相对来说比较重要，希望将损失降到最小，则可以使用AOF方式进行持久化 7.2 AOF方式7.2.1 介绍 默认情况下Redis没有开启AOF（append only file）方式的持久化 开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件，这一过程显然会降低Redis的性能，但大部分情况下这个影响是能够接受的，另外使用较快的硬盘可以提高AOF的性能。 可以通过修改redis.conf配置文件中的appendonly参数开启 1appendonly yes AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的。 默认的文件名是appendonly.aof，可以通过appendfilename参数修改： 1appendfilename appendonly.aof 7.2.2 参数说明 auto-aof-rewrite-percentage 100 表示当前aof文件大小超过上一次aof文件大小的百分之多少的时候会进行重写。如果之前没有重写过，以启动时aof文件大小为准 auto-aof-rewrite-min-size 64mb 限制允许重写最小aof文件大小，也就是文件大小小于64mb的时候，不需要进行优化 7.2.3 同步磁盘数据Redis每次更改数据的时候， aof机制都会将命令记录到aof文件，但是实际上由于操作系统的缓存机制，数据并没有实时写入到硬盘，而是进入硬盘缓存。再通过硬盘缓存机制去刷新到保存到文件。 参数说明： appendfsync always 每次执行写入都会进行同步 ， 这个是最安全但是是效率比较低的方式 appendfsync everysec 每一秒执行（默认） appendfsync no 不主动进行同步操作，由操作系统去执行，这个是最快但是最不安全的方式 7.2.4 AOF文件损坏以后如何修复服务器可能在程序正在对 AOF 文件进行写入时停机， 如果停机造成了 AOF 文件出错（corrupt）， 那么 Redis 在重启时会拒绝载入这个 AOF 文件， 从而确保数据的一致性不会被破坏。 当发生这种情况时， 可以用以下方法来修复出错的 AOF 文件： 为现有的 AOF 文件创建一个备份。 使用 Redis 附带的 redis-check-aof 程序，对原来的 AOF 文件进行修复。 redis-check-aof –fix readonly.aof 重启 Redis 服务器，等待服务器载入修复后的 AOF 文件，并进行数据恢复。 7.3 如何选择RDB和AOF 一般来说,如果对数据的安全性要求非常高的话，应该同时使用两种持久化功能。 如果可以承受数分钟以内的数据丢失，那么可以只使用 RDB 持久化。 有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快 。 两种持久化策略可以同时使用，也可以使用其中一种。如果同时使用的话， 那么Redis重启时，会优先使用AOF文件来还原数据 八、Redis主从复制持久化保证了即使redis服务重启也不会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，但是当redis服务器的硬盘损坏了可能会导致数据丢失，不过通过redis的主从复制机制就可以避免这种单点故障。 说明： 主redis中的数据有两个副本（replication）即从redis1和从redis2，即使一台redis服务器宕机其它两台redis服务也可以继续提供服务。 主redis中的数据和从redis上的数据保持实时同步，当主redis写入数据时通过主从复制机制会复制到两个从redis服务上。 只有一个主redis，可以有多个从redis。 主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求 一个redis可以即是主又是从 8.1 主从配置8.1.1 主redis配置无需特殊配置。 8.1.2 从redis配置修改从服务器上的redis.conf文件： 1slaveof &lt;masterip&gt; &lt;masterport&gt; 8.2 实现原理 Redis的主从同步，分为全量同步和增量同步。 只有从机第一次连接上主机是全量同步 断线重连有可能触发全量同步也有可能是增量同步（master判断runid是否一致） 除此之外的情况都是增量同步 8.2.1 全量同步Redis的全量同步过程主要分三个阶段： 同步快照阶段：Master创建并发送快照给Slave,Slave载入并解析快照。Master同时将此阶段所产生的新的写命令存储到缓冲区。 同步写缓冲阶段：Master向Slave同步存储在缓冲区的写操作命令。 同步增量阶段：Master向Slave同步写操作命令。 8.2.2 增量同步 Redis增量同步主要指Slave完成初始化后开始正常工作时，Master发生的写操作同步到Slave的过程。 通常情况下，Master每执行一个写命令就会向Slave发送相同的写命令，然后Slave接收并执行。 九、Redis Sentinel哨兵机制Redis主从复制的缺点：没有办法对master进行动态选举，需要使用Sentinel机制完成动态选举。 说明： Sentinel(哨兵)进程是用于监控redis集群中Master主服务器工作的状态 在Master主服务器发生故障的时候，可以实现Master和Slave服务器的切换，保证系统的高可用（HA） 其已经被集成在redis2.6+的版本中，Redis的哨兵模式到了2.8版本之后就稳定了下来。 9.1 哨兵进程的作用 监控(Monitoring): 哨兵(sentinel) 会不断地检查你的Master和Slave是否运作正常。 提醒(Notification)： 当被监控的某个Redis节点出现问题时, 哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。 自动故障迁移(Automatic failover)：当一个Master不能正常工作时，哨兵(sentinel) 会开始一次自动故障迁移操作。 它会将失效Master的其中一个Slave升级为新的Master, 并让失效Master的其他Slave改为复制新的Master； 当客户端试图连接失效的Master时，集群也会向客户端返回新Master的地址，使得集群可以使用现在的Master替换失效Master。 Master和Slave服务器切换后，Master的redis.conf、Slave的redis.conf和sentinel.conf的配置文件的内容都会发生相应的改变，即，Master主服务器的redis.conf配置文件中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换。 9.2 哨兵进程的工作方式 每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。 如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）。 如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认Master主服务器的确进入了主观下线状态。 当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为客观下线（ODOWN）。 在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。 当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。 若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。 9.3 案例演示修改从机的sentinel.conf 12#sentinel monitor &lt;master-name&gt; &lt;master ip&gt; &lt;master port&gt; &lt;quorum&gt;sentinel monitor mymaster 192.168.10.133 6379 1 其他配置项说明： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# Example sentinel.conf # 哨兵sentinel实例运行的端口 默认26379port 26379 # 哨兵sentinel的工作目录dir /tmp # 哨兵sentinel监控的redis主节点的 ip port # master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。# quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了# sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt; sentinel monitor mymaster 127.0.0.1 6379 2 # 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码# sentinel auth-pass &lt;master-name&gt; &lt;password&gt;sentinel auth-pass mymaster MySUPER--secret-0123passw0rd # 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒# sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;sentinel down-after-milliseconds mymaster 30000 # 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。# sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;sentinel parallel-syncs mymaster 1 # 故障转移的超时时间 failover-timeout 可以用在以下这些方面： #1. 同一个sentinel对同一个master两次failover之间的间隔时间。#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。#3.当想要取消一个正在进行的failover所需要的时间。 #4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了# 默认三分钟# sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;sentinel failover-timeout mymaster 180000 # SCRIPTS EXECUTION #配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。#对于脚本的运行结果有以下规则：#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。 #通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。#通知脚本# sentinel notification-script &lt;master-name&gt; &lt;script-path&gt; sentinel notification-script mymaster /var/redis/notify.sh # 客户端重新配置主节点参数脚本# 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。# 以下参数将会在调用脚本时传给脚本:# &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;# 目前&lt;state&gt;总是“failover”,# &lt;role&gt;是“leader”或者“observer”中的一个。 # 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的# 这个脚本应该是通用的，能被多次调用，不是针对性的。# sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt; sentinel client-reconfig-script mymaster /var/redis/reconfig.sh 通过redis-sentinel启动哨兵服务： 1./redis-sentinel sentinel.conf 十、Redis Cluster集群redis3.0以后推出的redis cluster 集群方案，redis cluster集群保证了高可用、高性能、高可扩展性。 架构细节: (1)所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽. (2)节点的fail是通过集群中超过半数的节点检测失效时才生效. (3)客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可 (4)redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护 Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点 最小节点数：3台 (1)节点失效判断：集群中所有master参与投票,如果半数以上master节点与其中一个master节点通信超过(cluster-node-timeout),认为该master节点挂掉. (2)集群失效判断:什么时候整个集群不可用(cluster_state:fail)? Ø 如果集群任意master挂掉,且当前master没有slave，则集群进入fail状态。也可以理解成集群的[0-16383]slot映射不完全时进入fail状态。 如果集群超过半数以上master挂掉，无论是否有slave，集群进入fail状态。]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用上手]]></title>
    <url>%2F2019%2F11%2F24%2FGit%E4%BD%BF%E7%94%A8%E4%B8%8A%E6%89%8B%2F</url>
    <content type="text"><![CDATA[Git使用上手一、起步1.1 安装Windows、Linux请自行前往官网,按照说明完成 这里说一下Mac版本,分两种情况: 使用Apple提供的git发行版:这种情况使用的是Xcode内的Command Line Tools 使用homebrew安装,强烈建议.因为Xcode内的git工具不太完整,缺少gitk、HTML格式的文档等 1.2 最小化配置配置user.name和user.email 12git config --global user.name 'your_name'git config --global user.email 'your_email@domain.com' 1.2.1 config的三个作用域123git config --local # 只针对某仓库git config --global # 对当前用户的所有仓库有效git config --system # 对该系统所有登陆的用户有效 显示config的配置,加--list 123git config --list --localgit config --list --globalgit config --list --system 1.3 使用本地HTML文档12# 例如查看git log命令的使用文档git help log --web 二、建一个Git仓库2.1 初始化此时存在两种场景: 项目代码已经存在,要把项目加入Git版本控制 新建一个项目并使用Git来管理 针对第一种情况,我们使用如下命令: 12cd 项目代码所在的文件夹git init 针对第二种情况,则是使用如下命令: 123cd 某个文件夹git init your_project # git会在当前目录下创建和项目名称同名的文件夹cd your_project 2.2 将文件加入Git版本控制1git add 文件名 # 如果不将文件纳入版本控制,后续操作则会报错 然后查看一下当前的状态: 1git status # 可查看当前git项目的状态,如哪些文件被修改,而哪些文件未被版本管理 此时的文件,是存在于临时的缓存(暂存区)当中,要真正提交还需要执行以下命令: 1git commit -m "变更说明" 这样我们就真正的将一个文件提交进版本了,我们还可以看一下当前的日志: 12345678git log# git log还有几种使用方法,例如git log 分支名 # 查看指定分支的历史;默认显示当前分支git log --all # 显示所有分支的版本历史;默认显示当前分支git log --oneline # 简洁显示变更历史,每次变更只显示一行git log -n2 # 显示最近的两次变更git log --all --graph # 在上面的基础上,添加图形化的版本演进 2.2.1 新建和切换分支12345678git checkout -b 分支名# 这个命令其实相当于创建分支和切换分支两条命令(因为-b参数)git branch 分支名 # 创建分支git checkout 分支名 # 切换分支# 查看当前工作分支git branch -av 2.3 回退修改1git reset --hard # 彻底回退,暂存区和所有未提交的变更记录都会被清理 2.4 文件重命名1git mv 文件原名 文件现名 2.5 比较版本的差异我们可以先查看一下历史: 1234567$ git log --onelineaf289f0 (HEAD -&gt; master) add OnlyMaster.rs1f39a38 add Hello.c1d294ca (test) hello.py renamed to Hello.py5f06285 add hello.py7499e49 add ReadMe 12345678910$ git diff 7499e49 5f06285diff --git a/hello.py b/hello.pynew file mode 100644index 0000000..ce47b77--- /dev/null+++ b/hello.py@@ -0,0 +1 @@+print("hello")\ No newline at end of file 如果是使用当前版本进行比较,我们可以使用HEAD来指代: 1234$ git diff 5f06285 HEAD# 和当前版本的上一个版本比较$ git diff HEAD~1 HEAD # 其中数字可以替换,也可以使用~~来代表~2 2.6 删除分支1234$ git branch -d &lt;BranchName&gt;# 有时候-d会删除不了,如果确认没有风险,可以使用-D$ git branch -D &lt;BranchName&gt; 三、工作区与暂存区的认识在Git当中,如果仅对文件作了add,但没有执行commit的话,文件会被存储进暂存区,而我们对文件进行创作修改的区域被称为工作区 当我们将文件提交进暂存区后,依然可以在工作区继续修改我们的文件,而此时暂存区内的文件是独立于工作区的 这也就意味着,我们随时可以用暂存区内的版本覆盖工作区(如对工作区的修改不满意),而又不需要提交到版本控制,这在实践当中非常实用 补充: 1git add -u # 将项目中所有工作区的文件一起提交到暂存区,而不需要一个个写文件名 四、图形化工具的介绍直接在命令行输入gitk即可. 在MacOS上,如果使用的是Xcode提供的git是没有gitk工具的,需要使用brew安装一下 同时如果使用的是MacOS的暗主题,gitk的菜单栏上的文字会因为和底色相同的原因看不见,需要将鼠标移上去 五、了解.git目录5.1 HEAD文件首先,我们进入.git目录,尝试查看一下HEAD文件的内容: 12$ cat HEADref: refs/heads/master 我们会发现HEAD文件其实是一个引用,而且指向的位置和当前工作的分支有关,如当前工作分支为master 而假设我们当前切换分支到了test,那么此时HEAD文件就会指向test分支 5.2 config文件该文件下除了保存了该仓库下的核心配置之外,如果设置了仓库级别的用户配置,也会写入该文件 例如: 1git config --local user.username "test" # 修改当前仓库的用户名 该文件内的内容则会变为: 123456789[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true[user] username = test 5.3 refs目录在refs目录中,存在两个子目录: heads:里面有各个分支的子文件 tags:里面有各个标签(可看作是里程碑)的子文件 先看heads目录,我们先查看一下master文件的内容: 12$ cat master1d294ca4f3dd9a0d2adef1528f18afd8ef3ca3d3 我们还可以查看该文件是什么类型的: 12$ git cat-file -t master # -t参数可以查看类型commit 同样的,在tag目录下的文件里面存放的也是hash值,文件类型属于tag 通过以下命令可以查看该tag是存放的哪一个commit对象: 1git cat-file -p tag名或tag的hash # -p参数可以查看内容 5.4 objects目录我们进入objects目录后,会看到很多两个字符组成的文件夹,以及pack(打包目录) 例如: 123456789$ ls -la...061d3d3einfopack 我们随便挑选一个两个字符的目录进去,会发现内部文件是这样的: 12345$ cd 06$ ls -la...0fede4878a49e95fc444e9a243fa77edc710f4 此时我们可以使用命令查看一下该对象的类型: 123# 注意:此处的hash为[两位长度的目录名 + 目录内文件名]$ git cat-file -t 060fede4878a49e95fc444e9a243fa77edc710f4tree tree即目录类型 然后,我们可以查看该对象的内容,使用以下命令(参数: -p): 123$ git cat-file -p 060fede4878a49e95fc444e9a243fa77edc710f4100644 blob 827ae020300b109c1e0e7ee58891e592d85df66c README.md100644 blob ce47b771f4fdb0c612745ca4b7c36695f3853f7c hello.py blob即是文件对象类型 我们可以进一步查看该blob类型: 123456$ git cat-file -t 827ae020300b109c1e0e7ee58891e592d85df66c # 查看类型blob$ git cat-file -p 827ae020300b109c1e0e7ee58891e592d85df66c # 查看内容版本1:1+1=2 至此,我们已经接触了git的如下几种类型: commit tag tree blob 提示: 在git中,只要两个文件内容相同,那么对于git就是唯一的一个blob 5.4.1 commit、tree、blob三者的关系我们可以通过git log命令查询到每一次的commit的hash,如果我们查询某次commit的内容: 123456$ git cat-file -p 7499e499b62642764e31475f # hash不需要输入完整,只要能让git唯一找到目标就可以tree 3d5799c550fa4b815545f0255ad83d16debce7f0author SherlockGy &lt;sherlockgy@live.com&gt; 1574435790 +0800committer SherlockGy &lt;sherlockgy@live.com&gt; 1574435790 +0800add ReadMe 我们会发现,commit对象中永远存储了一个tree,该tree代表截止该的commit为止,此git项目的所有内容,我们可以继续查看该tree的内容: 12$ git cat-file -p 3d5799c550fa4b815545f02100644 blob 827ae020300b109c1e0e7ee58891e592d85df66c README.md 也就是说,此commit提交后,我们的git项目中仅有一个文件,因此显示为一个blob对象;如果此时还有子目录的话,会显示为一个tree对象 这就是三种对象的关系 六、使用分离头指针现在假设有这样一个场景,我们要基于master的倒数第二个commit来创建一个分支,由于我们并不是基于最新的commit,所以要先把分支切换到commit上,而不是branch上,这就是分离头指针 不过千万要谨慎操作,因为分离后的branch是没有名字的,如果不赋予名字,后面会导致修改丢失. 示例如下: 1234567891011121314151617181920# 切换到一个commit上,而不是branch,从而实现分离头指针$ git checkout 1d294ca4f3dd9a0d2adef1528f18afd8ef3ca3d3注意：正在切换到 '1d294ca4f3dd9a0d2adef1528f18afd8ef3ca3d3'。您正处于分离头指针状态。您可以查看、做试验性的修改及提交，并且您可以在切换回一个分支时，丢弃在此状态下所做的提交而不对分支造成影响。如果您想要通过创建分支来保留在此状态下所做的提交，您可以通过在 switch 命令中添加参数 -c 来实现（现在或稍后）。例如： git switch -c &lt;新分支名&gt;或者撤销此操作： git switch -通过将配置变量 advice.detachedHead 设置为 false 来关闭此建议HEAD 目前位于 1d294ca hello.py renamed to Hello.py 然后我们查看一下当前branch的情况: 123456$ git branch* (头指针分离于 1d294ca) master test test2 现在让我们来创建一个分离后的文件吧: 123$ echo "我是分离头指针版本独有的文件内容" &gt; 分离头指针.txt$ git add 分离头指针.txt$ git commit -m "add 分离头指针.txt" 此时我们的新分支是没有名字的,如果我们切换到其他分支,有可能会导致该分支上的修改失效 这里我们尝试切换到master分支: 123456789101112$ git checkout master警告：您正丢下 1 个提交，未和任何分支关联： 718daed add 分离头指针.txt如果您想要通过创建新分支保存它，这可能是一个好时候。如下操作： git branch &lt;新分支名&gt; 718daed切换到分支 'master' 所以这里我们按照提示,给没有名字的新分支一个名字: 12345678$ git branch 实验分离头指针分支 718daed$ git branch* master test test2 实验分离头指针分支 然后我们来一起看一下当前的log: 12345678910111213141516171819202122232425262728293031323334353637383940414243$ git log --all --graph* commit 718daedc590da60e771debf95657de8639d4e1db (实验分离头指针分支)| Author: SherlockGy &lt;sherlockgy@live.com&gt;| Date: Sun Nov 24 15:58:00 2019 +0800|| add 分离头指针.txt|| * commit af289f05ffcba29d35eaaa30e6105244ed67b0ed (HEAD -&gt; master)| | Author: SherlockGy &lt;sherlockgy@live.com&gt;| | Date: Sun Nov 24 15:51:37 2019 +0800| || | add OnlyMaster.rs| || | * commit 5467beb8fdc754ddb14e31dfcd58790dfd9337fb (test2)| |/ Author: SherlockGy &lt;sherlockgy@live.com&gt;| | Date: Sun Nov 24 15:48:25 2019 +0800| || | add HelloAgain.go| || * commit 1f39a383ff3c1140affc1e128b0de17b1c909238|/ Author: SherlockGy &lt;sherlockgy@live.com&gt;| Date: Sun Nov 24 15:22:02 2019 +0800|| add Hello.c|* commit 1d294ca4f3dd9a0d2adef1528f18afd8ef3ca3d3 (test)| Author: SherlockGy &lt;sherlockgy@live.com&gt;| Date: Sat Nov 23 20:26:10 2019 +0800|| hello.py renamed to Hello.py|* commit 5f0628574c79dbc9ebfb1856ec882a80e5946c2b| Author: SherlockGy &lt;sherlockgy@live.com&gt;| Date: Sat Nov 23 19:37:30 2019 +0800|| add hello.py|* commit 7499e499b62642764e31475f4119dc253ca2f151 Author: SherlockGy &lt;sherlockgy@live.com&gt; Date: Fri Nov 22 23:16:30 2019 +0800 add ReadMe 由此可见,我们顺利得在master之前的版本上创建了分支]]></content>
      <categories>
        <category>版本控制</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>版本控制</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言实用库02——文本编码]]></title>
    <url>%2F2019%2F10%2F21%2FGo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%94%A8%E5%BA%9302%E2%80%94%E2%80%94%E6%96%87%E6%9C%AC%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[编码转换假设有一文本，编码为GBK，文本内容为： 12你好，中国我爱你，中国！ 由于Go默认按照utf-8的码表去解析，所以会导致乱码 在Go官方提供的库里面，有一个库可以解决这个问题，但是不包含在标准库内，需要使用go get golang.org/x/text下载 提醒：下载之前请一定配置代理，可参考这篇文章 使用方法： 1234567891011121314151617181920212223242526272829package mainimport ( "fmt" "golang.org/x/text/encoding/simplifiedchinese" "golang.org/x/text/transform" "io/ioutil" "os")const path = "/Users/sherlockgy/Desktop/test.txt"func main() &#123; file, e := os.Open(path) if e != nil &#123; panic("打开文件错误！") &#125; // 编码转换 newReader := transform.NewReader(file, simplifiedchinese.GBK.NewDecoder()) newBytes, e := ioutil.ReadAll(newReader) if e != nil &#123; panic("读取内容错误！") &#125; fmt.Printf("%s\n", newBytes)&#125; 编码猜测123456789101112131415161718192021222324252627282930313233const path = "/Users/sherlockgy/Desktop/test.txt"func main() &#123; file, e := os.Open(path) if e != nil &#123; panic("打开文件错误！") &#125; // 编码猜测 encoding := determineEncoding(file) // 编码转换 newReader := transform.NewReader(file, encoding.NewDecoder()) newBytes, e := ioutil.ReadAll(newReader) if e != nil &#123; panic("读取内容错误！") &#125; fmt.Printf("%s\n", newBytes)&#125;// 猜测编码类型func determineEncoding(r io.Reader) encoding.Encoding &#123; bytes, err := bufio.NewReader(r).Peek(1024) if err != nil &#123; panic(err) &#125; encoding, name, certain := charset.DetermineEncoding(bytes, "") fmt.Printf("编码类型为：%s\n是否确定：%v\n", name, certain) return encoding&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言实用库01——正则表达式]]></title>
    <url>%2F2019%2F10%2F21%2FGo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%94%A8%E5%BA%9301%E2%80%94%E2%80%94%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Go语言中的正则表达式一、正则表达式匹配1.1 匹配单个子串12345678910111213141516171819const str = "my email is sherlockjgy@gmail.com"func main() &#123; // 正则表达式规则声明，解析正则表达式 // 返回Regexp对象，用于后续操作 compile, err := regexp.Compile(`[A-Za-z0-9]+@[A-Za-z0-9]+\.[A-Za-z0-9]+`) if err != nil &#123; panic("你的正则表达式存在语法错误！") &#125; // 从目标字符串当中查找是否存在符合正则表达式规则的字符子串 // 返回true or false isMatch := compile.MatchString(str) fmt.Printf("目标字符串中是否存在符合规则的子串：%v\n", isMatch) // true // 从目标字符串当中查找并返回符合正则表达式规则的字符子串 // 若不存在，则返回空串 matchString := compile.FindString(str) fmt.Println(matchString) // sherlockjgy@gmail.com&#125; 提醒：建议将正则表达式规则书写在【`】引号（键盘1左边的按键）中，这样Go语言不会解析表达式中的转义字符，否则每个斜杠都需要双斜杠代替 1.2 匹配多个子串12345678910111213141516const str = `my email are sherlockjgy@gmail.comand shelockgy@live.com`func main() &#123; // 正则表达式规则声明，解析正则表达式 // 返回Regexp对象，用于后续操作 compile, err := regexp.Compile(`[A-Za-z0-9]+@[A-Za-z0-9]+\.[A-Za-z0-9]+`) if err != nil &#123; panic("你的正则表达式存在语法错误！") &#125; // 从目标字符串当中查找并返回【多个】符合正则表达式规则的字符子串 // 第二个参数代表需要查询多少个符合要求的子串，-1代表查询所有 matchString := compile.FindAllString(str, -1) fmt.Println(matchString, len(matchString)) // [sherlockjgy@gmail.com shelockgy@live.com] 2&#125; 1.3 字符串匹配并分组在正则表达式中运用小括号，可以对被匹配成功对子串进行分组 123456789101112131415161718const str = `my email are sherlockjgy@gmail.comand shelockgy@live.comand helloworld@test.com.cn`func main() &#123; // 正则表达式规则声明，解析正则表达式 // 返回Regexp对象，用于后续操作 compile, err := regexp.Compile(`([A-Za-z0-9]+)@([A-Za-z0-9]+)([.A-Za-z0-9]+)`) if err != nil &#123; panic("你的正则表达式存在语法错误！") &#125; // 返回一个二维数组 matchString := compile.FindAllStringSubmatch(str, -1) for _, value := range matchString &#123; fmt.Println(value) &#125;&#125; 输出： 123[sherlockjgy@gmail.com sherlockjgy gmail .com][shelockgy@live.com shelockgy live .com][helloworld@test.com.cn helloworld test .com.cn]]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言从入门到实战（二）]]></title>
    <url>%2F2019%2F09%2F28%2FGo%E8%AF%AD%E8%A8%80%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Go语言从入门到实战（二）一、变量与常量1.1 变量我们先来看一下Go语言当中的标准变量声明方法： 1var name string = "tom" 其中，var是声明变量的关键字，而name就是我们的变量名。需要特别注意的是，作为类型的string被放在了变量名的后面。这样设计主要是为了引导程序员使用类型自动推导，从而省略变量类型： 12// 使用类型推导var name = "tom" 拓展：这种类型后置的设计在现代编程语言当中已经非常常见了，如Scala、Kotlin、Swift、Rust等 而当我们需要一次性声明多个变量的时候，则可以使用代码块来做： 12345var ( name string age int address string) 当我们的变量是局部变量的时候，我们还可以使用简短声明的方法来声明变量： 123func main() &#123; name := "tom"&#125; 在这里，我们有几个注意点需要强调： 简短声明仅可使用于局部，全局变量必须使用var关键字声明 局部变量一经声明必须被使用，否则将会编译错误；如果需要丢弃该变量，则使用下划线_命名变量 全局变量是包级别的变量，而不是以单个文件作为作用域；全局变量可以声明但不使用 局部变量如果是不同类型（包括int32与int64也不是相同类型），无论如何都不能直接运算，而需要显式类型转换 1.2 常量Go语言的常量使用const关键字进行声明： 1const name string = "tom" 同样，变量类型是可以省略的： 1const name = "tom" 当我们需要一次性声明多个常量的时候，同样可以使用代码块来做： 1234const ( name = "tom" age = 11) 关于常量，我们也有几点需要强调的： 常量声明必须使用关键字的方式，不能使用简短声明 常量可以声明后不使用 常量如果是以省略变量类型的方式声明的，整型和浮点型变量之间可以直接运算 1.3 基于常量的枚举类型Go并不提供专门的枚举类型关键字，如其他语言当中常见的enum。而是通过常量的关键字const + iota的方式，实现枚举 我们先来看一段示例： 1234567891011121314151617func main() &#123; const ( a = 9 // iota值为0，虽然没有被使用，iota依然存在 b = iota // iota值为1，所以b为1 c // iota值为2，c继续使用b的表达式，所以c为2 d = 10 // iota值为3，虽然没有被使用，iota依然存在 e = iota // iota值为4，所以e为4 f = "abc" // iota值为5，f为"abc" g // iota值为6，g继续使用f的表达式，所以g为"abc" h = iota // iota值为7，所以h为7 ) const i = iota // 新的const，iota重制为0，所以i为0 fmt.Printf("a = %v, b = %v, c = %v, ", a, b, c) fmt.Printf("d = %v, e = %v, f = %v, ", d, e, f) fmt.Printf("g = %v, h = %v, i = %v", g, h, i)&#125; 输出 1a = 9, b = 1, c = 2, d = 10, e = 4, f = abc, g = abc, h = 7, i = 0 通过上述例子，可以总结为： iota不管是否被使用，在同一个const代码块内，都会从0开始不断自增；如果遇到新的const，则重制为0 如果枚举项没有声明表达式，则继承上一个枚举项的表达式 二、Go语言的数据类型2.1 布尔与字符串类型 类型 描述 bool 布尔类型（true、flase） string 字符串 2.2 无符号整数类型 类型 描述 uint 长度由系统架构类型决定 uint8 长度为8位，即1字节（0～255） uint16 长度为16位，即2字节（0 到 65535） uint32 长度为32位，即4字节（0 到 4294967295） uint64 长度为64位，即8字节（0 到 18446744073709551615） uintptr 长度为8位，即1字节（0～255） 2.3 有符号整数类型 类型 描述 int 长度由系统架构类型决定 int8 长度为8位，即1字节（-128 到 127） int16 长度为16位，即2字节（-32768 到 32767） int32 长度为32位，即4字节（-2147483648 到 2147483647） int64 长度为64位，即8字节（-9223372036854775808 到 9223372036854775807） 注意：虽然int类型和uint类型长度没有指定，但是不代表它们可以像Python这种语言一样不限制int的大小。例如在64位操作系统上，int和uint的最大值就是int64和uint64的最大值 我们也可以在代码中轻松获得每个数值类型的最大最小值，例如： 1234func main() &#123; fmt.Println(math.MaxInt8) fmt.Println(math.MinInt8)&#125; 那如果我们需要操作的数字的大小，int64已经无法满足了，要怎么办呢？ 我们可以使用math/big包下的函数进行处理： 1234func main() &#123; a, _ := new(big.Int).SetString("999999999999999999999999999999999999", 10) fmt.Println(a)&#125; 关于这一点，此处就不再多说了，毕竟这不是目前的重点。如果需要更多内容，可以直接查找相关API文档 2.4 浮点数类型 类型 描述 float32 长度为4个字节，IEEE-754 32位浮点型数 float64 长度为8个字节，IEEE-754 64位浮点型数 不同于整型当中的int类型，浮点数类型要么是float32要么就是float64，不存在float这个类型 在使用简短声明的时候，编译器会根据当前计算机的架构自动进行推断，从而决定使用float32还是float64 2.4.1 浮点数与字符串类型的转换浮点数转换为字符串： 1234567func main() &#123; var f64 float64 = 1.12 str := strconv.FormatFloat(f64, 'E', -1, 64) str2 := fmt.Sprintf("%v", f64) fmt.Println(str) // 1.12E+00 fmt.Println(str2) // 1.12&#125; 字符串转换为浮点数： 12345func main() &#123; s := "3.1415926" float, _ := strconv.ParseFloat(s, 64) fmt.Println(float)&#125; 2.5 复数类型 类型 描述 complex64 32 位复数（实部与虚部分别32位） complex128 64 位实数和虚数（实部与虚部分别64位） 2.6 别名类型2.6.1 byte和rune 类型 描述 byte 字节类型，uint8类型的别名 rune 字符类型，int32类型的别名 因为Go语言的rune和其他语言的char还是有较大差异，所以我们在这里针对rune类型，多做一些介绍 我们先看一下Go语言源码中，对于rune类型的注释： 1234// rune is an alias for int32 and is equivalent to int32 in all ways. It is// used, by convention, to distinguish character values from integer values.// 符文是int32的别名，在所有方面都等同于int32。按照惯例，用于区分字符值和整数值。type rune = int32 因此，rune其实并不是一个独立的类型，它只是int32类型的另一个称呼罢了。所以，rune类型可以和int32类型直接做计算，而不需要任何转换。 如果我们直接将rune类型的值打印出来，那么它就是一个数字： 12345func main() &#123; c := 'a' fmt.Println(c) // 97 fmt.Printf("%c\n", c) // a&#125; 对于rune类型的类型转换，下面给出两个示例： 例1: 将rune类型转换为字符串： 123456789func main() &#123; c := 'a' // 方法1 fmt.Println(string(c)) // 方法2 str := fmt.Sprintf("%c", c) fmt.Println(str)&#125; 例2： 将rune类型所代表的数字，转换为字符串： 这个问题其实可以等价为，将整型转换为字符串。在其他语言当中，如Python，我们是直接使用str()函数进行转换的，但是因为Go语言的rune类型的存在，如果直接使用string()函数，就会得到该数字对应的字符，而不是数字本身的字符串格式。这显然不是我们想要的。 正确的做法应为： 12345678func main() &#123; i := 97 // 方法1 fmt.Println(strconv.Itoa(i)) // 97 // 方法2 可以同时进行进制转换 fmt.Println(strconv.FormatInt(int64(i), 10)) // 97&#125; 2.6.2 类型定义与类型别名这两个概念我们需要重点区分：类型定义和类型别名 什么是类型定义？举个例子： 123456type myInt intfunc main() &#123; var i myInt = 100 fmt.Println(i)&#125; 在上面的例子当中，myInt这个类型就是我们新定义的。那为什么说是新定义的呢？因为，它和int类型其实并不是一个类型。他只是与int类型有共同的实现、共同的能力罢了。 我们知道Go是一个强类型语言，且不存在类型隐式转换。只要不是同一个类型，就不能直接运算，如下面的代码是不能编译成功的： 1234567type myInt intfunc main() &#123; var i myInt = 100 var j = 100 // 默认为int类型 fmt.Println(i + j) // invalid operation: i + j (mismatched types myInt and int)&#125; 但是如果我们直接与字面量运算，还是没有问题的： 1234567type myInt intfunc main() &#123; var i myInt = 100 var j = i + 100 fmt.Println(j) // 200 并且此时的j也是myInt类型&#125; 我们可以通过使用类型定义这个特性来拓展原有类型的能力： 123456789101112type myInt int// 我们给新的整数类型myInt赋予了自动翻倍的能力func (t myInt) double() int &#123; return int(t * 2)&#125;func main() &#123; i := 100 newNum := myInt(i).double() fmt.Println(newNum) // 200&#125; 而类型别名像我们上述提到type和rune时介绍的一样，并不是一个新的类型，只是叫法不同。这个特性是在Go1.9版本时引入的。 不同于类型定义，我们无法对别名类型的能力进行拓展，因为本来就是同一种类型 三、条件与循环语句3.1 if条件语句示例： 1234567891011func main() &#123; var a = 8 if a &gt; 10 &#123; fmt.Println("大于10") &#125; else if a &gt; 5 &#123; fmt.Println("a大于5") &#125; else &#123; fmt.Println("a小于5") &#125;&#125; 注意：Go语言的if语句，其条件不需要放在括号中 3.2 switch语句3.2.1 基础switch示例： 1234567891011func main() &#123; var a = 5 switch a &#123; case 0, 2, 4, 6, 8: fmt.Println("10以内的偶数") case 1, 3, 5, 7, 9: fmt.Println("10以内的奇数") default: fmt.Println("不是10以内的自然数") &#125;&#125; 输出： 110以内的奇数 这里应该能看出Go和其他主流编程语言的诸多不同，我们这里一一列举： Go语言的switch语句可以用来匹配任何类型，包括结构体 每个case都可以匹配多个值 每个case都默认自带break，如果需要实现switch穿透，则在需要穿透的case结尾加上fallthrough 除此之外，switch还可以作为if-else if结构的简写版本： 123456789101112func main() &#123; var a = 8 switch &#123; case a &gt; 10: fmt.Println("大于10") case a &gt; 5: fmt.Println("a大于5") default: fmt.Println("a小于5") &#125;&#125; 3.2.2 type switchtype switch主要用于对变量类型进行判断的场景，使用方法如下： 123456789101112func main() &#123; var a interface&#123;&#125; = "123" switch a.(type) &#123; case int: fmt.Println("int") case string: fmt.Println("string") default: fmt.Println("other") &#125;&#125; 这里需要说明的是，type switch只能对interface{}类型使用，interface{}类型是一个接口，Go当中所有类型都实现了该接口，所以type switch其实就是判断一个interface{}的实现到底是什么类型 提到了type switch，就不能不提type assertion。type assertion是一个类型断言，他能帮助我们先校验类型，后执行操作。 如下面这个s就可以顺利作为参数传递给println() 1234func main() &#123; var s interface&#123;&#125; = "123" fmt.Println(s.(string))&#125; 3.3 循环语句Go只有for循，但是存在多种不同的使用方式。比如其他语言当中的while循环，在Go语言中也是通过for来实现 3.3.1 经典for循环示例： 12345func main() &#123; for i := 0; i &lt; 10; i++ &#123; fmt.Println(i) &#125;&#125; 其中注意点和if是一样的，即不需要使用括号来包围条件 3.3.2 for循环变体Go中既然没有while循环，那么怎么实现while循环的效果呢？其实只要把for当作while就可以了： 1234567func main() &#123; i := 0 for i &lt; 10 &#123; fmt.Println(i) i++ &#125;&#125; for还可以轻松实现无限循环，相比其他语言的while(true)更加简洁： 12345func main() &#123; for &#123; fmt.Println("forever") &#125;&#125; 3.3.3 for…range当我们需要遍历一个集合或者字符串的时候，使用经典for循环显然是太啰嗦了，我们可以使用for...range语句来简化语法，但是要注意，在某些场景下，for...range不仅仅是帮助我们简化了语法，还多做了一些人性化的事情，后面会详细讲到的。 经典for循环遍历数组： 12]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言从入门到实战（一）]]></title>
    <url>%2F2019%2F09%2F24%2FGo%E8%AF%AD%E8%A8%80%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Go语言从入门到实战（一）一、为什么要学习Go语言在开始我们的学习旅程之前，我们先来了解一下Go语言，通过建立一个宏观的印象，来熟悉一下Go这门语言，消除陌生的感觉。 首先要强调的是，Go是一门通用语言，这也就意味着，不管是Java、C#、Python还是PHP，这些语言可以做到的事情，理论上Go都可以做；Go可以做到的事情，理论上这些语言也都可以做到。 因此，我们在选择一门技术的时候，都是选择去看他最擅长的方面。 但是先别急，我们不妨先去探究一下，Go为什么会被发明？或者说，Go是为了解决什么样的问题而诞生的呢？当我们搞清楚这个问题，Go语言擅长做什么这个问题，也就不言自明了。 2007年前后，软件开发迎来了新挑战，主要包括： 摩尔定律逐渐失效，多核硬件架构的广泛应用 超大规模分布式计算集群 Web模式导致的前所未有的开发规模和更新速度 而为了解决这些问题，Google的三位大牛合作创造了Go语言：Rob Pike、Ken Thompson、Robert Griesemer。 Rob Pike：Unix早期开发者、UTF-8创始人、Plan9操作系统创始人 Ken Thompson：Unix创始人、B语言创始人、UTF-8创始人、参与设计正则表达式、1983年图灵奖获得者 Robert Griesemer：Google V8 JS Engine开发者、Java Hot Spot开发者 所以我们学习Go语言，其最主要的应用场景就是上面所提到的：多核架构下，超大规模集群的项目的开发。 而天生目标明确的Go语言，毫无疑问的具备鲜明的特点，让我们来一一了解。 二、Go语言的特点2.1 简约Go语言所倡导的思想是“Less is more”，他的创造者们希望能用尽量简单的方法，去完成我们的工作，但是Go语言的简约不等于其简单，他的威力丝毫没有因为其简约的设计而弱于其他的编程语言。 Go语言设计的简约性可以体现在以下几个方面： 首先，就是关键字的数量： C Go C++ 11 37 25 84 我们都知道C是一门简单而强大的系统级语言，而Go甚至做到了关键字的数量比他还要少；而C++是与Go语言的理念截然相反的，C++几乎吸收了所有他能吸收的特性，导致了他虽然功能强大，但是过于复杂。 2.2 性能Go语言的特点不仅仅在于简约的设计，更少不了的是他强大的执行速度。 大家都知道Python也是一门上手迅速的编程语言，深受很多程序员的喜爱，然而他的问题就在于作为一门解释性语言性能较弱，因此，Python常用于一些对性能要求不高的地方，如充当“胶水语言”。 而Go作为一门编译型语言，其拥有超越Java的执行速度；又因为他的简约的设计，他还拥有接近Python的开发速度。同时具备这两个特性，使得Go语言充满了吸引力。 2.3 组合的编程思想组合是一种比起传统面向对象编程语言当中的继承更加灵活的编程思想。 组合是has-a的关系，而继承是is-a的关系。这种设计的优越性在于可以进一步的降低耦合，实现更小的封装从而保证功能的专注和单一。我们会在后面的学习中更加深入地感受到这种设计的优越性。 当然，没有最好的设计，只有更适合的设计。组合并不能全盘否定继承的价值。不过对于Go语言来说，组合更加接近其设计思想。 因此，我们在学习和使用Go的过程中，需要训练自己使用组合的方式来思考问题，而不是把Go的代码，写成了Go语法版本的Java 三、Go语言的Killer Application对于一门技术来说，最为重要的除了其即将能创造的价值以外，还有就是已经创造的价值。对一门编程语言来说，如果它曾经实现过杀手级应用，那么毫无疑问，对于该语言的推动与发展都是大有裨益的。 因为，这一方面杀手级应用证明了该语言开发复杂系统的能力，而不仅仅是一个大牛开发的玩具；另一方面，杀手级应用可以将部分应用自身的用户转化为开发该应用的技术的使用者。 杀手级应用（Killer application）是指一个极具价值的计算机程序或服务，消费者愿意为这个程序或服务购买特定硬件、软件产品或服务。——中文维基 Go语言就拥有数个杀手级应用： 用于云计算的两个关键应用是Go语言开发： Docker Kubernetes 用于区块链的杀手级应用和Go兼容最好： Ethereum Hyperledger 以及不得不提的：Go语言自身的编译器也是使用Go语言实现。这样的方式被称为：自举 四、Go语言的安装和准备工作4.1 下载Go安装程序因为Google退出中国大陆的原因，我们正常无法直接从官方网站下载Go安装程序，推荐前往地址：Go语言中文网下载。 如果是Mac OS的用户，可以使用home brew安装。 4.2 官网与文档Golang的官网是https://golang.org，不过因为上面提到的原因，国内不能正常访问，那么替代方案有这么几种： 方案一：Google CN提供的镜像网站：该网站最大的好处就是原版英文，可以获得等同于原官网的体验 方案二：中文版官网：该网站已经部分汉化了，可以帮助阅读英文有困难的同学们 方案三：使用Golang起一个本地服务：安装Golang后，在命令行里输入godoc -http=:8080，并在浏览器访问http://localhost:8080/即可访问本地官网（英文），8080是端口号，可以更改，这种方式优点在于不依赖网络 方案四：https://tip.golang.org/是golang.org的完全限定域名，由Google提供，目前中国大陆可以正常访问 提醒：针对上面的【方案三】，需要补充说明一点：新版的Go安装程序已经不在包含godoc，必须自行安装godoc（中国大陆需要代理）。 4.3 Go环境配置在此之前，我们先学习两个命令： 查看当前Go语言版本：go version 查看当前Go语言环境设置：go env 好，那我们开始吧： 配置环境变量GOPATH是至关重要的一个环节。所谓GOPATH，就是我们存放代码、编译程序的工作目录。 可以自己随意选择一个目录作为“GoPath”，然后将其配置到环境变量当中（具体配置方法可以参考【4.4设置代理】） GoPath路径下的目录结构应该是这样的： 1234GOPATH|-src（必要，请自行创建）|-pkg|-bin 其中，我们的代码就存放在src目录下，包括我们从网络上拉取的第三方包，也会存放在这里。 建议：将你的GoPath路径/bin【追加】到环境变量PATH里（请自行解决），以确保可以调用Go语言开发的工具 提示：从版本1.11开始，我们并不一定要将自己的代码写在GoPath目录下，具体请参见后面介绍“Go Mod”的文章 4.4 设置代理Go为我们提供了非常好用的工具go get，可以直接从网络拉取依赖包（例如：github），但是由于下载速度并不理想，且部分存放在Google服务器上的包文件无法正常获取（中国大陆），我们还是通过配置代理来解决吧。 推荐方法： 如果你的Go版本大于等于1.13，可以直接使用以下命令配置代理： 1$ go env -w GOPROXY=https://goproxy.cn,direct 通用方法： 如果上述推荐方法不适用，或者没有效果，那么我们可以手工配置： Windows：添加系统环境变量，GOPROXY，值为https://goproxy.cn；如果你的版本大于等于1.13，值则为https://goproxy.cn,direct Mac：在目录~/.bash_profile文件下添加：export GOPROXY=https://goproxy.cn，保存并退出；如果你的版本大于等于1.13，则为export GOPROXY=https://goproxy.cn,direct Mac（补充）：如果你的shell不是bash而是zsh，那么则是在该文件下操作：~/.zshrc。或者，依然在~/.bash_profile文件下操作，但是必须将source ~/.bash_profile配置添加入~/.zshrc Mac（提醒）：你可以执行source ~/.bash_profile或~/.zshrc使环境变量配置立刻生效 至此，你的go get命令可以正常工作了。 4.5 开发工具Go语言可以使用的开发工具还是比较丰富的，这里稍微列举几种： GoLand：Jetbrains家的专业IDE，和大名鼎鼎的Java IDE工具“intellij idea”同门。缺点：收费 liteide：由中国人自己开发的Go语言IDE工具，免费。下载说明在此，建议下载二进制文件，而不是手动编译 Eclipse + Goclipse：经典IDE Eclipse通过安装插件支持Go语言开发，免费 VsCode、Atom、Sublime等 + 插件：代码编辑器（Editor）相比IDE更加轻量，同样免费 Vim、Emacs + 插件 五、Go快速上手在第一篇文章的最后，我们一起来快速上手一下Go代码的编写吧。 5.1 Hello World 在你的GoPath目录下的src目录内，创建项目目录（名称自取）。 在项目目录下，创建文件hello.go（名称自取） 12345678910111213// 声明包package main// 导入包import ( "fmt")// 主函数func main() &#123; // 向控制台输出文本内容 fmt.Println("Hello World")&#125; 运行代码： 在.go文件所在目录下，执行命令：go run hello.go 控制台输出： 1Hello World 5.2 解释说明第1行： Go语言的单行注释，不参与程序执行 多行注释则为： 123/* fmt.Println("Hello World")*/ 第2行： Go和其他很多语言一样，使用包来管理和组织代码，其中规则如下： 同一个目录下，所有.go文件的包名必须一致 main包下，必须有且只能有一个main函数 目录的名称不一定非要和包名一致 main方法所在的文件的文件名不要求是main.go 第5、6、7行： 导入依赖包，其中规则如下： 当需要导入的包仅有一个时，可以简写成一行：import &quot;fmt&quot; 包可以设置别名，如import f &quot;fmt&quot; 导入的包，一般必须使用，否则编译不通过 如果不使用导入的包，且想要通过编译，需要将下划线_作为包别名：import _ &quot;fmt&quot; 第10行： main函数是整个程序的入口，具体规则如下： 该示例中，main函数声明为唯一写法。即：没有参数列表、没有返回值 main包下必须有一个main函数，并且只能有一个main函数 Go语言中，所有函数声明均是使用func关键字 Go语言中，函数体使用花括号包围，且左花括号不能另起一行 第12行： 函数的调用，具体规则如下： 函数&amp;表达式结尾均不需要添加分号 一般情况下，调用包函数必须写上包名.。如果需要省略这个部分，可以使用点.作为包别名：import . &quot;fmt&quot; Go语言中，函数名&amp;变量名的首字母大小写均代表包外可见性。大写代表可见，反之不可见 5.3 程序退出码我们可以用程序退出码来表示程序的执行结果，如：返回0代表执行成功，其他则代表出现异常 由于Go语言main函数不支持返回值，所以我们需要给os包下的Exit()函数传值实现 123456789101112package mainimport ( "fmt" "os")func main() &#123; fmt.Println("Hello World") // 设置程序退出码 os.Exit(0)&#125; 注意：这里的退出码范围为0～255，如果传递-1，则会当作255 5.4 传递命令行参数实用的命令行工具都需要传递参数给我们的程序，由于Go的main函数没有参数列表，所以需要使用os包下的Args()函数去接收命令行参数 1234567891011package mainimport ( "fmt" "os")func main() &#123; // 获取并打印命令行参数 fmt.Println(os.Args[1])&#125; 此处Args()函数返回的是一个字符串切片，关于字符串切片我们后面会学习到。这里我们只需要明白，[0]代表取出列表中的第一个元素，而[1]就是取出第二个元素 Args()函数返回的第一个元素（即下标0）永远是程序本身，而第二个元素（下标1）就是我们传入的第一个参数，以此类推… 执行上面的代码： 1$ go run Hello.go haha 控制台输出： 1haha]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go操作文件IO读与写]]></title>
    <url>%2F2019%2F09%2F03%2FGo%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6IO%E8%AF%BB%E4%B8%8E%E5%86%99%2F</url>
    <content type="text"><![CDATA[预备 关于文件操作模式和文件权限的说明： 模式 含义 os.O_WRONLY 只写 os.O_CREATE 创建文件 os.O_RDONLY 只读 os.O_RDWR 读写 os.O_TRUNC 清空 os.O_APPEND 追加 权限： 三个数字分别代表创建者、用户组、其他人对该文件的权限。注意，需要0开头，如：0777 4 2 1 读（r） 写（w） 可执行（x） 直接读文件123456789101112131415161718192021222324252627282930package mainimport ( "fmt" "io" "os")func main() &#123; file, e := os.Open("./main.go") if e != nil &#123; fmt.Println("打开文件失败") return &#125; defer file.Close() var cache = [128]byte&#123;&#125; for &#123; n, e := file.Read(cache[:]) if e == io.EOF &#123; return &#125; if e != nil &#123; fmt.Printf("读文件失败，%T \n", e) return &#125; fmt.Printf(string(cache[:n])) &#125;&#125; 缓存读文件（可按行读）1234567891011121314151617181920212223242526272829303132package mainimport ( "bufio" "fmt" "io" "os")func main() &#123; file, e := os.Open("./main.go") if e != nil &#123; fmt.Println("打开文件失败") return &#125; defer file.Close() reader := bufio.NewReader(file) for &#123; s, e := reader.ReadString('\n’) // 此处可使用ReadLine() if e == io.EOF &#123; return &#125; if e != nil &#123; fmt.Printf("读文件失败，%T \n", e) return &#125; fmt.Printf(s) &#125;&#125; 最简单的方法读文件（此方法不可按行读）123456789101112131415package mainimport ( "fmt" "io/ioutil")func main() &#123; bytes, e := ioutil.ReadFile("./main.go") if e != nil &#123; fmt.Printf("读文件失败，%T \n", e) return &#125; fmt.Printf(string(bytes))&#125; 按字符串或字节写文件123456789101112131415161718192021package mainimport ( "fmt" "os")func main() &#123; file, e := os.OpenFile("./123.txt", os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0744) if e != nil &#123; fmt.Println("打开文件失败！") return &#125; defer file.Close() var text = `祖国你好` // file.Write([]byte(text)) // 按字节写 file.WriteString(text) // 按字符串写&#125; 按缓存方法写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package mainimport ( "bufio" "fmt" "os")func main() &#123; file, e := os.OpenFile("./123.txt", os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0744) if e != nil &#123; fmt.Println("打开文件失败！") return &#125; defer file.Close() var text = `我爱的中国` writer := bufio.NewWriter(file) writer.Write([]byte(text)) writer.Flush() // 使用缓存方法写一定要刷入缓存&#125;/* 这种方法也可以实现按行写文件*/package mainimport ( "bufio" "fmt" "os")var lineList = []string&#123; "静夜思", "窗前明月光，", "疑是地上霜。", "举头望明月，", "低头思故乡。",&#125;func main() &#123; file, e := os.OpenFile("./测试按行写文件.txt", os.O_TRUNC|os.O_CREATE|os.O_WRONLY, 0744) if e != nil &#123; fmt.Println("打开文件失败") return &#125; writer := bufio.NewWriter(file) for _, line := range lineList &#123; writer.WriteString(line + "\n") writer.Flush() &#125;&#125; 使用ioutil写123456789101112package mainimport ( "io/ioutil")func main() &#123; var text = `啊我爱的中国` ioutil.WriteFile("./123.txt", []byte(text), 0744)&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RustTheBook学习笔记04——分支语句]]></title>
    <url>%2F2019%2F07%2F07%2FRustTheBook%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004%E2%80%94%E2%80%94%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 分支语句fn main() &#123; let x = 6; // if是表达式，所以可以用来赋值 let result: String = if x &gt; 5 &#123; "x &gt; 5".to_string() &#125; else &#123; "x &lt; 5".to_string() &#125;; println!("&#123;&#125;", result); println!(); let mut count = 5; // break可以用来返回结果 let count = loop &#123; count += 1; if count == 10 &#123; break count; &#125; &#125;; println!("&#123;&#125;", count); println!(); // while循环 // while循环可以替代掉很多loop、if-else、break循环的组合嵌套 let arr1 = [1, 2, 3, 4, 5]; let mut index = 0; while index &lt; 5 &#123; println!("&#123;&#125;", arr1[index]); index += 1; &#125; println!(); // for循环 // while循环很容易索引越界，for循环更加简单、安全 for elem in arr1.iter() &#123; println!("&#123;&#125;", elem); &#125; println!(); // for循环实现倒计时，输出3 2 1 for number in (1..4).rev() &#123; println!("&#123;&#125;", number); &#125;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Rust</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RustTheBook学习笔记03——函数]]></title>
    <url>%2F2019%2F07%2F07%2FRustTheBook%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[123456789101112131415// 函数fn main() &#123; let result = another_function(1, 2); println!("&#123;&#125;", result);&#125;// 注意语句和表达式的区别：// 语句：没有返回值，比如变量的声明，在Rust中必须以分号结尾// 表达式：有返回值，在Rust中表达式的结尾没有分号// 如果在表达式的结尾加上分号，它就变成了语句fn another_function(x: i32, y: i32) -&gt; i32 &#123; // return x + y; x + y&#125; 注意： 如果在上面示例中的x + y后面加上分号;，那么(x + y);作为一个语句而不是表达式将不会返回值，没有返回值的情况下，默认返回一个空元组()，与函数声明的返回值不符]]></content>
      <categories>
        <category>程序人生</category>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Rust</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RustTheBook学习笔记02——变量与可变性]]></title>
    <url>%2F2019%2F07%2F07%2FRustTheBook%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002%E2%80%94%E2%80%94%E5%8F%98%E9%87%8F%E4%B8%8E%E5%8F%AF%E5%8F%98%E6%80%A7%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920fn main() &#123; // 声明变量，默认不可变 let x = 5; println!("the value of x is &#123;&#125;", x); // 声明一个可变的变量 let mut y = 5; y = 6; println!("the value of y is &#123;&#125;", y); // 声明一个常量 // 必须 注明值的类型 const MAX_POINTS:i32 = 100_000; // 隐藏 let z = 10; let z = z + 1; let z = z + 1; println!("the value of z is &#123;&#125;", z);&#125; 隐藏： 我们可以定义一个与之前变量同名的新变量，而新变量会隐藏之前的变量。Rustacean们称之为第一个变量被第二个隐藏了，这意味着使用这个变量时会看到第二个值。可以用相同变量名称来隐藏一个变量，以及重复使用let关键字来多次隐藏。 隐藏的好处： 当我们需要给变量作类型转换的时候，不需要在变量名后面加上类型后缀了，更加的简洁，例如： 123let age: String = String::from("20");let age: i32 = age.parse().unwrap();println!("age is &#123;&#125;", age); // age is 20 我们不需要分别把变量命名为age_str和age_num，使用隐藏可以很好的完成类型转换而不更换变量名]]></content>
      <categories>
        <category>程序人生</category>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Rust</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RustTheBook学习笔记01——HelloWorld&猜数字游戏Demo]]></title>
    <url>%2F2019%2F07%2F07%2FRustTheBook%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001%E2%80%94%E2%80%94HelloWorld%26%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8FDemo%2F</url>
    <content type="text"><![CDATA[HelloWorld123fn main() &#123; println!("hello world!");&#125; 猜数字游戏Demo 1234567891011121314151617181920212223242526272829303132333435363738use std::io;use rand::Rng;use std::cmp::Ordering;fn main() &#123; println!("Hello, world!"); // 随机生成一个秘密数字 let secret_num = rand::thread_rng().gen_range(1, 101); //println!("秘密数字是：&#123;&#125;", secret_num); loop &#123; println!("请猜测一个数："); // 声明一个字符串保存键盘输入 let mut guess_number = String::new(); io::stdin().read_line(&amp;mut guess_number).expect("Fail to read line!"); let guess_number: i32 = match guess_number.trim().parse() &#123; Ok(num) =&gt; num, Err(_) =&gt; &#123; println!("您输入的不是数字，请重新输入！"); continue; &#125; &#125;; match guess_number.cmp(&amp;secret_num) &#123; Ordering::Less =&gt; println!("小了\n"), Ordering::Greater =&gt; println!("大了\n"), Ordering::Equal =&gt; &#123; println!("Win!\n"); break; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Rust</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyGame内置游戏启动方法]]></title>
    <url>%2F2019%2F07%2F07%2FPyGame%E5%86%85%E7%BD%AE%E6%B8%B8%E6%88%8F%E5%90%AF%E5%8A%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Pygame是Python的一个第三方游戏开发库，他自带了一个默认游戏，我们可以通过这个demo先感受一下Pygame的魅力 启动方法如下： 首先确保你安装了Python以及Pygame，我们假设你已经安装了Python，然后这里我们安装一下Pygame这个库 1pip install pygame 如果是MacOS则自带了Python2，如果你安装了Python3，应该键入以下命令以使用Python3使用；如果是Windows系统则直接安装Python3并以上面命令执行即可 1pip3 install pygame 启动demo 1python -m pygame.examples.aliens 或 1python3 -m pygame.examples.aliens]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>学习</tag>
        <tag>Python</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rust下载包太慢怎么办？配置国内源介绍]]></title>
    <url>%2F2019%2F07%2F06%2FRust%E4%B8%8B%E8%BD%BD%E5%8C%85%E5%A4%AA%E6%85%A2%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E6%BA%90%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[我们可以通过配置rust的配置文件来使用中科大的源作为默认下载源 步骤如下： 进入当前用户的文件夹下对于MacOS/Linux系统来说就是在终端输入cd ~；对于Windows系统的用户就是C:\Users\你的用户名目录 进入名为.cargo的文件夹（目录） 新建一个空文本文件，命名为：config 将以下文本粘贴进去，保存关闭 12345[source.crates-io]registry = "https://github.com/rust-lang/crates.io-index"replace-with = 'ustc'[source.ustc]registry = "git://mirrors.ustc.edu.cn/crates.io-index" 参考1 参考2 阿里云源： 123456[source.crates-io]registry = "https://github.com/rust-lang/crates.io-index"replace-with = "rustcc"[source.rustcc]registry = "https://code.aliyun.com/rustcc/crates.io-index"]]></content>
      <categories>
        <category>程序人生</category>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>学习</tag>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言数据结构——双向列表]]></title>
    <url>%2F2019%2F06%2F26%2FGo%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8F%8C%E5%90%91%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[Golang标准库中，包含双向列表这一数据结构，先来了解一下 源码123456// List represents a doubly linked list.// The zero value for List is an empty list ready to use.type List struct &#123; root Element // sentinel list element, only &amp;root, root.prev, and root.next are used len int // current list length excluding (this) sentinel element&#125; 1234567891011121314151617// Element is an element of a linked list.type Element struct &#123; // Next and previous pointers in the doubly-linked list of elements. // To simplify the implementation, internally a list l is implemented // as a ring, such that &amp;l.root is both the next element of the last // list element (l.Back()) and the previous element of the first list // element (l.Front()). next, prev *Element // The list to which this element belongs. // 该元素属于哪一个list list *List // The value stored with this element. // 此元素存储的值 Value interface&#123;&#125;&#125; 声明12 操作双向列表插入值在最前面/最后面插入12345678910111213141516171819202122func main() &#123; myList := list.New() // 在列表最后添加元素 myList.PushBack("a") printList(myList) // a myList.PushFront("b") printList(myList) // b a myList.PushBack("c") printList(myList) // b a c&#125;// 遍历双向列表listfunc printList(theList *list.List) &#123; currElement := theList.Front() for i := 0; i &lt; theList.Len(); i++ &#123; fmt.Printf("%v ", currElement.Value) currElement = currElement.Next() &#125; fmt.Println()&#125; 在指定值的前/后插入123456789101112131415161718192021222324252627282930func main() &#123; myList := list.New() // 在列表最后添加元素 myList.PushBack("a") myList.PushBack("b") myList.PushBack("c") myList.PushBack("d") myList.PushBack("e") myList.PushBack("f") printList(myList) // a b c d e f // 向第一个元素后面添加元素 myList.InsertAfter("x", myList.Front()) // 向最后一个元素前面添加元素 myList.InsertBefore("z", myList.Back()) printList(myList) // a x b c d e z f&#125;// 遍历双向列表listfunc printList(theList *list.List) &#123; currElement := theList.Front() for i := 0; i &lt; theList.Len(); i++ &#123; fmt.Printf("%v ", currElement.Value) currElement = currElement.Next() &#125; fmt.Println()&#125; 取出值取出第一个值和最后一个值12345678910111213141516func main() &#123; myList := list.New() // 在列表最后添加元素 myList.PushBack("a") myList.PushBack("b") myList.PushBack("c") myList.PushBack("d") myList.PushBack("e") myList.PushBack("f") printList(myList) // a b c d e f frontValue := myList.Front().Value backValue := myList.Back().Value fmt.Println(frontValue, backValue) // a f&#125; 按索引取出值123456789101112131415161718192021222324252627282930313233343536373839404142434445func main() &#123; myList := list.New() // 在列表最后添加元素 myList.PushBack("a") myList.PushBack("b") myList.PushBack("c") myList.PushBack("d") myList.PushBack("e") myList.PushBack("f") printList(myList) // a b c d e f result := getEleFromListByIndex(myList, 4) fmt.Println(result) // e&#125;// 按取出第几个值func getEleFromListByIndex(theList *list.List, index int) interface&#123;&#125; &#123; if index &lt; 0 || index &gt; theList.Len()-1 &#123; return nil &#125; else &#123; if index == 0 &#123; return theList.Front().Value &#125; else &#123; currElem := theList.Front() for i := 0; i &lt; index; i++ &#123; currElem = currElem.Next() if i == index-1 &#123; return currElem.Value &#125; &#125; &#125; &#125; return nil&#125;// 遍历双向列表listfunc printList(theList *list.List) &#123; currElement := theList.Front() for i := 0; i &lt; theList.Len(); i++ &#123; fmt.Printf("%v ", currElement.Value) currElement = currElement.Next() &#125; fmt.Println()&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言学习的注意点]]></title>
    <url>%2F2019%2F06%2F01%2FGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9%2F</url>
    <content type="text"><![CDATA[000_关于环境Golang的官网是https://golang.org，不过因为众所周知的原因，国内不能正常访问，那么替代方案有这么几种： 方案一：Google CN提供的镜像网站：该网站最大的好处就是原版英文，可以获得等同于原官网的体验 方案二：中文版官网：该网站已经部分汉化了，可以帮助阅读英文有困难的同学们 方案三：使用Golang起一个本地服务：安装Golang后，在命令行里输入godoc -http=:8080，并在浏览器访问http://localhost:8080/即可访问本地官网（英文），8080是端口号，可以更改，这种方式优点在于不依赖网络 方案四：https://tip.golang.org/是golang.org的完全限定域名，由Google提供，目前中国大陆可以正常访问 跨平台编译Golang有两个重要的环境变量GOOS和GOARCH,其中GOOS指的是目标操作系统，它的可用值为： darwin freebsd linux windows android dragonfly netbsd openbsd plan9 solaris 一共支持10中操作系统。GOARCH指的是目标处理器的架构，目前支持的有： arm arm64 386 amd64 ppc64 ppc64le mips64 mips64le s390x 一共支持9中处理器的架构 如果我们要生成不同平台架构的可执行程序，只要改变这两个环境变量就可以了（临时禁用CGO，以防出问题），比如要生成linux 64位的程序，命令如下： 1CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build github.com/xxx/hello 前面两个赋值，是更改环境变量，这样的好处是只针对本次运行有效，不会更改我们默认的配置。 以上这些用法差不多够我们用的了，更多关于go build的用法，可以通过以下命令查看: 1go help build 此段摘自 飞雪无情 的博客 001_数据类型rune类型Golang没有Java里面的char类型，取而代之的是rune类型，Golang源码对该类型的注释是这样的： rune is an alias for int32 and is equivalent to int32 in all ways.译：rune是int32的别名，在所有方面都等同于int32。 因此，它在执行以下代码的时候，输出的结果并不是预期的字符a，而是数字97： 1234func main() &#123; myChar := 'a' fmt.Println(myChar) // 97&#125; 这个地方的对应关系是基于ASCII码表的，myChar是一个rune类型变量，而rune其实就是代表整数的int32类型，参照码表，a对应为十进制下的97，所以这里的输出结果是数字97。 要输出字符a的话，需要进行类型转换，将rune类型转换为字符串类型的a： 1234func main() &#123; myChar := 'a' fmt.Println(string(myChar))&#125; 正因为这个特点，我们大概会遇到这个困扰： 如何将一个数字，例如：97转换为字符串使用？ 如果我们套用Python或Java等语言的经验的话，大概会写出这样的代码： 12345func main() &#123; num := 97 s := string(num) fmt.Println(s) // a&#125; 这样显然是不符合我们的预期的，而正确的方法是这样的： 12345func main() &#123; num := 97 s := strconv.Itoa(num) fmt.Println(s) // 97&#125; string类型忽视转义字符，以纯文本输出使用键盘1左边的键&#96;而不是双引号，就可以实现对转义字符以纯文本输出 12var name = `Ja\nck`fmt.Println(name) 输出 1Ja\nck 字符串的遍历string是字符串类型，采用unicode编码，因此在表示非ASCII字符的时候，其大小不是一个字节，具体看示例： 1234func main() &#123; str := "我爱中国" fmt.Println(len(str)) // 12&#125; 因此，我们在遍历的时候，不能直接使用其他编程语言里面常用的按照长度遍历，否则会是这样的结果： 123456func main() &#123; str := "我爱中国" for i := 0; i &lt; len(str); i++ &#123; fmt.Println(str[i]) &#125;&#125; 输出： 123456789101112230136145231136177228184173229155189 使用string()转换类型： 123456func main() &#123; str := "我爱中国" for i := 0; i &lt; len(str); i++ &#123; fmt.Println(string(str[i])) &#125;&#125; 输出就是彻底的乱码： 123456789101112æç±ä¸­å½ 出现这个问题的原因就是，汉字是由多个字节来表示的，而Golang当中的len()是获取的字节长度，而非字符数 正确遍历一个字符串中每一个字符的方法： 12345678910111213func main() &#123; str1 := "我爱中国" for key, value := range str1 &#123; fmt.Println(key, string(value)) &#125; fmt.Println() // 或者 str2 := "我爱中国" for key, value := range []rune(str2) &#123; fmt.Println(key, string(value)) &#125;&#125; 输出： 1234567890 我3 爱6 中9 国0 我1 爱2 中3 国 注意：前者的下标依然是按照字节来计算的，而后者则是按照字符 计算真实长度的方法： 12345func main() &#123; str := "我爱中国" fmt.Println(utf8.RuneCount([]byte(str))) // 4 fmt.Println(utf8.RuneCountInString(str)) // 4&#125; 在不使用range的情况下遍历： 123456789func main() &#123; str := "我爱中国" strBytes := []byte(str) for len(strBytes) &gt; 0 &#123; ch, size := utf8.DecodeRune(strBytes) strBytes = strBytes[size:] fmt.Println(string(ch)) &#125;&#125; 输出： 1234我爱中国 其他字符串操作常用函数strings.Fields：按空格分隔 123456func main() &#123; str := " 我 爱 中 国" fields := strings.Fields(str) fmt.Println(len(fields)) // 4 fmt.Println(fields) // [我 爱 中 国]&#125; int类型关于内存地址Golang当中的int类型的变量，在值改变的时候，其内存地址不会改变 具体示例如下： 例1: 12345func main() &#123; for i := 1; i &lt;= 5; i++ &#123; fmt.Printf("i的值%d，i的地址%p\n", i, &amp;i) &#125;&#125; 输出为： 12345i的值1，i的地址0xc000094000i的值2，i的地址0xc000094000i的值3，i的地址0xc000094000i的值4，i的地址0xc000094000i的值5，i的地址0xc000094000 例2: 123456func main() &#123; a := 1 fmt.Println(&amp;a) a = 2 fmt.Println(&amp;a)&#125; 输出为： 120xc0000940280xc000094028 数组和切片数组和切片的不同 切片是类似指针的引用类型，所以可以直接打印地址，而不需要取地址符号&amp; 数组定义时就会分配内存空间；切片不会 1234567func main() &#123; var s1 [3]int fmt.Printf("%p\n", &amp;s1) // 0xc0000180c0 var s2 []int fmt.Printf("%p\n", s2) // 0x0，没有分配内存&#125; 数组可以和相同类型的数组直接比较，切片只能和nil作比较，刚刚定义的切片为nil 123456func main() &#123; s1 := []int&#123;1, 2&#125; s2 := []int&#123;1, 2&#125; fmt.Println(s1 == s2) // 这是错误的！&#125; 1invalid operation: s1 == s2 (slice can only be compared to nil) 切片的扩容当容量小于1024，当长度超出容量，则容量翻倍，如果翻倍后容量已经大于长度，则容量就是这个数字；如果容量依然小于长度，则容量等于长度 切片的删除元素Golang并没有提供删除的相关功能，但是我们可以利用切片和append实现 这是一个遍历集合，并删除特定元素的例子： 12345678910func main() &#123; s := []string&#123;"a", "b", "c", "d"&#125; for i, value := range s &#123; if value == "c" &#123; s = append(s[:i:i], s[i+1:]...) &#125; &#125; fmt.Println(s) // [a b d]&#125; 方式1: 123456789101112131415161718func main() &#123; // 声明一个切片，作为初始切片 s := []int&#123;1, 2, 3, 4, 5&#125; fmt.Println("初始切片：", s) // 现在我要删除索引为2的元素 n := 2 // 先取索引2前面的元素 newSlice := s[0:n] fmt.Printf("索引n之前的部分：%v，内存地址为：%p\n", newSlice, newSlice) fmt.Printf("此时原切片为：%v，内存地址为：%p\n", s, s) // 再取索引2后面的元素，并和索引2前面的元素合并 newSlice = append(newSlice, s[n+1:]...) fmt.Printf("索引n之前和索引n之后元素合并后的切片：%v，内存地址为：%p\n", newSlice, newSlice) fmt.Printf("此时原切片为：%v，内存地址为：%p\n", s, s)&#125; 输出： 12345初始切片： [1 2 3 4 5]索引n之前的部分：[1 2]，内存地址为：0xc00001a0c0此时原切片为：[1 2 3 4 5]，内存地址为：0xc00001a0c0索引n之前和索引n之后元素合并后的切片：[1 2 4 5]，内存地址为：0xc00001a0c0此时原切片为：[1 2 4 5 5]，内存地址为：0xc00001a0c0 分析： 由于newSlice是从初始切片截取所得，其拥有相同的初始索引位置（索引位置：0）的值（值：1），索引newSlice的内存地址和原始切片的内存地址是相同的 切片的内存地址等于其第一个元素的内存地址，因为此处我们是从0号索引截取，所以s和newSlice的内存地址相同 因此，当我们对newSlice做append操作时，原切片的值也被一起改变了，这并不好 方式2: 解决上述问题的思路就是，我们确实需要一个切片，它的初始元素等于原切片的初始元素，而内存地址不同，我们即想到了创建一个新的slice，而不是在原有slice（或其切片上）上直接操作 我们可以运用copy函数，来拷贝需要的值 12345678910111213141516171819func main() &#123; // 声明一个切片，作为初始切片 s := []int&#123;1, 2, 3, 4, 5&#125; fmt.Println("初始切片：", s) // 现在我要删除索引为2的元素 n := 2 // 先取索引2前面的元素 newSlice := make([]int, n) copy(newSlice, s[0:n]) // 此处的newSlice的内存地址不同于s了 fmt.Printf("索引n之前的部分：%v，内存地址为：%p\n", newSlice, newSlice) fmt.Printf("此时原切片为：%v，内存地址为：%p\n", s, s) // 再取索引2后面的元素，并和索引2前面的元素合并 newSlice = append(newSlice, s[n+1:]...) fmt.Printf("索引n之前和索引n之后元素合并后的切片：%v，内存地址为：%p\n", newSlice, newSlice) fmt.Printf("此时原切片为：%v，内存地址为：%p\n", s, s)&#125; 输出 12345初始切片： [1 2 3 4 5]索引n之前的部分：[1 2]，内存地址为：0xc00009e040此时原切片为：[1 2 3 4 5]，内存地址为：0xc000094000索引n之前和索引n之后元素合并后的切片：[1 2 4 5]，内存地址为：0xc0000a0020此时原切片为：[1 2 3 4 5]，内存地址为：0xc000094000 关于Set和去重Golang是不提供set这种数据类型的，但是这也并没有什么，因为set完全就可以通过使用map来实现 我们在其他语言中，set最常用的就是去重，在Golang中，我们这样写即可： 123456789101112func main() &#123; // 这是一个带有重复元素的切片 s := []int&#123;1, 2, 2, 3, 4, 5, 5, 6&#125; m := map[int]interface&#123;&#125;&#123;&#125; for _, value := range s &#123; m[value] = struct&#123;&#125;&#123;&#125; &#125; for key := range m &#123; fmt.Printf("%d\t", key) // 5 6 1 2 3 4 &#125;&#125; 注意：无论是map还是set，都无法保证集合内元素的顺序和插入时的顺序一致，甚至Golang还刻意提高了其顺序的随机性 002_关于对象声明Golang中常规变量声明有两种方式： 方式一：使用var关键字声明： 1var name string 方式二：使用:=的方式声明 1name := "" 不过值得注意的是，这两种方式还是存在区别的： var关键字声明可以被用在全局位置。也就是说，:=这种方式只能够在函数内部使用 我们知道Golang中的变量一经声明必须使用，否则会抛出xxx declared and not used的错误，不过全局变量可以声明而不使用 003_关于对象的初始化此处参考飞雪无情的文章：Go语言中new和make的区别 尝试思考下面代码的执行结果，并分析原因： 12345func main() &#123; var i *int *i = 10 fmt.Println(*i)&#125; 输出： 1panic: runtime error: invalid memory address or nil pointer dereference 原因是这样的：当我们使用引用类型的时候，必须先分配其内存空间，然后我们存储的值才能有地方放 所以需要像这样： 12345func main() &#123; var i *int = new(int) *i = 10 fmt.Println(*i) // 10&#125; Golang源码中的new 1234567// The new built-in function allocates memory. The first argument is a type,// not a value, and the value returned is a pointer to a newly// allocated zero value of that type.// 分配内存的内置函数。接收的第一个参数是一个类型，而不是一个值// 返回的值是一个指向new的指针// 会分配这个类型的零值func new(Type) *Type make也是用于内存分配的，但是和new不同，它只用于chan、map以及切片的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。 make和new的异同 二者都是内存的分配（堆上），但是make只用于slice、map以及channel的初始化（非零值）；而new用于类型的内存分配，并且内存置为零 make返回的还是这三个引用类型本身；而new返回的是指向类型的指针 其实new不常用所以有new这个内置函数，可以给我们分配一块内存让我们使用，但是现实的编码中，它是不常用的。我们通常都是采用短语句声明以及结构体的字面量达到我们的目的，比如： 12i:=0u:=user&#123;&#125; 这样更简洁方便，而且不会涉及到指针这种比麻烦的操作。 make函数是无可替代的，我们在使用slice、map以及channel的时候，还是要使用make进行初始化，然后才才可以对他们进行操作。 004_for…range当需要在循环中改变值当我们试图在for...range中改变一个切片的值的时候，会遇到这个问题： 123456789func main() &#123; s1 := []int&#123;1, 2, 3, 4, 5&#125; for _, value := range s1 &#123; if value == 3 &#123; value = 9 &#125; &#125; fmt.Println(s1)&#125; 输出： 1[1 2 3 4 5] 其原因是value只是遍历出来的值的拷贝，要对其进行修改，需要使用下标： 123456789func main() &#123; s1 := []int&#123;1, 2, 3, 4, 5&#125; for key, value := range s1 &#123; if value == 3 &#123; s1[key] = 9 &#125; &#125; fmt.Println(s1)&#125; 输出： 1[1 2 9 4 5] 当需要在循环中存储值当我们试图存储被for...range遍历的内容的引用时，可能会出现这样的问题： 12345678910111213func main() &#123; s1 := []int&#123;1, 2, 3, 4, 5&#125; myMap := map[int]*int&#123;&#125; for key, value := range s1 &#123; myMap[key] = &amp;value &#125; // 迭代输出myMap的内容 for key, value := range myMap &#123; fmt.Printf("key = %d, value = %d\n", key, *value) &#125;&#125; 输出： 12345key = 0, value = 5key = 1, value = 5key = 2, value = 5key = 3, value = 5key = 4, value = 5 原因其实很简单：value虽然在遍历过程中，其值一直在修改，但是它的内存地址其实一直都没有变，所以在最后一次循环前放入myMap的引用所存储的值也都被修改为最后的5了 解决方法：其实也很简单，每次循环时创建一个新的变量来存储value的值就可以了，这样放入myMap的内存地址每次也都是不同的 1234567891011121314func main() &#123; s1 := []int&#123;1, 2, 3, 4, 5&#125; myMap := map[int]*int&#123;&#125; for key, value := range s1 &#123; temp := value myMap[key] = &amp;temp &#125; // 迭代输出myMap的内容 for key, value := range myMap &#123; fmt.Printf("key = %d, value = %d\n", key, *value) &#125;&#125; 输出： 12345key = 2, value = 3key = 3, value = 4key = 4, value = 5key = 0, value = 1key = 1, value = 2 当在循环中遇到闭包如果我们执行以下代码： 12345678910111213func main() &#123; s1 := []int&#123;1, 2, 3, 4, 5&#125; fs := [5]func()&#123;&#125; for key, value := range s1 &#123; fs[key] = func() &#123; fmt.Println(value) &#125; &#125; // 执行 for _, value := range fs &#123; value() &#125;&#125; 则会输出： 1234555555 为什么不是输出1 2 3 4 5呢？因为，在匿名函数中，fmt.Println(value)语句的value不是该匿名函数内声明的，而是从外层函数那里获得的引用 没错，闭包内的变量和闭包外的是相同的内存地址，而不是值拷贝 005_关于常量 数值类型常量如果不明确指定类型可以直接运算（如：float64和int32） 常量可以声明但不使用 常量的声明只需要使用=，而不是:=或者var 关于iota注意：iota无论你是否使用，其值都是从0依次递增，直到遇到新的const，iota的值即重制为0 例： 1234567891011121314func main() &#123; const ( a = 9 // iota值为0，虽然没有被使用，iota依然存在 b = iota // iota值为1 c // iota值为2，没有明确声明，继续使用b的表达式 d = 10 // iota值为3，虽然没有被使用，iota依然存在 e = iota // iota值为4 f // iota值为5，没有明确声明，继续使用e的表达式 ) const g = iota // 新的const，iota重制为0 fmt.Printf("a = %d\nb = %d\nc = %d\nd = %d\ne = %d\nf = %d\n", a, b, c, d, e, f) fmt.Println("g =", g)&#125; 输出 1234567a = 9b = 1c = 2d = 10e = 4f = 5g = 0]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python知识学习21——bytes、bytearray和编码]]></title>
    <url>%2F2019%2F04%2F07%2FPython%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A021%E2%80%94%E2%80%94bytes%E3%80%81bytearray%E5%92%8C%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[(一）bytes和bytearray的对比 bytes是不可变的，而bytearray则是可变类型 （二）bytes类型定义一个bytes类型： bytes接收的是一个可迭代类型 1234567891011$ bytes()b''$ bytes([1,2,3])b'\x01\x02\x03'$ bytes([97, 98, 99])b'abc'$ bytes(range(5))b'\x00\x01\x02\x03\x04' （三）编解码12# 将字符串编码为bytes对象'123'.encode() 声明一个bytes类型的对象str，并使用默认编码utf-8将其解码为字符串： 123$ str = b'\xe4\xb8\xad\xe5\x9b\xbd'$ str.decode()'中国']]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python知识学习20——随机数的使用]]></title>
    <url>%2F2019%2F04%2F07%2FPython%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A020%E2%80%94%E2%80%94%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[（一）获得[a, b]之间的随机整数123import randomprint(random.randint(1, 10)) （二）从一个非空序列中随机挑选一个元素123import randomprint(random.choice([1, 2, 3])) 或 1234import random# 从0～9中随机取一整数print(random.choice(range(10))) （三）按指定基数递增的集合中获取随机数基数缺省值为1 1234import random# randrange([start,]stop[,step]) 取不到stop对应的值print(random.randrange(1, 7, 2)) （四）随机打乱列表的元素就地修改，返回值为None 12345import randomlst = [1, 2, 3, 4, 5, 6, 7, 8]random.shuffle(lst)print(lst)]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac运行Swift的REPL时报错的问题]]></title>
    <url>%2F2019%2F03%2F31%2FMac%E8%BF%90%E8%A1%8CSwift%E7%9A%84REPL%E6%97%B6%E6%8A%A5%E9%94%99%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[当在Mac的终端输入swift后，出现报错，经查阅，报错由于使用了Mac版本的Swift和非Mac自带的Python导致，可以通过以下命令解决： 1pip install six 解决方法原文：点我 报错信息如下： $ swiftTraceback (most recent call last):File “”, line 1, inFile “/Applications/Xcode.app/Contents/SharedFrameworks/LLDB.framework/Resources/Python/lldb/init.py”, line 98, inimport sixImportError: No module named sixTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not definedTraceback (most recent call last):File “”, line 1, inNameError: name ‘run_one_line’ is not defined]]></content>
      <categories>
        <category>程序人生</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>故障解决</tag>
        <tag>Mac</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift语言快速入门02——基本运算符]]></title>
    <url>%2F2019%2F03%2F31%2FSwift%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A802%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[说明本系列是自学经历的笔记，不提供多余文字说明，默认有编程基础 正文123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 1. 算术运算let a = 10let b = 20a + b"3" + ".14" // 字符串拼接// 2. 赋值运算符let c = a// 3. 求余数b % aa % b// 4. 组合赋值运算符var d = 1d += 1 // 等同于d = d + 1print(d)// 5. 比较运算符let A = 10let B = 20print(A == B)print(A &gt; B)print(A != B)// 6. 三元运算符let C = 10let D = 20let E = C &gt; D ? C : 100print(E)// 7. 空合运算符let F : String? = nilprint(F ?? "123")// 8. 区间运算符// 8.1 闭区间运算符// a...bprint("开始打印闭区间运算符...")for i in 1...5 &#123; print(i)&#125;print("打印闭区间运算符结束")// 8.2 半开区间运算符print("开始打印半开区间运算符...")for i in 1..&lt;5 &#123; print(i)&#125;print("打印半开区间运算符结束")// 8.3 单侧区间运算符let arr1 = [1, 2, 3, 4, 5]print("打印单侧区间运算符开始...")for i in arr1[..&lt;2] &#123; // 打印索引为0、1的元素 print(i)&#125;print("打印单侧区间运算符结束")// 9. 逻辑运算符// 与、或、非// &amp;&amp; || !]]></content>
      <categories>
        <category>程序人生</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift语言快速入门01——语言基础]]></title>
    <url>%2F2019%2F03%2F31%2FSwift%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A801%E2%80%94%E2%80%94%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[说明本系列是自学经历的笔记，不提供多余文字说明，默认有编程基础 正文123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 0.hello worldprint("Hello World")// 1.常量和变量的声明var a = 1a = 2 // 可以改变值的是变量，使用var声明let a1 = 1 // 常量就是不能改变值的类型，使用let声明// 2.类型标注var a2 : Bool = truea2 = falsevar a3 : Int = 123var a4 : Double = 1.66666666666var a5 : Float = 1.66666666666 // Float类型只到后6位type(of: a2) // 查看变量类型// 3.常量变量的命名let name : Stringlet 姓名 : Stringlet 😆 = "小王"// 4.输出常量和变量print(😆) // print函数会自动在结尾加上‘\n’，表示换行// 4.1字符串插值print("😆代表的是\(😆)") // 反斜杠和括号是Swift语言字符串插值的使用方法// 5.注释// 6.分号let catName = "Tom"; print(catName) // 在同一行写两条独立语句// 7.数据类型与类型转换let three = 3let point = 0.14print("PI = " + String(Double(three) + point))print("PI =", 3 + 0.14) // 注意，虽然整型变量不能直接和浮点数变量相加，但是如果直接是数字就是可以的// 7.1整型let intMin = Int.minlet intMax = Int.maxprint("整型的范围:\(intMin)~\(intMax)")// 7.2千分位计数print(1_000_000 == 1000000)// 7.3多进制let fifteenInDecimal = 15 // 十进制let fifteenInHex = 0xF // 十六进制let fifteenInOctal = 0o17 // 八进制let fifteenInBinary = 0b1111 // 二进制// 8.可选类型let age : Int? = nil // 表示一个确定但缺失的值，避免空指针异常， = nil可以省略// 9.if语句以及强制解析if age == nil &#123; print("age == nil") // print(age!) // 强制解析，消除警告，仅在可选值一定有值时才可以使用，否则会报错&#125;if age == nil &#123; print("age == nil") print(age ?? 20) // 当age是nil时，赋值为20&#125;// 10.可选绑定let school : String? = "外国语"if let mySchool = school &#123; // 如果school不为nil才进行变量的绑定 print("mySchool = " + mySchool)&#125; else &#123; print("school = nil")&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift语言快速入门03——字符串和集合类型]]></title>
    <url>%2F2019%2F03%2F31%2FSwift%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A803%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[说明本系列是自学经历的笔记，不提供多余文字说明，默认有编程基础 正文1234567891011121314151617181920212223242526272829303132333435// 1. 用Character类型定义字符串var a : Character = "好"// 2. 遍历字符串var str = "我爱中国"for i in str &#123; print(i)&#125;// 3. 获得字符串的下标，并通过下标取出字符串中的字符var str2 = "我爱中国"let index = str2.index(str2.startIndex, offsetBy: 2)print(str2[index])// 4. 字符串和字符拼接，不能使用+号var ch : Character = "国"var begin : String = "我爱中"begin.append(ch)print(begin)// 5. 使用Tuple打包数据let success = (200, "HTTP ok")let fileNotFound = (404, "File not found")success.0success.1type(of: success) // 类型：(Int, String)组成的Tuplelet me = (name : "Sherlock", age : 23, job : "Developer") // 让Tuple更容易取值me.nameme.jobvar (successCode, successMsg) = success // 使用Tuple给多个变量赋值successCodesuccessMsg]]></content>
      <categories>
        <category>程序人生</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言学习之旅21——结构体]]></title>
    <url>%2F2019%2F03%2F28%2FGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%8521%E2%80%94%E2%80%94%E7%BB%93%E6%9E%84%E4%BD%93%2F</url>
    <content type="text"><![CDATA[结构体的写法与初始化123456789101112type Student struct &#123; name string id int age int // 代表字符类型 sex byte&#125;func main() &#123; // 初始化结构体1，顺序初始化 var stu1 Student = Student&#123;"tom", 101, 13, 'm'&#125; fmt.Println(stu1) // &#123;tom 101 13 109&#125;&#125; 注意：结构体的成员不需要使用var关键字来声明；字符类型的sex将会打印对应ASCII码，如果你需要声明为汉子，则需要使用rune类型，代表一个 UTF-8 字符 12345func main() &#123; // 初始化结构体2，指定初始化 stu2 := Student&#123;name: "tom", age: 13&#125; fmt.Println(stu2) // &#123;tom 0 13 0&#125;&#125; 结构体指针类型的初始化123456func main() &#123; // 初始化好对象类型后取地址，由指针类型接收 var stu1 *Student = &amp;Student&#123;name: "tom"&#125; // 取内存空间 fmt.Println(*stu1) // &#123;tom 0 0 0&#125;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言学习之旅20——生成随机数]]></title>
    <url>%2F2019%2F02%2F01%2FGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%8520%E2%80%94%E2%80%94%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[生成随机数我们需要设置一个随机数的seed（种子），不过要注意的是，相同的seed每次生成的随机数是同一组的 为了保证随机数能够更加随机且无规律，我们可以使用当前时间作为随机数的seed 具体看代码： 123456789101112func main() &#123; rand.Seed(time.Now().UnixNano()) // 设置种子数为当前时间 for i := 0; i &lt; 5; i++ &#123; fmt.Println(rand.Int()) // 生成一组大数随机数 &#125;&#125;// 8850436535121827008// 6377841482169103266// 4457291880434124677// 3123534825015967222// 3174816732139892017 我们可以这样指定其生成的范围，以免数字过大： 123456789101112func main() &#123; rand.Seed(time.Now().UnixNano()) for i := 0; i &lt; 5; i++ &#123; fmt.Println(rand.Intn(10)) // 生成一组[0,9]范围内的整数作为随机数 &#125;&#125;// 8// 7// 2// 9// 0]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言学习之旅19——new函数的使用]]></title>
    <url>%2F2019%2F02%2F01%2FGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%8519%E2%80%94%E2%80%94new%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[声明一个指针类型的变量，我们会这么做： 12345func main() &#123; var a *int fmt.Println(a) fmt.Printf("%T", a)&#125; 输出 12&lt;nil&gt;*int 由此可见，a确实是一个int类型的指针，但是并没有为其分配内存空间，所以在我们试图打印其内存地址的时候，输出结果是&lt;nil&gt; 如果我们需要修改该指针指向的值，就不得不为其先分配一个内存地址，我们知道：当变量被声明的时候，会创建内存并分配地址，所以方法一如下： 1234567func main() &#123; var a *int b := 10 a = &amp;b // 将变量b的地址赋给指针a fmt.Println(a) fmt.Println(*a)&#125; 输出： 120xc00009000010 但是显然这样做太麻烦了：我们需要创建一个中间变量b才能完成给指针类型分配内存地址的工作，这时候，就需要使用new函数了 方法二：使用new函数 123456func main() &#123; var a *int = new(int) *a = 10 fmt.Println(*a) fmt.Println(a)&#125; new函数可以分配内存地址并返回保存该内存地址的指针]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言学习之旅17——init函数]]></title>
    <url>%2F2019%2F01%2F26%2FGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%8517%E2%80%94%E2%80%94init%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[init函数将会在程序运行的一开始执行，如果导入了其他的依赖包，依赖包的init函数也会自动执行，即使没有使用依赖包内的任何函数 由于go语言导入的包不使用就会报错，因此需要在包名前加上_，代表引入此包仅为了执行其init函数，而无需调用其他方法 被引入的包： 1234567package test_initimport "fmt"func init() &#123; fmt.Println("test init...")&#125; 调用包： 1234567891011121314package mainimport ( "fmt" _ "sherlockgy.com/LearnGo/test_init")func init() &#123; fmt.Println("main init")&#125;func main() &#123; fmt.Println("test")&#125; 执行结果如下： 123test init...main inittest]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言学习之旅18——指针]]></title>
    <url>%2F2019%2F01%2F26%2FGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%8518%E2%80%94%E2%80%94%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[Go语言的指针还是比较简单的，我们首先先了解基本的使用： 取址运算符：&amp; 取出变量的内存地址： 1234func main() &#123; var a int = 10 fmt.Println(&amp;a) // 输出：0xc000070008&#125; 指针类型：*int 定义一个指针类型并接受一个内存地址作为该变量的值： 123456func main() &#123; var a int = 10 var p *int p = &amp;a fmt.Println(*p) // 取指针类型变量所指向的内存地址里，保存的值&#125; 注意：指针类型不赋值的时候，默认为&lt;nil&gt;，而不是NULL 不要使用没有合法指向的内存： 1234func main() &#123; var point *int fmt.Println(*point)&#125; 报错信息为： 12345panic: runtime error: invalid memory address or nil pointer dereference[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x1090d27]goroutine 1 [running]:main.main() 因为该指针类型的变量并没有被赋值，因此取对应内存所保存的值时会报错]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言学习之旅16——接收命令行参数]]></title>
    <url>%2F2019%2F01%2F26%2FGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%8516%E2%80%94%E2%80%94%E6%8E%A5%E6%94%B6%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[我们如果编写的是Linux或Mac等的命令行程序，需要在执行程序的时候接收相关命令，我们就可以使用os包来实现 12345678910111213141516package mainimport ( "fmt" "os")func main() &#123; list := os.Args len := len(list) fmt.Println("命令行参数长度为：", len) for index, v := range list &#123; fmt.Printf("list[%d] = %s", index, v) &#125;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言学习之旅15——延迟调用defer]]></title>
    <url>%2F2019%2F01%2F26%2FGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%8515%E2%80%94%E2%80%94%E5%BB%B6%E8%BF%9F%E8%B0%83%E7%94%A8defer%2F</url>
    <content type="text"><![CDATA[defer关键字修饰的语句将获得延时执行的特性，将会在该方法结束前调用 注意：defer语句只能出现在方法内部 defer的使用1234567func main() &#123; defer fmt.Println("print defer") fmt.Println("print 1")&#125;// print 1// print defer 多个defer的调用顺序defer是延时加载的，当普通语句执行完毕后，defer的语句遵循逆序执行：最先写的defer语句最后执行 12345678910func main() &#123; defer fmt.Println("1") defer fmt.Println("2") defer fmt.Println("3")&#125;/* * 3 * 2 * 1 */ 注意：不管程序是否报错中断，defer语句总会执行，可以理解为Java的finally defer和匿名函数的结合使用12345678910111213func main() &#123; a := 10 b := 20 defer func(int, int) &#123; fmt.Printf("内部：a的函数内值：%d，b的函数内值%d\n", a, b) &#125;(a, b) a = 888 b = 999 fmt.Printf("外部：a的函数内值：%d，b的函数内值%d\n", a, b)&#125; 以上程序的执行结果为： 12外部：a的函数内值：888，b的函数内值999内部：a的函数内值：888，b的函数内值999 我们可以看到，a和b的函数内打印的值是在+=执行后的]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言学习之旅14——匿名函数和闭包]]></title>
    <url>%2F2019%2F01%2F26%2FGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%8514%E2%80%94%E2%80%94%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[在go语言当中，匿名函数可以作为一个函数当中的变量，它没有函数名称但是却可以访问其作用域外的变量，这样的能力被称为闭包 示例： 12345678910111213141516171819202122232425262728func main() &#123; // 01、匿名函数的声明和调用 a := func() &#123; fmt.Println("hello world") &#125; a() // 02、直接调用匿名函数 func() &#123; fmt.Println("你好") &#125;() // ()代表调用函数和传参 // 03、下面演示闭包，匿名函数可以访问函数外的变量 num1 := 10 str1 := "abc" func() &#123; fmt.Printf("num1 = %d, str1 = %s\n", num1, str1) &#125;() // 04、闭包的参数传递特性测试，由于num1被改变了，所以闭包是传递的引用 func() &#123; num1 = num1 + 1 fmt.Printf("num1现在等于%d\n", num1) &#125;() fmt.Printf("num1现在等于%d\n", num1)&#125; 闭包内变量的生命周期与普通函数不同，普通函数的变量在被调用时初始化，调用结束后即被回收，而闭包内的变量的生命周期和作用域无关 1234567891011121314151617// 闭包内变量的生命周期不受其作用域限制func test() func() int &#123; x := 0 return func() int &#123; x++ return x &#125;&#125;func main() &#123; t := test() fmt.Println(t()) fmt.Println(t()) fmt.Println(t()) fmt.Println(t()) fmt.Println(t())&#125; 以上输出结果分别为：1、2、3、4、5]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言学习之旅13——回调函数]]></title>
    <url>%2F2019%2F01%2F26%2FGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%8513%E2%80%94%E2%80%94%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[使用回调函数可以帮助我们提高代码的灵活性，避免硬编码问题，下面我们就来看一下go语言当中，要如何实现回调吧 123456789101112131415161718192021222324// 声明一个函数类型的变量type FuncMath func(int, int) int/* * 用来作为参数传给数学计算方法的函数，代表加法功能 */func add(a int, b int) int &#123; return a + b&#125;/* * 进行数学计算的方法，通过传入函数作为参数来决定其具体作用 */func doMath(a int, b int, funcMath FuncMath) int &#123; return funcMath(a, b)&#125;/* * 程序入口 */func main() &#123; result := doMath(1, 2, add) fmt.Println(result)&#125; 由此可见，所谓回调，即是将一个函数作为变量类型传递给另一个函数作为参数，从而实现程序的多态性]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言学习之旅12——goto和标签]]></title>
    <url>%2F2019%2F01%2F13%2FGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%8512%E2%80%94%E2%80%94goto%E5%92%8C%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[Go语言还是保留了goto这个功能的，但是不建议使用太多，因为会使得代码比较混乱，不易于后续的阅读和维护 goto可以无条件跳转执行的位置，但不能跨函数，需要配合标签label使用 先看这个例子： 123456789101112func main() &#123; fmt.Println(1) goto printThree fmt.Println(2)printThree: fmt.Println(3)&#125;/*result: 1 3*/ 如上所示，goto可以跳过代码直接执行标签位置的语句 不过标签还有一种使用方式，就是配合跳出多层循环，因为break只能跳出当前所在的循环，因此，我们可以配合标签使用： 12345678910111213141516func main() &#123;outer: for &#123; fmt.Println(1) for &#123; fmt.Println(2) break outer &#125; &#125; fmt.Println(3) /*result: 1 2 3 */&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言学习之旅11——类型别名的使用]]></title>
    <url>%2F2019%2F01%2F13%2FGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%8511%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[类型别名和原类型完全一样，只不过是另一种叫法而已，而类型定义和原类型是不同的两个类型。 1234567func main() &#123; type bigInt int64 var a bigInt fmt.Printf("变量a的类型是%T", a) // 变量a的类型是main.bigInt&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言学习之旅10——接收键盘输入]]></title>
    <url>%2F2019%2F01%2F13%2FGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%8510%E2%80%94%E2%80%94%E6%8E%A5%E6%94%B6%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%2F</url>
    <content type="text"><![CDATA[我们除了需要输出值到屏幕，有时候也需要接收来自键盘输入的值，可以使用fmt包内的Scan或Scanf 如果使用Scanf，需要传入格式化类型；或者直接使用Scan 1234567891011func main() &#123; var a string fmt.Println("请任意输入：") //fmt.Scanf("%s", &amp;a) fmt.Scan(&amp;a) fmt.Println("您输入的是：", a)&#125; 注意：传入的变量需取址]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言知识点02——格式化输出类型梳理]]></title>
    <url>%2F2019%2F01%2F13%2FGo%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B902%E2%80%94%E2%80%94%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E7%B1%BB%E5%9E%8B%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[这里梳理一下go语言中，printf可以使用的格式化输出类型： 格式 含义 %% 一个%字面量 %b 一个二进制整数值(基数为2)，或者是一个(高级的)用科学计数法表示的指数为2的浮点数 %c （常用）字符型，可以把输入的数字按照ASCII码相应转换为对应的字符 %d （常用）一个十进制数值(基数为10) %e 以科学记数法e表示的浮点数或者复数值 %E 以科学记数法E表示的浮点数或者复数值 %f 以标准记数法表示的浮点数或者复数值 %g 以%e或者%f表示的浮点数或者复数，任何一个都以最为紧凑的方式输出 %G 以%E或者%f表示的浮点数或者复数，任何一个都以最为紧凑的方式输出 %o 一个以八进制表示的数字(基数为8) %p 以十六进制(基数为16)表示的一个值的地址，前缀为0x,字母使用小写的a-f表示 %q 以双引号括起来的字符串或者字节切片[]byte，或者是以单引号括起来的数字 %s 字符串。输出字符串中的字符直至字符串中的空字符（字符串以’\0‘结尾，这个’\0’即空字符） %t （常用）以true或者false输出的布尔值 %T （常用）输出的值的数据类型 %U 一个用Unicode表示法表示的整型码点，默认值为4个数字字符 %v （常用）使用默认格式输出的内置或者自定义类型的值，或者是使用其类型的String()方式输出的自定义值，如果该方法存在的话。自动匹配类型的格式化 %x 以十六进制表示的整型值(基数为十六)，数字a-f使用小写表示 %X 以十六进制表示的整型值(基数为十六)，数字A-F使用小写表示]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言知识点01——字符和字符串的区别]]></title>
    <url>%2F2019%2F01%2F13%2FGo%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B901%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[在这里梳理一下go语言两大数据类型——字符和字符串的区别及联系 字符 字符声明使用单引号 字符往往只有一个字符，但转义字符除外，如’\n’ 格式化输出为%c 字符串 字符串的声明使用双引号 字符串可以有一个或多个字符组成 字符串都隐藏了一个结束符，’\0’ 格式化输出为%s 例： 1str = "a" // 由'a'和'\0'组成一个字符串]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言学习之旅09——map]]></title>
    <url>%2F2019%2F01%2F12%2FGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%8509%E2%80%94%E2%80%94map%2F</url>
    <content type="text"><![CDATA[map的定义1234567891011121314151617func main() &#123; // 定义map 方法一 m1 := map[string]string&#123; "A": "a", "B": "b", &#125; // 定义map 方法二 empty map m2 := make(map[string]string) // 定义map 方法三 nil var m3 map[string]string fmt.Println(m1) // map[A:a B:b] fmt.Println(m2) // map[] fmt.Println(m3) // map[]，注意：此map为nil&#125; map的赋值1234567func main() &#123; m1 := make(map[string]string, 10) fmt.Println(m1, len(m1)) // map[] 0，注意：这里只是初始化了他的容量，但是len依然是0 m1["A"] = "a" // go语言的赋值方式 m1["B"] = "b" fmt.Println(m1, len(m1)) // map[A:a B:b] 2&#125; map的遍历12345678910func main() &#123; m1 := map[string]string&#123; "A": "a", "B": "b", &#125; for k, v := range m1 &#123; fmt.Printf("ket = %s, v = %s\n", k, v) &#125;&#125; 补充：map的遍历不保证顺序 map的取值1234567func main() &#123; m1 := map[string]string&#123; "name": "sherlock", &#125; fmt.Println(m1["name"]) // sherlock&#125; 当所取的key不存在时： 1234567func main() &#123; m1 := map[string]string&#123; "name": "sherlock", &#125; fmt.Printf("%q", m1["age"]) // ""&#125; 我们可以通过接收第二个返回值来保证map的key存在： 1234567891011func main() &#123; m1 := map[string]string&#123; "name": "sherlock", &#125; name, result1 := m1["name"] age, result2 := m1["age"] fmt.Printf("name = %q, result1 = %t\n", name, result1) // name = "sherlock", result1 = true fmt.Printf("age = %q, result2 = %t\n", age, result2) // age = "", result2 = false&#125; 注意：m1[key]有两个返回值，第一个返回值是key对应的value，第二个返回值是key是否存在的布尔值；若key不存在，取出的value是空字符串 安全取值： 1234567891011func main() &#123; m1 := map[string]string&#123; "name": "sherlock", &#125; if v, result := m1["name"]; result &#123; fmt.Println("value =", v) &#125; else &#123; fmt.Println("map中不存在该key") &#125;&#125; map的删除123456func main() &#123; m1 := map[string]string&#123;"A": "a", "B": "b", "C": "c"&#125; // 删除键为B的键值对 delete(m1, "B") fmt.Println(m1) // map[A:a C:c]&#125; map作函数参数是引用传递12345678910111213func main() &#123; m1 := map[string]string&#123; "A": "a", "B": "b", "C": "c", &#125; testMap(m1) fmt.Println(m1) // map[B:Z C:c A:a]&#125;func testMap(m map[string]string) &#123; m["B"] = "Z"&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言学习之旅08——切片Slice]]></title>
    <url>%2F2018%2F12%2F24%2FGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%8508%E2%80%94%E2%80%94%E5%88%87%E7%89%87%2F</url>
    <content type="text"><![CDATA[Go语言切片切片可以传入三个参数，分别是[low, high, max]，取元素就是从low开始，取high - low个数（等同于Java和Python），max - low的数作为新的切片的容量cap，可以不传max，当max不传时，容量默认和长度len相同。 即：新切片的len = high - low，cap = max - low 示例： 1234567func main() &#123; arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125; fmt.Println(arr[2:6]) // [2 3 4 5] fmt.Println(arr[2:]) // [2 3 4 5 6 7] fmt.Println(arr[:6]) // [0 1 2 3 4 5] fmt.Println(arr[:]) // [0 1 2 3 4 5 6 7]&#125; 注意：切片包头不包尾 视图由数组执行切片所返回的对象是一个view，即视图，若我们在视图上操作数组，会改变原数组 12345678910func updateSlice(arr []int) &#123; // 接收一个切片的view作为参数，而不是不限制长度的数组 arr[0] = 99&#125;func main() &#123; arr1 := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125; fmt.Println("前arr1 = ", arr1) // 前arr1 = [0 1 2 3 4 5 6 7] updateSlice(arr1[:]) fmt.Println("后arr1 = ", arr1) // 后arr1 = [99 1 2 3 4 5 6 7]&#125; 补充：可以在view的基础上继续执行切片（slice），称为Reslice slice的扩展先看示例： 12345678func main() &#123; arr1 := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125; fmt.Println("前arr1 = ", arr1) // [0 1 2 3 4 5 6 7] var arr2 = arr1[3:6] fmt.Println("第一次slice = ", arr2) // [3 4 5] var arr3 = arr2[3:5] fmt.Println("第二次slice = ", arr3) // [6 7]&#125; 对于切片，存在len()和cap()两个概念，len范围内的元素是可以直接获取到的，而超出的部分如果依然在cap的返回内可以通过拓展获取，如果超出cap的长度，则会报错 注意：slice可以向后扩展，不可以向前扩展 slice的操作添加元素123456func main() &#123; s1 := []int&#123;1, 2, 3&#125; // 声明一个切片 var s2 = append(s1, 4) fmt.Println("原切片s1 = ", s1) // 原切片s1 = [1 2 3] fmt.Println("原切片s2 = ", s2) // 原切片s2 = [1 2 3 4]&#125; 补充：slice如果append的长度超过了cap，那么底层会重新给他分配一个更大的数组 补充：由于值传递的原因，必须接受append的返回值 slice的创建slice的默认值是nil，len为0，cap为0，cap每一次扩充大小都是乘以2 12345678910func main() &#123; var s1 []int s2 := []int&#123;1, 2, 3&#125; // 分配初值 s3 := make([]int, 4) // 不分配初始值，指定切片类型，指定长度。不指定容量cap时，容量和长度相同 s4 := make([]int, 4, 10) // 不分配初始值，指定切片类型，指定长度和容量cap fmt.Println("s1 =", s1, "len =", len(s1), "cap =", cap(s1)) // s1 = [] len = 0 cap = 0 fmt.Println("s2 =", s2, "len =", len(s1), "cap =", cap(s2)) // s2 = [1 2 3] len = 3 cap = 3 fmt.Println("s3 =", s3, "len =", len(s1), "cap =", cap(s3)) // s3 = [0 0 0 0] len = 4 cap = 4 fmt.Println("s4 =", s4, "len =", len(s1), "cap =", cap(s4)) // s4 = [0 0 0 0] len = 4 cap = 10&#125; slice的删除删除某一下标的元素： 12345678func main() &#123; s1 := []int&#123;1, 2, 3, 4, 5&#125; fmt.Println("原分片s1 =", s1) // 原分片s1 = [1 2 3 4 5] // 删除下标1的元素 s2 := append(s1[:1], s1[2:]...) // append可以接受可变参数，s1[2:]...语法可以分解分片为多个元素 fmt.Println("s1删除下标元素1后 =", s2) // s1删除下标元素1后 = [1 3 4 5]&#125; 删除分片的头元素： 12345func main() &#123; s1 := []int&#123;1, 2, 3, 4, 5&#125; s2 := s1[1:] fmt.Println(s2) // [2 3 4 5]&#125; 删除分片的末元素： 12345func main() &#123; s1 := []int&#123;1, 2, 3, 4, 5&#125; s2 := s1[:len(s1)-1] fmt.Println(s2) // [1 2 3 4]&#125; slice的拷贝copy()内建函数在第一个参数的基础上，将第二个参数的元素加在其前面，第一个元素被修改 1234567func main() &#123; s1 := []int&#123;1, 2, 3, 4, 5&#125; s2 := []int&#123;8, 9&#125; copy(s1, s2) fmt.Println(s1) // [8 9 3 4 5] fmt.Println(s2) // [8 9]&#125; 切片和数组的区别12345678910111213func main() &#123; // 声明一个数组，数组的长度不可改变，len和cap永远都是5 arr := [5]int&#123;1, 2, 3, 4, 5&#125; fmt.Printf("数组的长度：%d，数组的容量：%d\n", len(arr), cap(arr)) // 声明一个切片，切片的长度可变 slice := []int&#123;&#125; fmt.Printf("原切片的长度：%d，数组容量：%d\n", len(slice), cap(slice)) // 给切片的末尾追加一个成员 slice = append(slice, 1) fmt.Printf("append后切片的长度：%d，数组容量：%d\n", len(slice), cap(slice))&#125; 结果为： 123数组的长度：5，数组的容量：5原切片的长度：0，数组容量：0append后切片的长度：1，数组容量：1]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言学习之旅07——数组]]></title>
    <url>%2F2018%2F12%2F24%2FGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%8507%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[定义数组1234567func main() &#123; var arr1 [5]int // 声明数组，不赋值 arr2 := [5]int&#123;1, 2, 3, 4, 5&#125; // 声明数组并赋值，指定数组长度，完整赋值 arr3 := [5]int&#123;1, 2, 3&#125; // 不完整赋值，未赋值的为0 arr4 := [5]int&#123;2: 1, 3: 2&#125; // 指定下标赋值，为下标2赋值1，下标3赋值2，其余为0 arr5 := [...]int&#123;1, 2, 3, 4, 5&#125; // 声明数组，长度由编译器自动识别&#125; 数组的比较，比较其每一个元素是否都相同： 12345func main() &#123; arr1 := [5]int&#123;1, 2, 3, 4, 5&#125; arr2 := [5]int&#123;1, 2, 3, 4, 5&#125; fmt.Println(arr1 == arr2) // 返回true&#125; 定义二维数组1234func main() &#123; var arr4 [4][5]int // 定义4个长度为5的数组 fmt.Println(arr4)&#125; 遍历数组123456789func main() &#123; for i := 0; i &lt; len(arr4); i++ &#123; // 一般遍历方法 fmt.Println(arr4[i]) &#125; for _, value := range arr2 &#123; // 推荐遍历方法 fmt.Println(value) &#125;&#125; 当使用range进行遍历的时候，可以接受两个返回值，返回值1是下标，返回值2是对应下标的内容，下划线可以表示不需要该返回值 为什么要使用range 意义明确、美观 C++原生没有该能力 Java、Python原生不能同时获取下标和值 注意：在go语言中，数组也是值类型，作为参数传递时，传递的是其拷贝，而不是其引用，因此需要指针才能修改 数组作为函数的参数注意：数组作为参数是值传递，即，我们形参是实参的拷贝，如果需要同步修改，就要使用指针数组 12345678func main() &#123; arr := [5]int&#123;1, 2, 3, 4, 5&#125; modify(&amp;arr) fmt.Println(arr)&#125;func modify(arr *[5]int) &#123; (*arr)[0] = 99 // 使用*取值&#125; 输出：[99 2 3 4 5] 进过测试，这样写也可以，当前go版本为：go version go1.11 darwin/amd64 12345678func main() &#123; arr := [5]int&#123;1, 2, 3, 4, 5&#125; modify(&amp;arr) fmt.Println(arr)&#125;func modify(arr *[5]int) &#123; arr[0] = 99 // 没有取值&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux&Mac系统环境变量配置]]></title>
    <url>%2F2018%2F12%2F23%2FLinux%26Mac%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[mac 一般使用bash作为默认shell Mac系统的环境变量，加载顺序为： /etc/profile /etc/paths ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc 当然/etc/profile和/etc/paths是系统级别的，系统启动就会加载，后面几个是当前用户级的环境变量。 后面3个按照从前往后的顺序读取，如果~/.bash_profile文件存在，则后面的几个文件就会被忽略不读了，如果~/.bash_profile文件不存在，才会以此类推读取后面的文件。~/.bashrc没有上述规则，它是bash shell打开的时候载入的。 如果没特殊说明,设置PATH的语法都为： 12#中间用冒号隔开export PATH=$PATH:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:------:&lt;PATH N&gt; 一、全局设置下面的几个文件设置是全局的，修改时需要root权限 1）/etc/paths （全局建议修改这个文件 ）编辑 paths，将环境变量添加到 paths文件中 ，一行一个路径Hint：输入环境变量时，不用一个一个地输入，只要拖动文件夹到 Terminal 里就可以了。 2）/etc/profile （建议不修改这个文件 ）全局（公有）配置，不管是哪个用户，登录时都会读取该文件。 3）/etc/bashrc （一般在这个文件中添加系统级环境变量）全局（公有）配置，bash shell执行时，不管是何种方式，都会读取此文件。 4）操作步骤1.创建一个文件：1sudo touch /etc/paths.d/mysql 2.用 vim 打开这个文件（如果是以 open -t 的方式打开，则不允许编辑）：1sudo vim /etc/paths.d/mysql 3.编辑该文件，键入路径并保存（关闭该 Terminal 窗口并重新打开一个，就能使用 mysql 命令了）1/usr/local/mysql/bin 这样可以自己生成新的文件，不用把变量全都放到 paths 一个文件里，方便管理。 二、单个用户设置1）~/.bash_profile （任意一个文件中添加用户级环境变量）（注：Linux 里面是 .bashrc 而 Mac 是 .bash_profile）若bash shell是以login方式执行时，才会读取此文件。该文件仅仅执行一次!默认情况下,他设置一些环境变量设置命令别名alias ll=’ls -la’ 设置环境变量： 1export PATH=/opt/local/bin:/opt/local/sbin:$PATH 2）~/.bashrc 同上如果想立刻生效，则可执行下面的语句：$ source 相应的文件一般环境变量更改后，重启后生效。]]></content>
      <categories>
        <category>技巧分享</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Mac</tag>
        <tag>系统配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言学习之旅06——指针初见]]></title>
    <url>%2F2018%2F12%2F23%2FGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%8506%E2%80%94%E2%80%94%E6%8C%87%E9%92%88%E5%88%9D%E8%A7%81%2F</url>
    <content type="text"><![CDATA[go语言的指针没有C语言那么复杂，这里稍加举例 详细一点的介绍请看学习之旅第18篇 12345678910111213141516func passByValue(a int) int &#123; a += 1 return a&#125;func passByRef(a *int) int &#123; *a += 1 return *a&#125;func main() &#123; a := 1 fmt.Printf("%d\n", passByValue(a)) fmt.Printf("%d\n", passByRef(&amp;a))&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言学习之旅05——函数]]></title>
    <url>%2F2018%2F12%2F23%2FGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%8505%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[关于函数之前已经举过一些例子，这里再做详细的介绍 函数的声明go语言的函数由：关键字func + 函数名称 + 参数列表 + 返回值列表 + 函数体组成，若是匿名函数，则可以省略函数名称 多返回值go语言允许一个函数返回多个值，如果调用者只需要其中的部分返回值，不需要的返回值可以使用下划线_符号接收，这样编辑器就不会认为存在没有使用的变量了。 注意：go语言变量一经声明，必须使用，否则编译不通过，通过上述方法可以接收不需要使用的返回值 go语言的返回值可以命名，方式类似参数列表，这样做的好处是有： 假设我们将返回值命名为score，那么我们如果在函数体内只需要给score赋完值，返回时只需要写return即可，而不是return score 调用该函数的时候，可以通过返回值名称（由IDE工具生成或显示）来判断每一个返回值得含义 函数式编程我们可以将一个函数传入作为入参，这样就可以实现动态化的功能 12345678910111213func fp(op func(a, b int) int, a, b int) int &#123; // 函数式编程，函数作为入参 return op(a, b)&#125;func main() &#123; // 函数式编程 result := fp(func(a, b int) int &#123; return int(math.Pow(float64(a), float64(b))) &#125;, 3, 4) fmt.Println(result)&#125; 可变参数列表go语言没有默认参数默认值这样的设计，但是依然拥有可变参数列表： 12345678func sum(nums ...int) int &#123; // 可变参数列表 result := 0 for i := 0; i &lt; len(nums); i++ &#123; result += nums[i] &#125; return result&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言学习之旅04——循环语句]]></title>
    <url>%2F2018%2F12%2F23%2FGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%8504%E2%80%94%E2%80%94%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[简单for循环：123for i := 0; i &lt; 10; i++ &#123; fmt.Printf("%d\n", i)&#125; 需要注意的是，go语言的for循环不同于Java或C语言，不需要用括号来包裹表达式 go语言没有while循环，所以所有其他语言while的使用场景，go语言的for循环都可以完成： 死循环12345func forever() &#123; for &#123; fmt.Println("hello") &#125;&#125; 省略for循环的定义和递增，仅保留判断条件1234567891011121314151617func readFile(fileName string) (string, error) &#123; result := "" file, err := os.Open(fileName) if err != nil &#123; error := fmt.Errorf("打开文件错误") return result, error &#125; else &#123; scanner := bufio.NewScanner(file) // 一行一行地读文件 fmt.Println("文件内容：start") for scanner.Scan() &#123; // scanner.Scan()返回布尔类型，此处for循环只保留了循环条件，代替while fmt.Println(scanner.Text()) &#125; fmt.Println("文件内容：end") &#125; return result, nil // nil代表不存在，这里指没有error&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言学习之旅03——条件语句]]></title>
    <url>%2F2018%2F12%2F23%2FGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%8503%E2%80%94%E2%80%94%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[if语句12345678910func main() &#123; a := 88 if a == 100 &#123; fmt.Print("满分") &#125; else if a &gt;= 90 &#123; fmt.Println("优秀") &#125; else &#123; fmt.Println("一般") &#125;&#125; 在go语言当中，if语句还可以同时赋值并判断，两条语句使用分号;`隔开 123456789func main() &#123; var chinese int = 88 var math int = 79 if total := chinese + math; total &lt; 180 &#123; fmt.Print("不够好") &#125; else &#123; fmt.Print("还不错") &#125;&#125; switch语句go语言的switch语句中，每一个case都默认有break，如果需要穿透的效果，则使用fallthrough关键字 12345678910111213141516171819func eval(a, b int, op string) int &#123; // 四则运算 var result int switch op &#123; case "+": result = a + b case "-": result = a - b case "*": result = a * b case "/": result = a / b case "?": fallthrough default: panic("unsupported operator:" + op) // 报错 &#125; return result&#125; 通常switch需要传入一个表达式才可以和case匹配，但是在go语言的设计当中，表达式不是必须的： 12345678910111213141516171819202122func scoreLevel(score int) string &#123; // 计算成绩等级 result := "" switch &#123; // switch可以没有表达式 case score &lt; 0 || score &gt; 100: panic(fmt.Sprintf("wrong score:%d", score)) // 强制报错并中断程序的执行 case score &lt; 60: result = "E" case score &lt; 70: result = "D" case score &lt; 80: result = "C" case score &lt; 90: result = "B" case score &lt; 100: result = "A" case score == 100: result = "S" &#125; return result&#125; 注意：go语言的返回值类型写在方法的后方]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言学习之旅02——常量与枚举]]></title>
    <url>%2F2018%2F10%2F10%2FGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%8502%E2%80%94%E2%80%94%E5%B8%B8%E9%87%8F%E4%B8%8E%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[常量首先需要强调：定义常量，Go语言常量不需要全部大写，因为在Go语言当中，大小写带有特殊含义 Go语言定义常量的关键字是const，可以显式地指名类型，也可以不指明，例如下： 1234567func consts() &#123; const filename string = "abc.txt" const a, b = 3, 4 // 不指名类型 类型不确定 可做各种类型 var c int c = int(math.Sqrt(a*a + b*b)) // a和b都被视作float64类型 fmt.Println(c)&#125; 补充：声明常量自动推导类型，使用=而不是:= 枚举Go语言中的枚举是通过一组常量实现的： 12345678910func enums() &#123; // 枚举类型，一组const，必须指定值 const ( cpp = 0 java = 1 python = 2 golang = 3 ) fmt.Println(cpp, java, python, golang)&#125; 上面的枚举类型的例子可以这样简化： 12345678910func enumsSimple() &#123; // 枚举类型，简化 const ( cpp = iota // 自增 java python golang ) fmt.Println("枚举类型简化：", cpp, java, python, golang)&#125; 补充：iota是常量自动生成器，给常量赋值使用。从0开始，每行自动累加1；可以仅第一行写iota；如果是在同一行，值都为同一个值 补充：iota如果遇到下一个const，值重置为0 小练习使用枚举类型的简化运算计算：打印字节单位b、kb、mb、gb、tb、pb的字节数 123456789101112func execise() &#123; // 枚举类型，简化运算 const ( b = 1 &lt;&lt; (10 * iota) // 自增，iota从0开始，1左移10即:1乘以（2的10次方） kb // 1乘以（2的20次方） mb gb tb pb ) fmt.Println("枚举类型的简化运算 练习", b, kb, mb, mb, gb, tb, pb)&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言学习之旅01——变量与数据]]></title>
    <url>%2F2018%2F09%2F15%2FGo%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%8501%E2%80%94%E2%80%94%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[大道至简Go语言（Golang）作为一门崇尚简洁的编程语言，主张使用20%的设计，解决80%的问题，他的全新设计思路，在如今21世纪非常值得我们去学习参考 它没有隐式数据类型转换，没有构造函数或者析构函数，没有运算符重载也没有继承、泛型、异常…但它却拥有垃圾搜集、一等函数、词法作用域以及channel等等 学习Go语言，就犹如打开编程语言世界的一扇新窗 数据类型按类别 整体类型 描述 布尔型 布尔型的值只可以是常量 true 或者 false。例：var b bool = true 数字类型 整型 int 和浮点型 float32、float64，Go 语言原生支持复数，其中位的运算采用补码 字符串类型 字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串是由单个字节连接起来的。Go语言的字符串的字节使用UTF-8编码标识Unicode文本 派生类型 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) Channel 类型(e) 函数类型(f) 切片类型(g)接口类型（interface）(h) Map 类型 整数类型 描述 uint8 无符号 8 位整型 (0 到 255) uint16 无符号 16 位整型 (0 到 65535) uint32 无符号 32 位整型 (0 到 4294967295) uint64 无符号 64 位整型 (0 到 18446744073709551615) int8 有符号 8 位整型 (-128 到 127) int16 有符号 16 位整型 (-32768 到 32767) int32 有符号 32 位整型 (-2147483648 到 2147483647) int64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) 浮点数&amp;复数类型 描述 float32 IEEE-754 32位浮点型数 float64 IEEE-754 64位浮点型数，浮点数默认类型 complex64 32 位实数和虚数 complex128 64 位实数和虚数，复数默认类型 其他数字类型 描述 byte uint8别名，用来存放字符 rune 等价int32，存放Unicode编码 uint 32 或 64 位 int 与 uint 一样大小 uintptr 无符号整型，用于存放一个指针 1234复数回顾： 定义i = 根号下-1 复数：3 + 4i i平方 = -1 i三次方 = -i i四次方 = 1... 123456789101112131415package mainimport ( "math" "fmt")func main() &#123; // 强制类型转换，Go语言没有隐式类型转换 var a, b int = 3, 4 var c int // c = math.Sqrt(a * a + b * b) // 返回平方根 c = int(math.Sqrt(float64(a*a + b*b))) // 强制类型转换 fmt.Println(c)&#125; 变量定义1234567891011121314151617181920212223242526272829303132333435func variable() &#123; // 定义变量，注意，变量名在前，类型在后 var a int var s string fmt.Println(a, s) // 打印Go语言变量的初值 fmt.Printf("%d, %q\n", a, s) // quotation，字符串打印引号&#125;func variableTypeDeduction() &#123; // 自动推断类型 var s = "abcd" var a, b, c = 1, true, "hello" // 定义多个变量，即使不是同一类型 fmt.Println(s, a, b, c)&#125;func variableShorter() &#123; a, b, c := 1, true, "hello" // 定义变量，不使用var关键字（在函数外面定义变量不可以简写） fmt.Println(a, b, c)&#125;func variableInit() &#123; // 定义变量并赋初值 var a int = 3 var b, c int = 4, 5 // 同时定义多个变量，Go定义变量必须要被使用到 var s string = "abc" fmt.Println(a, b, c, s)&#125;func main() &#123; variable() // 定义变量 variableTypeDeduction() // 自动推断类型 variableShorter() // 自动推断类型 简写（函数外的包变量不可以简写） variableInit() // 定义变量并赋初值&#125; 补充：Go定义变量必须要被使用到，如不需要使用，使用下划线_接收 补充：Go在调用函数的时候，如果需要省略包名，使用下点.接收]]></content>
      <categories>
        <category>程序人生</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL学习步骤分享]]></title>
    <url>%2F2018%2F09%2F01%2FSQL%E5%AD%A6%E4%B9%A0%E6%AD%A5%E9%AA%A4%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[阶段一学习SQL基本语句、关系型数据库的基本知识 推荐零基础入门者从此部分开始学习 推荐书籍： 《关系数据库和SQL语言》或同类数据，每天两小时两天就可以看完 学习建议： 结合书本自己操作一遍 阶段二学习ORACLE数据库和PL/SQL编程 对数据库和SQL有了一定的了解之后，可以进入该阶段 推荐书籍： 《Oracle PL/SQL从入门到精通》 《精通Oracle Database 12c SQL&amp;PL/SQL编程》 学习建议： 最好看书结合网络上的一些视频学习（也可以是带视频的书籍），这样会轻松很多，书本可作为以后的工具书使用 建议不要在本地数据库进行练习 阶段三选择性的深入学习 根据岗位和职业规划，选择深入学习的方向： 数据库管理 SQL调优 大数据 数据库编程接口]]></content>
      <categories>
        <category>程序人生</category>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL简述02——SQL基础知识]]></title>
    <url>%2F2018%2F09%2F01%2FSQL%E7%AE%80%E8%BF%B002%E2%80%94%E2%80%94SQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[SQL的分类（一）DDL数据定义语言作用：用于检索或修改数据 命令： SELECT：用于检索数据 INSERT：用于添加数据到数据库 UPDATE：用于修改数据库数据 DELETE：用于删除数据库数据 （二）DML数据操作语言作用：用于定义数据结构，比如：创建、修改或删除数据库对象，包括：用于创建用户和重建数据库对象 命令： CREATE TABLE：创建表 ALTER TABLE：修改表 DROP TABLE：删除表 CREATE INDEX DROP INDEX （三）DCL数据控制语言作用：用于定义用户权限 命令： ALTER PASSWORD GRANT REVOKE CREATE SYNONYM 语句介绍（一）SELECT作用： SELECT语句用于从数据库中选取数据 语法： SELECT 列名称 FROM 表名称 SELECT * FROM 表名称 补充： 结果集：SELECT语句将取出的数据存储在一个结果表，也称结果集result set （二）DISTINCT作用： DISTINCT用于不重复的显示查询结果集，即重复数据只显示一次 语法： SELECT DISTINCT 列名称 FROM 表名称 （三）WHERE语句作用： WHERE能有条件的从表中选取数据 语法： SELECT 列名称 FROM 表名称 WHERE 列运算符值 补充： 列运算中的常见运算符： 运算符 含义 = 等于（注意只有一个等号） != 或 &lt;&gt; 不等于 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 BETWEEN 在某个范围内 LIKE 模糊搜索 AND 并且 OR 或者 NOT 取反 引号的使用： 数值类型无需加单引号 字符类型要加单引号 别名使用双引号 双引号还被用来将文本放入日期格式 （四）ORDER BY语句作用： ORDER BY能给查询的结果集排序 语法： ORDER BY DESC ORDER BY ASC 补充： ORDER BY默认是升序排列（从小到大） DESC代表降序排列 ASC代表升序排列 Oracle数据库中，null默认为最大值 指定NULLS FIRST，则表示null值的记录将排在最前(不管是asc，还是desc) 指定NULLS LAST，则表示null值的记录将排在最后(不管是asc，还是desc) （五）INSERT语句作用： INSERT INTO用于向表中插入数据 语法： INSERT INTO 表名称 VALUES (值1, 值2…) INSERT INTO 表名称 (列1, 列2…) VALUES (值1, 值2…) （六）UPDATE语句作用： UPDATE用于更新表中记录 语法： UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值 （七）DELETE语句作用： DELETE用于删除表中的行 语法： DELETE FROM 表名称 WHERE 列名称 = 某值 进阶语句介绍（一）SELECT TOP语句作用： SELECT TOP子句用于规定要返回的记录的数目，该子句对大型表来说非常有用 语法： SELECT 列名称 FROM 表名称 WHERE ROWNUM &lt;= number （二）LIKE操作符作用： LIKE操作符用于在WHERE子句中搜索列中指定模式，加上通配符可以实现很多灵活的条件查询 语法： SELECT 列名称 FROM 表名称 WHERE 列名称 LIKE 某值 补充： 通配符： %代表一个或多个字符 _代表一个字符 （三）IN操作符作用： IN操作符允许你在WHERE子句中规定多个值 语法： SELECT 列名称 FROM 表名称 WHERE 列名称 IN (值1, 值2…) （四）BETWEEN…AND操作符作用： BETWEEN...AND选取介于两个值之间的数据范围内的值，这些值可以是数据、文本或日期 语法： SELECT 列名称 FROM 表名称 WHERE 列名称 BETWEEN 值1 AND 值2 补充： 不同数据库对该字段的处理稍有不同，在Oracle数据库中，查找到的数据包含AND字符前后的两个边界数据 （五）别名作用： 为表名称或列名称指定别名，创建别名主要是为了更强的可读性 语法： SELECT 列名称 别名 FROM 表名称 （六）SQL连接作用： SQL JOIN用于把两个或多个表的行结合起来 语法： Join的四种类型： JOIN，如果表中至少有一个匹配，则返回行 LEFT JOIN，即使右表没有匹配，也从左表返回所有行 RIGHT JOIN，即使左表没有匹配，也从右表返回所有行 FULL JOIN，只要其中一张表存在匹配，就返回行 （七）UNION操作符作用： SQL UNION操作符合并两个或多个SELECT语句的结果，UNION内部的SELECT语句必须拥有相同数量的列，列必须拥有相似的数据类型 同时，每个SELECT语句的列的顺序必须相同 语法： SELECT 列名称 FROM 表名称UNIONSELECT 列名称 FROM 表名称 补充： UNION默认选取不同的值，如果需要允许重复值，使用UNION ALL SQL函数（一）分组函数 常用函数 作用 AVG 求平均值 COUNT 返回查询的行数 MAX 返回查询列的最大值 MIN 返回查询列的最小值 SUM 返回查询列的总和 分组函数常结合GROUP BY使用 （二）转换函数 常用函数 作用 TO_DATE 将字符串转换为日期 TO_CHAR 转换日期或数值为字符串 TO_NUMBER 转换字符串为数字 举例： 1234-- 获取系统当前时间select sysdate from dual-- 日期格式化select sysdate ATIME, to_char(sysdate, 'YYYYMMDDHH24MISS') STIME from dual]]></content>
      <categories>
        <category>程序人生</category>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL简述01——什么是SQL]]></title>
    <url>%2F2018%2F09%2F01%2FSQL%E7%AE%80%E8%BF%B001%E2%80%94%E2%80%94%E4%BB%80%E4%B9%88%E6%98%AFSQL%2F</url>
    <content type="text"><![CDATA[本系列文章主要基于Oracle 什么是数据库 简单来说，数据库就是数据的集合 我们可以把数据库看成是一种有组织的机制；它能够存储信息，用户能够使用有效且高效的方式检索其中的信息 而关系型数据库就是建立在关系模型上的数据库，借助于集合代数等数学概念和方法来处理数据库中的常见数据，在关系型数据库管理系统（RDBMS）中的数据被存储在称为表的数据库对象中，表是相关数据项的集合，它由行和列组成 补充： 常见的关系型数据库 MS SQL Server IBM DB2 Oracle MySQL Microsoft Access 非关系型数据库 MongoDB Redis 手机应用的数据库 SQLite 大数据分布式数据库 postgreSQL 什么是SQL 结构化查询语言 关系型数据库标准语言 ANSI标准计算机语言 虽然存在多个不同版本的SQL语言，但他们必须以相似的方式支持一些主要的命令（如：SELECT、UPDATE、DELETE、INSERT、WHERE等） 补充：什么是PL/SQL PL/SQL（过程化SQL语言）是Oracle对SQL语句的一个拓展，在普通SQL语句上加入了编程语言的特点， 所以PL/SQL可以把数据操作和查询语句组织在PL/SQL代码的过程性单元中，通过逻辑判断、循环等操作实现复杂的功能或计算 SQL能做什么数据操作 面向数据库执行查询 从数据库取回数据 在数据库中插入新的记录 更新数据库的数据 从数据库删除记录 数据定义 可以创建新数据库 可以在数据库中创建表 可以在数据库中创建存储过程 可以在数据库中创建视图 数据控制SQL可以设置表、存储过程、视图的权限 程序开发可以在你的程序、网站的后台使用SQL SQL在工作中的场景研发 编程中数据库操作模块（数据库接口技术、SQL增删改查） 需求的数据库配置修改（SQL增删改查） 系统割接中的数据迁移（PL/SQL编程） 数据库定时任务和辅助工具的开发 （PL/SQL编程） 测试 数据库配置SQL脚本测试（SQL增删改查） 程序数据库操作模块的测试（数据库接口技术、SQL增删改查） 数据库对象操作的脚本测试（数据库对象操作） 编写测试工具（PL/SQL编程） 应用维护 上线或需求执行数据库脚本（SQL增删改查） 日常运维任务（SQL增删改查） 程序数据库操作模块维护（数据库接口技术、SQL增删改查） 批量数据分析（SQL高级查询、数据分析技术） 编写数据批量修改脚本（PL/SQL编程：特别是游标的使用、数据库对象操作、SQL调优技术） 通过编写存储过程和函数开发维护工具（PL/SQL编程） 系统维护 操作数据库对象脚本的编写和执行（数据库对象操作） SQL脚本评审（PL/SQL编程、数据库对象操作、SQL调优技术） 日常数据清理和故障处理（PL/SQL编程、数据库对象操作、数据库管理技术） 通过编写存储过程和函数开发维护工具（PL/SQL编程、数据库对象操作、数据库管理技术）]]></content>
      <categories>
        <category>程序人生</category>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置VsCode自动换行]]></title>
    <url>%2F2018%2F09%2F01%2F%E8%AE%BE%E7%BD%AEVsCode%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[我们会发现，Visual Studio Code是默认不会自动换行的 那么如何设置它按照我们的可视区域自动折行呢？ 方法如下： 文件 -&gt; 首选项 -&gt; 设置 如果你是Mac则是右上角 Code -&gt; 首选项 -&gt; 设置 然后在右侧的编辑窗口中添加： 1&quot;editor.wordWrap&quot;: &quot;on&quot;]]></content>
      <categories>
        <category>技巧分享</category>
        <category>工具</category>
        <category>Visual Studio Code</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python命令行工具——iPython安装与使用]]></title>
    <url>%2F2018%2F08%2F23%2FPython%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94iPython%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、安装iPython通过pip install ipython的方式来安装ipython插件 如果你使用的是Mac电脑并安装了Python3，那么你也许需要输入pip3 install ipython 如果执行报错，找不到pip命令，可以通过命令行前往python安装路径下的Scripts目录，然后执行以上命令 二、基本操作在命令行输入ipython进入交互界面 清屏：输入clear 退出：输入exit() 查看帮助 使用help(name)函数调用python的帮助功能 使用?查看ipython工具的概要介绍 使用obj?调用ipython的帮助功能 使用obj??调用ipython更详细的帮助功能 特殊变量在ipython中，_变量具有特殊含义，指代上一次执行的表达式的结果 类似还有： __表示倒数第二次执行的表达式的结果 ___表示倒数第三次执行的表达式的结果 _dh表示目录历史 _oh表示输出历史 shell命令在ipython中可以直接使用系统的shell命令，使用!command使用或直接使用command（无叹号调用的不是shell） 魔术方法%magic %alias定义一个系统命令的别名 %timeit statement（-n 一个循环loop执行语句多少次；-r 循环执行多少次loop，取最好结果） %timeit setup_code %cd、%ls、%pwd等都是ipython内部实现的魔术方法，与操作系统无关 三、安装自动补全请继续执行命令pip install pyreadline或pip3 install pyreadline 按tab即可自动补全]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
        <category>Python工具</category>
      </categories>
      <tags>
        <tag>命令行</tag>
        <tag>Python</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python知识学习19——IO操作]]></title>
    <url>%2F2018%2F08%2F22%2FPython%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A019%E2%80%94%E2%80%94IO%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。 打开文件先给出一个示范程序 123f = open("test.py", "w")f.read()f.close() 补充：close()操作关闭文件是非常必要的，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的 这里介绍打开文件常用的几种访问模式 访问模式 说明 r 以只读的方式打开文件，文件的指针将会放在文件的开头，这是默认的模式（文件必须存在） w 打开一个文件只用于写入，如果该文件已经存在则将其覆盖；如果该文件不存在，创建新的文件 a 打开一个文件用于追加，如果该文件已存在，文件指针将放在该文件的结尾；如果不存在，创建新文件以供写入 rb 以二进制格式打开一个文件用于读写，文件的指针放在文件的开头，这是默认模式（文件必须存在） wb 以二进制格式打开一个文件用于写入，如果文件已存在则将其覆盖；如果文件不存在，创建新文件以供写入 ab 以二进制格式打开一个文件用于追加，如果文件已存在，文件指针将放在文件的结尾；如果文件不存在，创建新文件以供写入 r+ 打开一个文件用于读写，文件指针将放在文件开头 w+ 打开一个文件用于读写，如果文件已存在，则将其覆盖；如果不存在，创建新文件以供读写 a+ 打开一个文件用于读写，如果该文件已存在，文件指针将放在文件结尾；文件打开时会是追加模式；如果文件不存在，创建新文件以供读写 rb+ 以二进制格式打开一个文件用于读写，文件指针将放在开头 wb+ 以二进制格式打开一个文件用于读写，如果该文件已存在则将其覆盖；如果不存在，创建新文件以供读写 ab+ 以二进制格式打开一个文件用于追加，如果该文件已存在，文件指针将放在文件结尾，如果该文件不存在，创建新文件以供读写 读写（初见）读 如果直接使用read()，将一次性读取文本中所有内容； 如果使用read(n)，将会一次性读取n个字节，下一次读取将从此处继续 readline()方法可以一行一行地读取文件内容 readlines()方法依旧是一行一行读取，不过会一次性读取完，并将每一行存在列表当中作为一个元素 写 使用write()方法写入数据到文件 提示：当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入，只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了 小练习：复制文件让我们用以上知识，先实现一个简单的文件复制功能吧 123456789101112131415161718192021# 1、获取源文件名old_name = "/Users/sherlockgy/Desktop/1.txt"# 2、计算新文件名position = old_name.rfind(".")new_name = old_name[:position] + "[复件]" + old_name[position:]# 3、缓存读取的文件内容file_read = open(old_name, "r")file_content = file_read.read()# 4、写入新文件file_write = open(new_name, "w")file_write.write(file_content)# 5、关闭文件file_read.close()file_write.close()print("复制完成！") 大文件读取的处理如果我们需要读取的文件非常庞大，庞大到超过我们的内存大小，那么我们无论如何都不能使用以上的read()方法去读取文件内容 那么我们是否可以使用readline()方法去读取呢？我们这里是不建议的，原因如下：有些文件是经过压缩的，整个文件没有换行符和空白符，那么如果使用的是readline()依然会出现“挤爆内存”的情形 那么我们要怎么做呢？我们可以指定每一次读取的字节数 123456while True: content = old_file.read(1024) if len(content) == 0: break new_file.write(content) 文件的定位读写现有一个txt文件，内容如下： 12123456789abcdefg 现在我们执行以下程序，该程序使用了seek()方法 12345f = open("/Users/sherlockgy/Desktop/1.txt", "r")f.seek(2, 0)print(f.read(1))print(f.read(1))print(f.read(1)) 输出结果为： 123345 seek（offset [,from]）方法改变当前文件的位置。Offset变量表示要移动的字节数（偏移量）。From变量指定开始移动字节的参考位置。 如果from被设为0，这意味着将文件的开头作为移动字节的参考位置。如果设为1，则使用当前的位置作为参考位置。如果它被设为2，那么该文件的末尾将作为参考位置。 我们可以使用tell()方法查找当前文件指针的位置 1234f = open("/Users/sherlockgy/Desktop/1.txt", "rb")print("初始指针：" + str(f.tell()))f.seek(2, 0)print("偏移后指针：" + str(f.tell())) 12初始指针：0偏移后指针：2 补充：在文本文件中，没有使用b模式选项打开的文件，只允许从文件头开始计算相对位置，从文件尾计算时就会引发异常【can’t do nonzero end-relative seeks】 文件的常见操作1234567891011121314151617181920212223import os# 重命名os.rename("xxx.txt", "yyy.txt")# 删除文件os.remove("yyy.txt")# 新建文件夹os.mkdir("test")# 删除文件夹os.rmdir("test")# 获取当前文件操作路径os.getcwd()# 改变默认目录os.chdir("../")# 获取目录列表（重要）# 该方法获取的不包括文件路径，仅文件名os.listdir("./") 小练习：批量重命名12345678910111213141516171819202122232425262728import os# 输入需要重命名的文件所在路径source = "/Users/sherlockgy/Desktop/123"# 需要加上的前缀before = "[测试]"# 遍历每一个文件获得文件名def iter_file(file_source): """迭代文件列表""" # 得到目录下所有文件的名称 file_list = os.listdir(file_source) for file_name in file_list: # 判断是否是一个文件 if os.path.isfile(file_source + "/" + file_name): old_name = file_source + "/" + file_name new_name = file_source + "/" + before + file_name os.rename(old_name, new_name) else: new_source = file_source + "/" + file_name iter_file(new_source)iter_file(source)]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>IO</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala入门03——Scala函数]]></title>
    <url>%2F2018%2F08%2F19%2FScala%E5%85%A5%E9%97%A803%E2%80%94%E2%80%94Scala%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在上一章当中，我们定义函数的方法是适用于无参的函数的，接下来，我们一起来学习函数声明的完整方法 基本函数声明上一章的声明方法： 12345678scala&gt; val x = 1x: Int = 1scala&gt; val y = 2y: Int = 2scala&gt; def sum = x + ysum: Int 完整的函数声明方法： 1234scala&gt; def sum(x : Int, y : Int): Int = &#123; | x + y | &#125;sum: (x: Int, y: Int)Int 补充：右括号右边的: Int代表本函数的返回值类型，=代表这是一个有返回值的函数，如果: Int=省略，等于: Unit=，即返回() 我们可以让Scala自动推断返回值类型，即可以这样书写： 1234scala&gt; def sum(x : Int, y : Int) = &#123; | x + y | &#125;sum: (x: Int, y: Int)Int 补充：不过要记得，=一般不能省略，否则等于返回值为() if的使用我们也可以尝试实现一下if语句，这是最基本的程序流程控制语句 12345678scala&gt; def max(x : Int, y : Int): Int = &#123; | if (x &gt; y)&#123; | return x | &#125; else &#123; | return y | &#125; | &#125;max: (x: Int, y: Int)Int 以上程序无比的完整，但是他太繁琐了，我们可以尝试这样去书写它： 12scala&gt; def max(x : Int, y : Int) = if (x &gt; y) x else ymax: (x: Int, y: Int)Int 我们可以把如上函数看做Java语言当中的三元表达式或者称为三目运算 补充：必须要告诉大家的是，Scala会返回程序执行中函数最后一行的值，而无需使用return 函数的使用（1）函数的默认值函数的参数可以拥有自己的默认值，如果调用者没有传递相应的参数，则使用默认值 12345678def sayMyName(name : String = "Marry") = &#123; println(name)&#125;def main(args: Array[String]): Unit = &#123; sayMyName() sayMyName("Jack")&#125; 补充：Scala建议的缩进是两个空格 （2）可变长函数当不确定函数需要接受几个参数的时候，使用可变长函数 123456789def printElement(x : Int*) = &#123; for (element &lt;- x)&#123; println(element) &#125;&#125;def main(args: Array[String]): Unit = &#123; printElement(1, 2, 3)&#125; （3）调用函数的函数我们先有这样一个函数，用于计算两个数的和 12345def add(x : Int, y : Int) = x + ydef main(args: Array[String]): Unit = &#123; println(add(2, 3))&#125; 以上函数的执行结果显然是：5 如果我们能够确定其中一个函数的参数，那么我们的函数2可以这样书写 1234567def add(x : Int, y : Int) = x + ydef add2 = add(_ : Int, 2)def main(args: Array[String]): Unit = &#123; println(add2(8))&#125; 以上函数，_代表通配符，意为任意一个Int类型的参数，2代表固定的参数 add2()的书写方法为该方式的简写： 1def add2(x : Int) = add(x, 2) （4）函数递归例：计算5的阶乘 12345def fac (x : Int): Int = if (x == 1) 1 else fac(x - 1) * xdef main(args: Array[String]): Unit = &#123; println(fac(5))&#125; （5）柯里化函数柯里化函数是一种特殊的书写方式： 12345def mulitply(x : Int)(y : Int) = x * ydef main(args: Array[String]): Unit = &#123; println(mulitply(2)(3))&#125; 函数互相调用（柯里化函数中通配符的使用）： 123456def mulitply(x : Int)(y : Int) = x * ydef mulitply2 = mulitply(3)_def main(args: Array[String]): Unit = &#123; println(mulitply2(3))&#125; （6）匿名函数在Scala中声明一个匿名函数，方法如下 12345val t = () =&gt; 333def main(args: Array[String]): Unit = &#123; println(t())&#125; 将匿名函数作为参数 123456789val t = () =&gt; 333def testFunc(c : () =&gt; Int) = &#123; println(c())&#125;def main(args: Array[String]): Unit = &#123; testFunc(t)&#125; 补充：上述函数，若println()函数内传递的是c,而不是c()，将打印其内存地址；c()为调用该函数 () =&gt; Int为匿名函数的类型：即无参、返回类型为Int 举例： 123456789def testF1(callback: (Int, Int) =&gt; Int) = &#123; callback(123, 123)&#125;val addFunc = (x: Int, y: Int) =&gt; &#123;x + y&#125;def main(args: Array[String]): Unit = &#123; println(testF1(addFunc))&#125; （7）嵌套函数12345678910def funOut(x: Int, y:Int, z: Int) = &#123; def funInner(x: Int, y: Int) = &#123; x + y &#125; funInner(funInner(x, y), z)&#125;def main(args: Array[String]): Unit = &#123; println(funOut(1, 2, 3))&#125; 小测验：能否看懂123456789101112def sum(f: Int =&gt; Int): (Int, Int) =&gt; Int = &#123; def sumF(a: Int, b: Int): Int = &#123; if (a &gt; b) 0 else f(a) + sumF(a + 1, b) &#125; sumF&#125;def main(args: Array[String]): Unit = &#123; val f = (x: Int) =&gt; x val sumF = sum(f) println(sumF(1, 2))&#125; 分析： 本题意为： sum()函数，入参f，类型为匿名函数：入参Int；出参Int sum()函数，出参为匿名函数：入参Int，Int；出参Int sumF()函数为sum()函数的嵌套函数，入参a，b皆为Int；出参为Int sumF()函数体：如果a &gt; b，则返回0；否则返回f匿名函数（传入a）和递归调用sumF()函数（传入a + 1，b）的和 main方法测试： 给sum()函数传递一个符合要求的匿名函数即可得到一个sumF()函数 给sumF()函数传值 1 + sumF(2, 2) | |1 + 2 + sumF(3, 2) | |1 + 2 + 0]]></content>
      <categories>
        <category>程序人生</category>
        <category>Scala</category>
        <category>Scala入门</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala入门02——Scala数据类型]]></title>
    <url>%2F2018%2F08%2F19%2FScala%E5%85%A5%E9%97%A802%E2%80%94%E2%80%94Scala%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Scala数据类型Scala的数据类型基本与Java一致，并且没有基本数据类型，而是直接使用其包装类型，因此，Scala和Java内存类型布局一致，精度一致 在scala是可以对数字等基础类型调用方法的 因此，Scala和Java内存类型布局一致，精度一致 数据类型 描述 Byte 8bit（1字节）有符号数字，范围在-128 到 127 Short 16bit（2字节）有符号数字，范围在-32768 到 32767 Int 32bit（4字节）有符号数字，范围在-2147483648 到 2147483647 Long 64bit（8字节）有符号数字，范围在-9223372036854775808 到 9223372036854775807 Float 32bit（4字节），IEEE 754标准的单精度浮点数 Double 64bit（4字节），IEEE 754标准的双精度浮点数 Char 16bit Unicode字符，范围在U+0000 到 U+FFFF String 字符串 Boolean 布尔类型 Unit 表示无值，和Java中void等同。用作不返回任何结果的方法的结果类型。Unit只有一个实例值，写成() Null 空值或空引用，唯一实例是null，AnyRef的子类 Nothing Nothing类型在Scala的类层级的最低端；它是任何其他类型的子类型，表示没有值，没有实例 Option 表示可能存在（Some），可能不存在（None）的值 None Option的两个子类之一，用于安全的函数返回值，比Null安全 Some Option的两个子类之一，表示包装了值 Any 所有其他类的超类 AnyRef 所有引用类(reference class)的超类 AnyVal 所有值类型的超类 Nil 长度为0的List Scala字符串定义多行字符串在Scala中，单行字符串的定义方式和Java中完全相同，不过，Scala还拥有类似于Python的多行字符串定义方式，用三双引号表示即可 123456789scala&gt; val str = """ | hello | world | """str: String = "helloworld" s字符串12345scala&gt; val name = "Tom"name: String = Tomscala&gt; println(s"my name is $name")my name is Tom 12345678scala&gt; val name = "Tom"name: String = Tomscala&gt; val age = 10age: Int = 10scala&gt; println(s"两年后，$&#123;name&#125;就$&#123;age + 2&#125;岁啦")两年后，Tom就12岁啦 raw字符串raw字符串可以使\n这些转义字符被作为普通字符串 12scala&gt; println(raw"\nhello")\nhello 定义变量定义变量分val和var两种关键字：val关键字声明的是常量，一旦声明不能修改；var关键字声明的是变量 在Scala当中，鼓励尽量使用val 12val name : String = "Tom"val age = 20 // 类型推断 定义函数（初探）在Scala当中定义函数使用def关键字，定义函数并不会直接计算出其结果，而需要等待调用的那一刻 12345678scala&gt; val v1 = 1v1: Int = 1scala&gt; val v2 = 3v2: Int = 3scala&gt; def v3 = v1 + v2v3: Int 定义函数也可以使用如下写法 12scala&gt; def v4() = v1 + v2v4: ()Int 区别： 在Scala当中，如果函数没有参数，则可以不用书写()，在调用时，也是直接书写函数名即可 调用函数（初探）12scala&gt; v3res13: Int = 4 或 12scala&gt; v4()res15: Int = 4]]></content>
      <categories>
        <category>程序人生</category>
        <category>Scala</category>
        <category>Scala入门</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala入门01——安装Scala（Mac）]]></title>
    <url>%2F2018%2F08%2F09%2FScala%E5%85%A5%E9%97%A801%E2%80%94%E2%80%94%E5%AE%89%E8%A3%85Scala%EF%BC%88Mac%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本篇介绍如何在MacOS上安装Scala Scala是运行在JVM上的函数式编程语言，所以要在Mac上安装Scala，先要保证安装了JDK 安装JDK安装JDK只需要登录Oracle官网下载即可，不赘述 然后在命令行分别执行以下命令，测试Java是否已经安装完成： 1java -version 1javac -version 使用brew安装Scala然后使用brew安装Scala： 1brew install scala 如何安装brew当然，也许你还没安装brew，brew是Mac上安装软件的神器，安装brew也是很简单的 这里给出几个安装brew的命令： 1ruby &lt;(curl -fsSkL raw.github.com/mxcl/homebrew/go) 1curl -LsSf http://github.com/mxcl/homebrew/tarball/master | sudo tar xvz -C/usr/local --strip 1 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 不管使用以上哪一种，只要能安装brew就行 下面执行命令更新一下brew即可： 1brew update 其他方式安装Scala当然直接在搜索引擎搜索Scala，进入其官网下载二进制文件也是可以的，这样的方法同样适用于Windows平台，只不过需要手动配置环境变量 官网下载地址：https://www.scala-lang.org/download/ 解压缩文件包，可将其移动至/usr/local/share下 修改环境变量，修改配置文件profile: 1sudo vim /etc/profile 在文件的末尾加入: 1export PATH="$PATH:/usr/local/share/scala/bin" :wq!保存退出，重启终端，执行 scala 命令 123$ scalaWelcome to Scala 2.12.6 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_141).Type in expressions for evaluation. Or try :help. 使用:quit命令退出Scala命令行 安装sbt启动Scalasbt是Scala的构建工具，我们使用brew安装它： 1brew install sbt 在命令行使用sbt打开Scala交互： 1sbt console 使用:quit命令退出Scala命令行]]></content>
      <categories>
        <category>程序人生</category>
        <category>Scala</category>
        <category>Scala入门</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——工厂模式]]></title>
    <url>%2F2018%2F08%2F08%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式概念实例化对象，用工厂方法来代替new操作 工厂模式包括简单工厂模式、工厂方法模式、抽象工厂模式 抽象工厂模式是工厂方法模式的拓展 工厂模式的意图实现了创建者和调用者的分离 定义一个接口来创建对象，让子类决定哪些对象需要被实例化 工厂方法模式把实例化的工作推迟到子类去实现 什么情况需要工厂模式 有一组类似的对象需要被创建 在编码时不能预见需要创建哪种类的实例 系统需要考虑拓展性 工厂模式详细分类 简单工厂模式 工厂方法模式 抽象工厂模式 遵循的面向对象设计原则（了解） 开闭原则：对拓展开发，对修改关闭。在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码 依赖倒转原则：针对接口而不是针对实现编程。该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代 迪米特法则：米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。只与朋友通信，避免和陌生人通信 没有工厂的情况接口：车 123public interface Car &#123; void run();&#125; 实现类：宝马 123456public class BmwCar implements Car &#123; @Override public void run() &#123; System.out.println("宝马发动了"); &#125;&#125; 实现类：比亚迪 123456public class BydCar implements Car &#123; @Override public void run() &#123; System.out.println("比亚迪发动了"); &#125;&#125; 测试类： 123456public class Test &#123; public static void main(String[] args) &#123; Car car1 = new BmwCar(); Car car2 = new BydCar(); &#125;&#125; 分析： 在没有工厂模式的情况下，调用者需要知道实现的接口，还需要知道其每一个实现类的实现方式 若上文演示的实现类都需要设置复杂的参数，那么对于调用者来说是违反迪米特法则的 （一）简单工厂模式我们在其他类都保持原样的情况下，添加这样一个工厂如下： 简单工厂： 12345678910public class SimpleFactory &#123; public static Car getCar(String carName)&#123; if ("比亚迪".equals(carName))&#123; return new BydCar(); &#125;else if ("宝马".equals(carName))&#123; return new BmwCar(); &#125; return null; &#125;&#125; 测试类： 1234567891011public class Test &#123; public static void main(String[] args) &#123; Car car1 = SimpleFactory.getCar("比亚迪"); Car car2 = SimpleFactory.getCar("宝马"); if (car1 != null &amp;&amp; car2 != null)&#123; car1.run(); car2.run(); &#125; &#125;&#125; 分析： 在简单工厂方法当中，我们调用者已经不需要知道实现类被创造的细节，但是依然存在一个问题： 简单工厂是依赖if、else判断来决定创造哪一个实现类的对象的，那么如果我们需要增加新的实现类、删除原有实现类，都要频繁修改工厂类 这违反了上述的开闭原则，不过在业务不需要频繁变更的项目当中，已经可以使用了 （二）工厂方法模式 为了避免简单工厂模式不遵守开闭原则的缺点 工厂方法模式和简单工厂模式的不同点在于：简单工厂模式往往只有一个工厂类，而工厂方法模式有一组实现了相同接口的工厂类 在不改变没有使用工厂模式情况下的代码的前提下，我们创建这样的工厂方法： 首先，创建一个工厂的接口，用于规范一系列工厂的行为 工厂的接口： 123public interface Factory &#123; Car getCar();&#125; 其次，我们创建各个种类对象的分工厂，这些分工厂统一实现工厂接口 分工厂： 123456public class FactoryBmw implements Factory &#123; @Override public Car getCar() &#123; return new BmwCar(); &#125;&#125; 123456public class FactoryByd implements Factory &#123; @Override public Car getCar() &#123; return new BydCar(); &#125;&#125; 这些分工厂一样可以隐藏实现这些对象的细节，遵循迪米特法则 测试类： 1234567891011public class Test &#123; public static void main(String[] args) &#123; Car car1 = new FactoryBmw().getCar(); Car car2 = new FactoryByd().getCar(); if (car1 != null &amp;&amp; car2 != null)&#123; car1.run(); car2.run(); &#125; &#125;&#125; 分析： 使用工厂方法模式，如果需要添加新的实现类，只需要创建新的分工厂实现工厂接口即可；如果需要删除实现类，只需要删除对应的分工厂即可 这样的设计完美实现了开闭原则的要求 （三）抽象工厂模式 用于生产不同产品族的全部产品（对于增加单个产品无能为力，支持增加一个产品族） 抽象工厂模式和工厂方法模式处理的是不同的场景。在存在多个业务分类时，可以使用此模式创造一整个族的产品 由于抽象工厂模式的复杂性，我们这里使用全新的案例分析： 产品族： 汽车产品族1：低端轮胎、低端座椅、低端发动机 汽车产品族2：高端轮胎、高端座椅、高端发动机 抽象工厂模式就是用于直接生成一个产品族内全部对象的工厂模式 发动机模块： 12345678910111213141516171819202122232425262728293031323334353637/** * 发动机接口 */public interface Engine() &#123; void run(); void start();&#125;/** * 豪华发动机 */class LuxuryEngine() implements Engine &#123; @Override public void run() &#123; System.out.println("极速快"); &#125; @Override public void start() &#123; System.out.println("提速快"); &#125;&#125;/** * 低端发动机 */class LowEngine() implements Engine &#123; @Override public void run() &#123; System.out.println("极速慢"); &#125; @Override public void start() &#123; System.out.println("提速慢"); &#125;&#125; 座椅模块： 1234567891011121314151617181920212223242526/** * 座椅接口 */public interface Seat() &#123; void massage();&#125;/** * 豪华座椅 */class LuxurySeat() implements Seat &#123; @Override public void massage() &#123; System.out.println("按摩舒服"); &#125;&#125;/** * 低端座椅 */class LowSeat() implements Seat &#123; @Override public void massage() &#123; System.out.println("按摩不舒服"); &#125;&#125; 轮胎模块： 1234567891011121314151617181920212223242526/** * 轮胎接口 */public interface Tyre() &#123; void revolve();&#125;/** * 豪华轮胎 */class LuxuryTyre() implements Tyre &#123; @Override public void revolve() &#123; System.out.println("旋转磨损低"); &#125;&#125;/** * 低端轮胎 */class LowTyre() implements Tyre &#123; @Override public void revolve() &#123; System.out.println("旋转磨损高"); &#125;&#125; 下面就要创建整合我们的产品族中每一个模块的整合对象：Car了，汽车工厂接口负责定义每一个汽车分工厂的规范 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 汽车工厂接口 */public interface CarFactory &#123; void createEngine(); void createSeat(); void createTyre();&#125;/** * 高端汽车工厂 */class LuxuryCarFactory implements CarFactory &#123; @Override public void createEngine() &#123; return new LuxuryEngine(); &#125; @Override public void createSeat() &#123; return new LuxurySeat(); &#125; @Override public void createTyre() &#123; return new LuxuryTyre(); &#125;&#125;/** * 低端汽车工厂 */class LowCarFactory implements CarFactory &#123; @Override public void createEngine() &#123; return new LowEngine(); &#125; @Override public void createSeat() &#123; return new LowSeat(); &#125; @Override public void createTyre() &#123; return new LowTyre(); &#125;&#125; 测试类： 123456789101112public class Test &#123; public static void main(String[] args) &#123; // 我们需要一辆高档车 CarFactory factory = new LuxuryCarFactory(); Engine engine = factory.createEngine(); Seat seat = factory.createSeat(); Tyre tyre = factory.createTyre(); engine.run(); // 极速快 seat.massage(); // 按摩舒服 tyre.revolve(); // 旋转磨损低 &#125;&#125; 分析： 按照上文演示的测试类，即可创造出一个高端汽车产品族所需的所有模块。如果我们需要一辆中档的汽车（混合高端引擎和低端座椅），那么我们仅需要创建一个中档汽车工厂，并实现汽车工厂接口，在其对应方法中创造出对应产品，即可创造一条新的产品族 在实际应用当中，如果我们的业务不需要创建一个庞大的产品族，抽象工厂模式很少用到 总结工厂模式的应用场景： JDK中Calendar的getInstance()方法 JDBC中Connection对象的获取 Hibernate当中，使用SQLSessionFactory创建SQLSession Spring中，IOC容器创建管理Bean对象 XML文件解析时，DocumentBuilderFactory创建解析器对象 反射中Class对象的newInstance()方法]]></content>
      <categories>
        <category>程序人生</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python知识学习18——匿名函数的使用]]></title>
    <url>%2F2018%2F08%2F08%2FPython%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A018%E2%80%94%E2%80%94%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[我们先来复习一下列表的一些常用方法： 列表排序（数字元素）默认：从小到大 1234&gt;&gt;&gt; arr = [33, 43, 12, 18, 9, 40]&gt;&gt;&gt; arr.sort()&gt;&gt;&gt; print(arr)[9, 12, 18, 33, 40, 43] 从大到小 1234&gt;&gt;&gt; arr = [33, 43, 12, 18, 9, 40]&gt;&gt;&gt; arr.sort(reverse = True)&gt;&gt;&gt; print(arr)[43, 40, 33, 18, 12, 9] 列表倒序（数字元素）1234&gt;&gt;&gt; arr = [33, 43, 12, 18, 9, 40]&gt;&gt;&gt; arr.reverse()&gt;&gt;&gt; print(arr)[40, 9, 18, 12, 43, 33] 那么如果列表元素是不能直接自然排序的字典元素，要怎么办呢？ 列表排序（字典元素）1234&gt;&gt;&gt; infors = [&#123;"name" : "LaoWang", "age" : 12&#125;, &#123;"name" : "BanZhang", "age" : 10&#125;, &#123;"name" : "ChuShi", "age" : 13&#125;]&gt;&gt;&gt; infors.sort(key = lambda x:x["name"])&gt;&gt;&gt; print(infors)[&#123;'name': 'BanZhang', 'age': 10&#125;, &#123;'name': 'ChuShi', 'age': 13&#125;, &#123;'name': 'LaoWang', 'age': 12&#125;] 将匿名函数作为实参1234&gt;&gt;&gt; def test(a, b, func):··· return func(a, b)&gt;&gt;&gt; print(test(1, 2, lambda a, b : a + b))3 字符串作为lambda函数123456&gt;&gt;&gt; def test(a, b, func):··· return func(a, b)&gt;&gt;&gt; func = "lambda a, b : a * b"&gt;&gt;&gt; func = eval(func)&gt;&gt;&gt; print(test(1, 2, func))2 以上函数，如果没有eval()函数，在Python2当中可以运行，但是在Python3当中，会报出如下错误： TypeError: ‘str’ object is not callable 原因是，Python3不允许直接把字符串作为函数表达式运行。 eval()函数：eval(expression, globals=None, locals=None) — 官方文档中的解释是，将字符串str当成有效的表达式来求值并返回计算结果。 globals和locals参数是可选的，如果提供了globals参数，那么它必须是dictionary类型；如果提供了locals参数，那么它可以是任意的map对象。 eval()使用原因1）在编译语言里要动态地产生代码，基本上是不可能的，但动态语言是可以。 意味着软件已经部署到服务器上了，但只要作很少的更改，只好直接修改这部分的代码，就可立即实现变化，不用整个软件重新加载。 2）在machin learning里根据用户使用这个软件频率，以及方式，可动态地修改代码，适应用户的变化。]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记——MySQL必知必会]]></title>
    <url>%2F2018%2F08%2F07%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[MySQL基础命令 MySQL登录：mysql -u -p -h myserver -P 9999 获取帮助：mysql –help（help select） 退出程序：quit、exit 选择数据库：use 数据库名称 查看可用数据库：show databases 查看表：show tables 查看表的字段：show columns from 表名（快捷：describe 表名） 显示广泛的服务器状态信息：show status 显示创建数据库和表的语句：show create database、show create table 显示授予用户的安全权限：show grants 显示服务器错误或警告信息：show errors、show warnings 检索数据 简单搜索：select 字段名 from 表名 检索多个列：select 字段1，字段2，… from 表名 检索所有列：select * from 表名 检索并去除重复：select distinct 字段名 from 表名 分页查找（5行）：select 字段名 from 表名 limit 5（总是第一行开始） 分页查找（下一个5行）：select 字段名 from 表名 limit 5，5（开始行，行数） 排序数据 排序：select * from 表名 order by 字段名（可用不在检索内的列） 多个列排序：select * from 表名 order by 字段1，字段2 降序排序：select * from 表名 order by 字段 desc（只针对该desc前的一个列有效） 找出最昂贵物品的值：select price from products order by price desc limit 1 字段顺序：order by 在from，where，group by，having后，limit在order by后 过滤数据 基础搜索：select * from 表名 where 字段 = 条件 操作符：&lt;&gt;、!=(不等于)、between a and b（指定两个值之间，包头包尾） 空值检查：select * from 表名 where 列名 is null 数据过滤 and操作符：select * from 表名 where 条件一 and 条件2 or操作符：select * from 表名 where 条件一 or 条件2 and 和 or 的优先级：and更高 in操作符：select * from 表名 where 字段名 in（1002，1003）order by 字段 in和or相比的优势： 多个数值时，in比or直观 因为使用的操作符少，执行次序更容易管理 in执行速度更快 in可以包含其他where语句 not操作符：select * from 表名 where 字段名 not in（1002，1003）order by 字段 not补充：MySQL的not支持：in、between和exists子句取反，不同于其他DBMS支持各种条件 用通配符进行过滤 %通配符：select * from 表名 where name like ‘jet%’（%代表：任意字符、任意次数） %通配符不能匹配null _通配符：select * from 表名 where name like ‘_jet’（_代表：一个字符） 注意事项： 尽量少使用通配符 尽量少放在搜索模式的开始处，因为这样效率最低 用正则表达式进行搜索 简单正则表达式：select * from 表名 where name REGEXP ‘1000’ order by name 匹配一个字符：select * from 表名 where name REGEXP ‘.000’ order by name like与正则表达式区别：like没有通配符与列值相同并不会返回，正则表达式则会 正则表达式不区分大小写，除非：select * from 表名 where name REGEXP BINARY ‘.000’ or匹配：select * from 表名 where name REGEXP ‘1000|2000|3000’ 匹配几个字符之一：select * from 表名 where name REGEXP ‘[123]Tom’ 否定字符集合：select * from 表名 where name REGEXP ‘[^123]Tom’ 简化字符集合：select * from 表名 where name REGEXP ‘[1-5]Tom’ 匹配特殊字符（转义）：select * from 表名 where name REGEXP ‘\.’ \ \引用元字符： \ \f：换页 \ \n：换行 \ \r：回车 \ \t：制表 \ \v：纵向制表 匹配字符类： [:alnum:] 任意字母数字（同[a-zA-Z0-9]） [:alpha:] 任意字符（同[a-zA-Z]） [:blank:] 空格和制表（同\ \t） [:cntrl:] ASCII控制字符（ASCII 0到31和127） [:digit:] 任意数字（同[0-9]） [:graph:] 与[:print:]相同，不包括空格 [:lower:] 任意小写字母（同[a-z]） [:print:] 任意可打印字符 [:punct:] 既不在[:alnum:]又不在[:cntrl:]内的字符 [:space:] 包括空格在内的任意空白字符（同\ \f\ \t\ \r\ \n\ \v） [:upper:] 任意大写字母（同[A-Z]） [:xdigit:] 任意十六进制数字（同a-fA-F0-9） 重复元字符： &#42; ：0个或多个匹配 ：一个或多个匹配，等同于{1，} ？：0个或一个匹配，等同于{0，1} {n} ：指定数目匹配 {n，} ：不少于指定数目匹配 {n，m} ：匹配数目范围（m不超过255） 定位符： ^ ：文本开始 $ ：文本结束 [[:&lt;:]] ：词的开始 [[:&gt;:]] ：词的结束 ^ 的双重作用：（1）集合中，否定集合；（2）表示文本开始 创建计算字段（field） 字段拼接：select Concat(name,’(‘,country,’)’) from vendors order by name 去除空格：select Concat(Trim(name),’(‘,Trim(country),’)’) from vendors 去除空格：（1）右空格：RTrim()（2）左空格：LTrim()（3）左右空格：Trim() 使用别名：select Concat(name,’(‘,country,’)’) AS title from vendors 省略from子句：select Trim(‘ABC’) 使用数据处理函数文本处理函数 文本大写：select name,Upper(name) as name_upcase from vendors 常用的文本处理函数： Left() ： 返回串左边的字符 Length() ： 返回串的长度 Locate() ： 找出串的一个子串 Lower() ： 将串转换为小写 LTrim() ： 去除左空格 Right() ： 返回串右边字符 RTrim() ： 去除右空格 Soundex() ： 返回串的Soundex值（模拟发音） SubString() ： 返回子串的字符 Upper() : 将串转换为大写 日期函数 日期函数：select * from 表名 where Date(order_date) = ‘2015-1-10’（仅返回日期，过滤时间） 日期函数：select * from 表名 where Year(order&#95;date) = 2015 and Month(order_date) = 9 返回星期几：DayOfWeek() 返回当前日期：CurDate() 返回当前时间：CurTime() 计算日期差：DateDiff() 数值处理函数 绝对值 ：Abs() 余弦函数 ：Cos() 指数函数 ：Exp() 返回余数 ：Mod() 圆周率 ：Pi() 返回随机数 ：Rand() 正弦函数 ：Sin() 平方根 ：Sqrt() 正切 ：Tan() 汇总数据聚集函数 函数 说明 补充 AVG() 返回某列的平均值 忽略null值的行 COUNT() 返回某列的行数 COUNT(*)：不忽略nullCOUNT(列名)：忽略null MAX() 返回某列最大值 忽略null值的行 MIN() 返回某列最小值 忽略null值的行 SUM() 返回某列值之和 忽略null值的行 聚集不同值：select AVG(DISTINCT price) AS avg_price from products where id=1003 聚集不同值说明：MySQL 5及后期版本可用 分组数据 分组数据：select vend&#95;id，COUNT(*) AS num_prods from 表名 GROUP BY vend&#95;id 分组数据补充：聚集函数对每个分组聚集而不是整个结果集 GROUP BY子句规定： 可以包含任意数目列（分组可以嵌套） 如果嵌套，数据将在最后的分组上汇总（不能从个别列取回数据) 该子句中所有列必须是检索列或有效表达式（不能是聚集函数），如果select子句中使用表达式，该子句需要使用相同表达式，不能使用别名 除聚集计算语句外，select语句每个列必须在GROUP BY子句中给出 若分组列具有null，null将作为一个分组返回；若列有多行null，将他们分为一组 GROUP BY必须在where后，order by前 获得汇总级别值：select id,COUNT(*) AS num_prods from 表名 group by id WITH ROLLUP 过滤分组HAVING子句： 可以和WHERE子句一样使用 区别： where过滤行，having过滤分组 where在分组前过滤，having在分组后过滤 过滤组内超过两项数据的行：select id,COUNT(&#42;) from 表名 group by id having COUNT(*) &gt; 2 分组和排序 ORDER BY GROUP BY 排序产生的输出任意列都可以使用（甚至非选择的列）不一定需要 分组行，但输出可能不是分组的顺序只能使用选择列或表达式列，而且必须使用每个列表达式如果与聚集函数一起使用列，则必须使用 使用子查询12345-- 子查询从内向外处理select id from orders where order_num in (select order_num from orderitems where prod_id = 'TNT2') 联结表12345-- 创建联结，无连接条件（笛卡尔积）select vend_name,prod_name,prod_pricefrom vendors,productswhere vendors.vend_id = products.vend_idORDER BY vend_name,prod_name 内联接12345-- 内联接select vend_name,prod_name,prod_pricefrom vendors INNER JOIN productswhere vendors.vend_id = products.vend_idORDER BY vend_name,prod_name 创建高级联接使用表别名12345select cust_name,cust_contactfrom customers AS c,orders AS o,orderitems AS oiwhere c.cust_id = o.cust_id and oi.order_num = o.order_num and prod_id = 'TNT2' 表别名只在查询中使用。与列别名不同，表别名不会返回客户机 使用不同类型的联接自联接 1234select p1.prod_id,p1_prod_name from products AS p1,products AS p2where p1.vend_id = p2.vend_id and p2.prod_id = 'DTNTR']]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式小练习01]]></title>
    <url>%2F2018%2F08%2F06%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B0%8F%E7%BB%83%E4%B9%A001%2F</url>
    <content type="text"><![CDATA[练习： 正则表达式优化字符串 解释： String类下匹配正则表达式替换的方法为replaceAll() 第一步，去除点。点本身是正则的通配符，所以需要转义。 第二步，去除叠词。点匹配任意词，以小括号包围编组，将1转义过后，\\1 代表引用第一组匹配内容，即是叠词匹配。+ 代表第一组内容出现一次或多次。 不同字符串中，引用组采用 $1 12345678910111213141516public class Exercise01 &#123; public static void main(String[] args) &#123; String str = "我...我...我要...要学...学...学...学编程...程!"; System.out.println(method(str)); &#125; private static String method(String str)&#123; str = str.replaceAll("\\.+", ""); return str.replaceAll("(.)\\1+","$1"); &#125;&#125; 拓展： 多个组互相包含时，数左括号数即可判断一共多少组 以左括号出现顺序，所包含的部分即为该顺序组 组从1开始计，0组代表整个表达式 练习： IP地址排序 12345192.68.1.254102.49.23.1310.10.10.102.2.2.28.109.90.30 12345678910111213141516171819public class Exercise02 &#123; public static void main(String[] args) &#123; String str = "102.49.23.13 192.68.1.254 10.10.10.10 2.2.2.2 8.109.90.30"; String s = str.replaceAll("(\\d+)", "00$1"); s= s.replaceAll("0*(\\d&#123;3&#125;)", "$1"); String[] strings = s.split(" +"); Set&lt;String&gt; set = new TreeSet&lt;&gt;(); set.addAll(Arrays.asList(strings)); for (String s1 : set) &#123; s1 = s1.replaceAll("0*(\\d+)", "$1"); System.out.println(s1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法基础——冒泡排序和选择排序]]></title>
    <url>%2F2018%2F08%2F06%2F%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%92%8C%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序原理分析： 索引0和1比；1和2比；2和3比… 两两比较，较大者和较小者交换位置，最后一个数不需要主动比较 因此第一轮后，最大数就在最大索引处 第二轮开始，比较次数因此减1次 因此，总比较轮数为数组长度减1轮 代码如下： 12345678910111213141516171819202122232425262728293031public class BubbleSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;24, 69, 80, 57, 13&#125;; System.out.println("排序前：\n" + Arrays.toString(arr)); bubbleSort(arr); System.out.println("排序后：\n" + Arrays.toString(arr)); &#125; private static void bubbleSort(int[] arr) &#123; // 控制比较轮数 for (int i = 0; i &lt; arr.length - 1; i++) &#123; // 控制比较次数 // -1是因为最后一个索引不需要主动比较 // -i是因为每轮比较的最大索引即是最大值，因此，每过1轮即可少比较一次 for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; // 比较大小，大值向后交换 if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; &#125;&#125; 选择排序选择排序 原理分析： 索引：0和1比，0和2比，0和3比… 值小的往前交换，一轮结束，最小索引处即是最小值 内循环的索引对应被比较的对象，内循环启始索引永远比外循环索引大1位 每一轮都需要比较直到最大索引处，但是启始索引每一轮都会加1位 外循环控制比较轮次，也是当前比较者的索引；类似于冒泡排序，轮次等于数组长度减1次 代码如下： 123456789101112131415161718192021222324public class SelectSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;24, 69, 80, 57, 13&#125;; System.out.println("排序前：\n" + Arrays.toString(arr)); selectSort(arr); System.out.println("排序后：\n" + Arrays.toString(arr)); &#125; private static void selectSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = i + 1; j &lt; arr.length; j++) &#123; // 比较大小，大值向后交换 if (arr[i] &gt; arr[j]) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——单例模式]]></title>
    <url>%2F2018%2F08%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例设计模式 饿汉式（高效，无懒加载，线程安全） 类一加载就创建对象 由于类加载器是绝对线程安全的，所以不会出现多个实例的问题 懒汉式（低效，懒加载，同步锁） 需要对象的时候再实例化，存在线程安全问题，需要同步锁 双重检查锁式（高效，懒加载，不可靠） 由于jvm内存模型问题，会导致执行顺序颠倒的可能，不可靠 静态内部类式（高效，懒加载，推荐） 类（包括内部类）不会在外部类初始化时初始化，而是需要的时候初始化，保证懒加载 private static final保证了利用类加载器初始化实例，绝对线程安全 内部类静态原因：非静态内部类，不能拥有静态属性（容易导致内部类不受外部类限制，直接使用类名得到实例） 枚举式（高效，无懒加载，绝对安全，推荐） 由jvm底层保证其绝对安全，不被反射和反序列化破解 枚举类天生单例 防止被反射和反序列化破解： 防止被反射 123456private Demo1()&#123; // 进一步不允许构造器被使用，防止反射 if (demo1 != null)&#123; throw new RuntimeException(); &#125;&#125; 防止反序列化获取多个对象的漏洞 123private Object readResolve() throws ObjectStreamException &#123; return demo1;&#125; 下面开始举例： 饿汉式12345678910111213141516171819202122public class Demo1 &#123; // 构造器私有化 private Demo1()&#123; // 进一步不允许构造器被使用，防止反射 if (demo1 != null)&#123; throw new RuntimeException(); &#125; &#125; // 直接创建对象 private static Demo1 demo1 = new Demo1(); public static Demo1 getInstance()&#123; return demo1; &#125; // 防止反序列化获取多个对象的漏洞 private Object readResolve() throws ObjectStreamException &#123; return demo1; &#125;&#125; 懒汉式1234567891011121314151617181920212223242526public class Demo2 &#123; // 私有构造器 private Demo2()&#123; // 防止反射破解，进一步阻止对象被创建 if (demo2 != null)&#123; throw new RuntimeException(); &#125; &#125; // 懒加载的实例 private static Demo2 demo2 = null; // 获得实例 public static Demo2 getInstance()&#123; if (demo2 == null)&#123; demo2 = new Demo2(); &#125; return demo2; &#125; // 防止反序列化获取多个对象的漏洞 private Object readResolve() throws ObjectStreamException &#123; return demo2; &#125;&#125; 双重检查锁因为不推荐使用，暂不实现 静态内部类式12345678910111213141516171819202122public class Demo4 &#123; private static class Demo4Inner&#123; private static final Demo4 demo4 = new Demo4(); &#125; public static Demo4 getInstance()&#123; return Demo4Inner.demo4; &#125; private Demo4()&#123; // 防止反射破解 if (Demo4Inner.demo4 != null)&#123; throw new RuntimeException(); &#125; &#125; // 防止反序列化获取多个对象的漏洞 private Object readResolve() throws ObjectStreamException &#123; return Demo4Inner.demo4; &#125;&#125; 枚举式12345678public enum Demo5 &#123; INSTANCE; public void method() &#123; // do something. &#125;&#125; 使用反射破解单例模式123456789101112131415161718192021222324252627282930313233public class TestReflect &#123; public static void main(String[] args) &#123; // Class&lt;Demo1&gt; clazz = Demo1.class; // 破解Demo1 /*try &#123; Constructor&lt;Demo1&gt; constructor = clazz.getDeclaredConstructor(null); constructor.setAccessible(true); Demo1 instance1 = constructor.newInstance(null); Demo1 instance2 = constructor.newInstance(null); System.out.println(instance1); System.out.println(instance2); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;*/ // 破解Demo4 Class&lt;Demo4&gt; clazz = Demo4.class; try &#123; Constructor&lt;Demo4&gt; constructor = clazz.getDeclaredConstructor(null); constructor.setAccessible(true); Demo4 instance1 = constructor.newInstance(null); Demo4 instance2 = constructor.newInstance(null); System.out.println(instance1); System.out.println(instance2); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架入门]]></title>
    <url>%2F2018%2F08%2F05%2FSpring%2F</url>
    <content type="text"><![CDATA[一、Spring简要什么是Spring？Spring是一个非倾入容器，用于降低代码间的耦合度。根据不同的代码，使用IoC和AOP两种技术进行解耦。 主业务逻辑：逻辑联系紧密，复用性低 系统级服务：功能独立，主要是为业务提供系统级服务（日志、安全、事务），复用性强 IoC：使主业务不再自己维护关系，由Spring统一管理，“注入” AOP：使系统级服务最大限度复用，不需要混杂进主业务，而是由Spring统一“织入” 非倾入：Spring的API不会侵入业务逻辑，不会破坏pojo（Plain Old Java Object） ApplicationContext与BeanFactory容器的区别 123451) ApplicationContext容器在进行初始化时，会将其中所有Bean对象创建（占用系统资源，响应速度快）2）BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在获取该对象时才会被创建（响应速度慢，不多占用系统资源） 最全约束123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 开启组件扫描器 --&gt; &lt;context:component-scan base-package="beans"&gt;&lt;/beans&gt; IoC是什么？控制反转思想，DI（依赖注入）是主流的实现方式 其他实现方式：依赖查找 二、Bean简述（一）动态工厂Bean12&lt;bean id="factory" class="ServiceFactory"&gt;&lt;bean id="myService" factory-bean="factory" factory-method="getService"&gt; （二）静态工厂Bean（推荐）1234&lt;!-- 需要工厂方法为静态方法 --&gt;&lt;!-- 静态工厂，工厂对象无需创建，直接引用工厂类 --&gt;&lt;bean id="testService" class="factory.ServiceFactory" factory-method="getTestService"/&gt; （三）Bean的创建模式1234&lt;!-- 单例（默认） --&gt;&lt;bean id="student" class="Student" scope="singleton"&gt;&lt;!-- 原型（对象创建时机：不随容器创建） --&gt;&lt;bean id="student" class="Student" scope="prototype"&gt; 三、Bean生命周期的始末12&lt;bean id="myService" class="ServiceImpl" init-method="起始方法名" destory-method="结束方法名"&gt; 要执行结束方法，需关闭容器。 12// 关闭容器条件 1. Bean对象是单例的 2. 手动关闭容器((ClassPathXmlApplicationContext)applicationContext).close(); 生命周期顺序： 无参构造器 执行setter（需注入） 获取到Bean的id（需实现BeanNameAware） 获取到BeanFactory容器（需实现BeanFactoryAware） 执行postProcessBeforeInitialization()（需注册Bean后处理器BeanPostProcessor接口实现类） Bean初始化完毕（需实现InitializingBean） 初始化完毕之后（起始方法init-method执行） 执行postProcessAfterInitialization()方法 doSome… 销毁之前（需实现接口DisposableBean） 销毁之前（执行destory-method=”结束方法名”） 四、Spring配置文件标签id和name区别id：必须满足XML的命名规范： 必须字母开头，可以包含数字、字母、下划线、连字符、句号、冒号 name：可以包含任何字符 基于XML的DI（一）设值注入12345&lt;!-- 需要提供setter方法 --&gt;&lt;bean id="student" class="Student"&gt; &lt;property name="name" value="张三"/&gt; &lt;property name="school" ref="mySchool"/&gt;&lt;/bean&gt; （二）构造注入方法一 12345&lt;!-- 需带参构造器 --&gt;&lt;bean id="student" class="Student"&gt; &lt;constructor-arg index="0" value="李四"&gt; &lt;constructor-arg index="1" ref="mySchool"&gt;&lt;/bean&gt; 方法二 12345&lt;!-- 需带参构造器 --&gt;&lt;bean id="student" class="Student"&gt; &lt;constructor-arg value="李四"&gt; &lt;constructor-arg ref="mySchool"&gt;&lt;/bean&gt; 方法三 12345&lt;!-- 需带参构造器 --&gt;&lt;bean id="student" class="Student"&gt; &lt;constructor-arg name="name" value="李四"&gt; &lt;constructor-arg name="school" ref="mySchool"&gt;&lt;/bean&gt; （三）实现接口注入（四）命名空间注入 P命名空间设值注入 12&lt;!-- 需要setter方法 --&gt;&lt;bean id="student" class="Student" p:name="王五" p:school-ref:mySchool/&gt; C命名空间构造注入 12&lt;!-- 需要带参构造方法 --&gt;&lt;bean id="student" class="Student" c:name="王五" c:school-ref:mySchool/&gt; （五）集合属性注入1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;bean id="mySome" class="Some"&gt; &lt;!-- 数组：引用类型 --&gt; &lt;property name="schools"&gt; &lt;array&gt; &lt;ref bean="mySchool"&gt; &lt;ref bean="mySchool2"&gt; &lt;/array&gt; &lt;/property&gt; &lt;!-- 字符串数组 --&gt; &lt;property name="myStrs"&gt; &lt;array&gt; &lt;value&gt;北京&lt;/value&gt; &lt;value&gt;上海&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!-- list：字符串 --&gt; &lt;property name="myList"&gt; &lt;list&gt; &lt;value&gt;广州&lt;/value&gt; &lt;value&gt;云南&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- set：字符串 --&gt; &lt;property name="mySet"&gt; &lt;set&gt; &lt;value&gt;苏州&lt;/value&gt; &lt;value&gt;常州&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- map：字符串 Object --&gt; &lt;property name="myMap"&gt; &lt;map&gt; &lt;entry key="password" value="123456"&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- Properyies对象 --&gt; &lt;property name="myPros"&gt; &lt;props&gt; &lt;prop key="education"&gt;大学&lt;/prop&gt; &lt;prop key="gender"&gt;男&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 简单写法 123&lt;property name="myStrs" value="北京，上海"/&gt;&lt;property name="myList" value="广州，云南"/&gt;&lt;property name="mySet" value="苏州，常州"/&gt; （六）自动注入1234567&lt;bean id="school" class="School"&gt; &lt;property name="name" value="清华大学"/&gt;&lt;/bean&gt;&lt;!-- byName:从容器中自动找寻与属性名称相同的Bean的id，自动织入school属性 --&gt;&lt;bean id="student" class="Student" autowire="byName"&gt; &lt;property name="name" value="张三"/&gt;&lt;/bean&gt; 1234567&lt;bean class="School"&gt; &lt;property name="name" value="清华大学"/&gt;&lt;/bean&gt;&lt;!-- byType:从容器中自动找寻与属性类型相同(包括子类)的Bean，自动织入school属性 --&gt;&lt;bean id="student" class="Student" autowire="byType"&gt; &lt;property name="name" value="张三"/&gt;&lt;/bean&gt; （七）SpEL表达式12345678910111213&lt;!-- 要求： 李四年龄随机小于50 myStudent名称和myPerson相同 myStudent年龄和myPerson相同，若大于25按25算 --&gt;&lt;bean id="myPerson" class="Person"&gt; &lt;property name="pname" value="李四"&gt; &lt;property name="page" value="#&#123;T(java.lang.Math).random()*50&#125;"&gt;&lt;/bean&gt;&lt;bean id="myStudent" class="Student"&gt; &lt;!-- 需要getter方法 --&gt; &lt;property name="name" value="#&#123;myPerson.pname&#125;"&gt; &lt;property name="age" value="#&#123;myPerson.page &gt; 25 ? 25 : myPerson.page&#125;"&gt;&lt;/bean&gt; （八）内部Bean12345678&lt;bean id="student" class="Student"&gt; &lt;property name="school"&gt; &lt;!-- 内部Bean无法直接被getBean获取 --&gt; &lt;bean class="School"&gt; &lt;property name="name" value="清华大学"/&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; （九）同类抽象Bean1234567891011121314&lt;!-- abstract：阻止base被获取 --&gt;&lt;bean id="baseStudent" class="Student" abstract="true"&gt; &lt;property name="school" value="清华大学"/&gt;&lt;/bean&gt;&lt;!-- parent：继承base的property，class --&gt;&lt;bean id="myStudent1" parent="baseStudent"&gt; &lt;property name="name" value="张三"/&gt;&lt;/bean&gt;&lt;bean id="myStudent2" parent="baseStudent"&gt; &lt;property name="name" value="李四"/&gt;&lt;/bean&gt;&lt;bean id="myStudent3" parent="baseStudent"&gt; &lt;property name="name" value="王五"/&gt;&lt;/bean&gt; （十）异类抽象Bean1234567891011&lt;!-- abstract：阻止base被创建(base无class，无abstract则创建报错) --&gt;&lt;bean id="base" abstract="true"&gt; &lt;property name="school" value="清华大学"/&gt;&lt;/bean&gt;&lt;!-- parent：继承base的property --&gt;&lt;bean id="myStudent" class="Student" parent="base"&gt; &lt;property name="name" value="张三"/&gt;&lt;/bean&gt;&lt;bean id="myTeacher" class="Teacher" parent="base"&gt; &lt;property name="name" value="李四"/&gt;&lt;/bean&gt; 五、多个Spring配置文件关系平等关系配置文件： spring-beans.xml spring-base.xml 写法一（利用重载方法：可变参数） 123String resource = "spring-base.xml";String resource2 = "spring-beans.xml";ApplicationContext ac = new ClassPathXmlApplicationContext(resource,resource2); 写法二（利用重载方法：可变参数） 1234String resource = "spring-base.xml";String resource2 = "spring-beans.xml";String[] resources = &#123;resource,resource2&#125;;ApplicationContext ac = new ClassPathXmlApplicationContext(resources); 写法三（推荐） 123String resource = "spring-*.xml";ApplicationContext ac = new ClassPathXmlApplicationContext(resource);Student stu = (Student)ac.getBean("myStudemt"); 包含关系123&lt;!-- 若使用通配符，主配置文件格式需不同 --&gt;&lt;import resource="classpath:spring-base.xml"/&gt;&lt;import resource="classpath:spring-beans.xml"/&gt; 六、基于注解的DI必须1：导入aop包 必须2：开启组件扫描器 12&lt;!-- 开启组件扫描器 --&gt;&lt;context:component-scan base-package="beans"&gt; 123456789@Scope("prototype") // 单例 or 原型（默认单例）@Component("mySchool") // 组件，表示当前类被Spring容器管理public class School&#123; @Value("清华大学") // 注入值 private name; public void setName(String name)&#123; this.name = name; &#125;&#125; （一）base-package相关12345&lt;!-- 扫描com.ssm这个包及其子包 --&gt;&lt;context:component-scan base-package="com.ssm"&gt;&lt;!-- 仅扫描com.ssm这个包的子包 --&gt;&lt;context:component-scan base-package="com.ssm.*"&gt; （二）和@Component相关的注解 注解 使用位置 Repository 使用在Dao实现类上 Service 使用在Service实现类上 Controller 使用在SpringMVC的处理器上]]></content>
      <categories>
        <category>程序人生</category>
        <category>Java</category>
        <category>Java框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python知识学习17——可变类型与不可变类型]]></title>
    <url>%2F2018%2F08%2F05%2FPython%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A017%E2%80%94%E2%80%94%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[在Python当中，这样几种数据类型是不可变的类型： 整型int 浮点型float 字符串string 元组tuple 可变数据类型： 列表list 字典dict 这里使用整型稍作演示： 123456&gt;&gt;&gt; a = 10&gt;&gt;&gt; b = 10&gt;&gt;&gt; print(id(a))&gt;&gt;&gt; print(id(b))45217125444521712544 在上面的代码当中，id()函数查看的是当前变量的地址值。可以发现，对于同样的整型数据，内存当中仅创建了一份数据对象10。 补充：在字典当中，仅不可变类型可以作为字典的key]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java单元测试框架——Mockito]]></title>
    <url>%2F2018%2F08%2F05%2FJava%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94Mockito%2F</url>
    <content type="text"><![CDATA[一、建立测试目录 测试包类路径与被测试包类保持一致 二、建立测试类 类名在被测试类名后面加上Test （一）配置文件1、pom.xml 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mockito&lt;/groupId&gt; &lt;artifactId&gt;mockito-all&lt;/artifactId&gt; &lt;version&gt;1.10.19&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; Mockito是一个流行的Mocking(模拟测试)框架，通过使用Mocking框架，可以尽可能使unit test独立。 （二）构建测试类实例化被测试类对象 1private BGWorkStorage bgWorkStorage = new BGWorkStorage(); 模拟变量 12345678910@Mockprivate IBGControlManage bgControlManage;@Mockprivate IBGSeqManage bgSeqManage;@Mockprivate IBGWorkManage bgWorkManage;@Mockprivate ThreadLocal&lt;Date&gt; lastInsertDate = new ThreadLocal&lt;&gt;();@Mockprivate ThreadLocal&lt;Integer&gt; currentStep = new ThreadLocal&lt;&gt;(); 定义方法内部用到的返回结果 1234private List&lt;UsersBo&gt; userBoList;private List&lt;AcctAccountRelationBo&gt; acctAccountRelationBoList;private List&lt;AcctAccountBo&gt; acctAccountBoList;private List&lt;BillDetailItemBo&gt; queryBillDetailItemList; 初始化mock变量 1234567891011@BeforeMethodpublic void setUp() throws Exception&#123; // 初始化 MockitoAnnotations.initMocks(this); ReflectionTestUtils.setField(AopTargetUtils.getTarget(genBillHang),"iBillHangDetailItemManager",iBillHangDetailItemManager); ReflectionTestUtils.setField(AopTargetUtils.getTarget(genBillHang),"iDayBillSubtotalItemManage",iDayBillSubtotalItemManage); ReflectionTestUtils.setField(AopTargetUtils.getTarget(genBillHang),"iAcctAccountManage",iAcctAccountManage); ReflectionTestUtils.setField(AopTargetUtils.getTarget(genBillHang),"iAcctAccountRelationManage",iAcctAccountRelationManage); ReflectionTestUtils.setField(AopTargetUtils.getTarget(genBillHang),"iUsersManage",iUsersManage); ReflectionTestUtils.setField(AopTargetUtils.getTarget(genBillHang),"genConfig",genConfig);&#125; 设置上下文参数 1234567891011//设置上下文private void setContextParams() throws Exception&#123; Context.getContextParams().put("deal_mode",0); Context.getContextParams().put("deal_type",1); Context.getContextParams().put("dbi_type",14); Context.getContextParams().put(Constants.Key.CITY_ID,14); JobConfig jobConfig = new JobConfig(); jobConfig.setTotalTaskNum(2); jobConfig.setTaskItemNum(0); Context.getContextParams().put("jobConfig",jobConfig);&#125; （三）期望、断言12345// 设置返回对象when(bgControl.getBGControlByCityId(anyInt())).thenReturn(null);List list = bgWorkStorage.fetchData();// 断言Assert.assertNull(list); 123bgWorkStorage.processData(workMQMessageBoList);// 断言方法执行次数verify(bgWorkManage, times(1)).updateWorkUsersBgFlagBatch(anyListOf(BGWorkUsersBo.class)); 断言执行次数还有这些函数方法：never()，atLeast()，atLeastOnce()，atMost() timeout(100).times(2)代表100毫秒内被调用两次 （四）PowerMock1234@PrepareForTest(&#123;BGWorkStorageTest.class,CollectionUtils.class, PropertiesUtil.class&#125;)@PowerMockIgnore("javax.management.*")public class BGWorkStorageTest &#123;&#125; 1234@ObjectFactorypublic ITestObjectFactory getObjectFactory() &#123; return new PowerMockObjectFactory();&#125; 123456789// mock工具类CollectionUtils collectionUtils = PowerMockito.mock(CollectionUtils.class); // 替换被测试类中的变量PowerMockito.whenNew(CollectionUtils.class).withAnyArguments().thenReturn(collectionUtils);// mock静态方法PowerMockito.mockStatic(CollectionUtils.class); // 断言PowerMockito.when(collectionUtils.isEmpty(anyList())).thenReturn(false);PowerMockito.when(collectionUtils.isNotEmpty(anyList())).thenReturn(true); （五）期望异常、模拟异常捕获12// 期望捕获异常：@Test(expectedExceptions = com.newland.common.NLException.class) 12// 模拟void函数doNothing().when(spy).add(anyInt(), anyString()); 1234// 模拟方法抛出异常when(mock.someMethod()).thenThrow(new RuntimeException());// 模拟void方法抛出异常doThrow(new RuntimeException()).when(mock).someMethod(); 补充： when()匹配固定字符串的方式: 1when(AcctFileProcessUtil.getNodeElement(anyString(), eq("MemProvCode"), eq("MemProvCode"))).thenReturn(null); 对于工具类没有返回值的情况，跳过执行: 12PowerMockito.mockStatic(FileUtils.class);PowerMockito.doNothing().when(FileUtils.class, "moveFile", (File) anyObject(), (File) anyObject()); 对静态方法进行断言（前提：先使用PowerMock的注解） 12PowerMockito.verifyStatic(times(1));FileTool.writeFile(anyString(), anyString(), anyString(), anyListOf(String.class));]]></content>
      <categories>
        <category>程序人生</category>
        <category>Java</category>
        <category>Java框架</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>Java</tag>
        <tag>框架</tag>
        <tag>Mockito</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python知识学习16——不定长参数]]></title>
    <url>%2F2018%2F08%2F04%2FPython%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A016%E2%80%94%E2%80%94%E4%B8%8D%E5%AE%9A%E9%95%BF%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[当我们不确定需要的参数个数时，可以使用不定长参数来作为形式参数。 不定长参数可以选择传递0~多个值，并将这些值保存为一个元组： 12345678&gt;&gt;&gt; def test(a, b, *args):··· print("a = ", a)··· print("b = ", b)··· print("args = ", args)&gt;&gt;&gt; test(1, 2, 3, 4, 5)a = 1b = 2args = (3, 4, 5) 当然不定长参数也可以接受0个参数： 1234567&gt;&gt;&gt; def test(a, b, *args):··· print(a)··· print(b)··· print(args)&gt;&gt;&gt; test(1, 2)12 不定长参数还有这样一种格式：结合字典的不定长参数： 12345678910&gt;&gt;&gt; def test(a, b, *args, **kwargs):··· print("a =", a)··· print("b =", b)··· print("args =", args)··· print("kwargs =", kwargs)&gt;&gt;&gt; test(1, 2, 3, 4, 5)a = 1b = 2args = (3, 4, 5)kwargs = &#123;&#125; 若是这样给不定长参数传值，**kwargs并不会接收到值，因为我们需要以字典的方式传值 12345678910&gt;&gt;&gt; def test(a, b, *args, **kwargs):··· print("a =", a)··· print("b =", b)··· print("args =", args)··· print("kwargs =", kwargs)&gt;&gt;&gt; test(1, 2, name = 3, age = 4, addr = 5)a = 1b = 2args = ()kwargs = &#123;'name': 3, 'age': 4, 'addr': 5&#125; 拆包： 如果需要直接给两种不定长参数分别传递元组和字典，应该怎么做呢？ 123456789101112&gt;&gt;&gt; def test(a, b, *args, **kwargs):··· print("a =", a)··· print("b =", b)··· print("args =", args)··· print("kwargs =", kwargs)&gt;&gt;&gt; a = ("a", "b", "c")&gt;&gt;&gt; b = &#123;"name":"Tom", "age":22&#125;&gt;&gt;&gt; test(1, 2, a, b)a = 1b = 2args = (('a', 'b', 'c'), &#123;'name': 'Tom', 'age': 22&#125;)kwargs = &#123;&#125; 可见，这并不是我们想要的结果，因为Python将我们传递的元组和字典都作为第一种不定长参数的元组的元素了。 但是如果我们这样传递实际参数，就可以分别为两种不定长形式参数赋值： 123456789101112&gt;&gt;&gt; def test(a, b, *args, **kwargs):··· print("a =", a)··· print("b =", b)··· print("args =", args)··· print("kwargs =", kwargs)&gt;&gt;&gt; a = ("a", "b", "c")&gt;&gt;&gt; b = &#123;"name":"Tom", "age":22&#125;&gt;&gt;&gt; test(1, 2, *a, **b)a = 1b = 2args = ('a', 'b', 'c')kwargs = &#123;'name': 'Tom', 'age': 22&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python知识学习15——缺省参数]]></title>
    <url>%2F2018%2F08%2F02%2FPython%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A015%E2%80%94%E2%80%94%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[观察以下代码，思考缺省参数存在的意义： 12345def get_sum(a, b): return a + bprint(get_sum(10, 20))print(get_sum(11, 20))print(get_sum(12, 20)) 我们发现，参数b的值一直都是10，那么怎么样使其值默认为20呢？ 我们这样修改代码： 12345def get_sum(a, b = 20): return a + bprint(get_sum(10))print(get_sum(11))print(get_sum(12)) 补充：含缺省值的参数，必须在参数列表的最后 当存在多个缺省参数时，亦可单独给某个缺省参数赋值： 12345def get_sum(a, b = 20, c = 5): return a + b + cprint(get_sum(10, c = 10))print(get_sum(11, c = 10))print(get_sum(12, c = 10)) 在传递多个缺省值时，参数顺序就不再重要了： 12345def get_sum(a, b = 20, c = 5): return a + b + cprint(get_sum(10, c = 10, b = 10))print(get_sum(11, c = 10, b = 10))print(get_sum(12, c = 10, b = 10)) 如果不指定缺省参数的名称，则是按顺序赋值： 12345def get_sum(a, b = 20, c = 5): return a + b + cprint(get_sum(10, 10, 10))print(get_sum(11, 10, 10))print(get_sum(12, 10, 10))]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python知识学习14——局部变量与全局变量]]></title>
    <url>%2F2018%2F08%2F01%2FPython%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A014%E2%80%94%E2%80%94%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[局部变量就是只能在定义他的函数当中使用，而在其他函数当中不能使用的变量。 全局变量就是在函数外部定义，在任意函数当中都可以使用的变量。 重点： 如果函数当中需要修改全局变量的值的话，需要使用global关键字，否则Python将会把函数当中的修改当作一个重名的局部变量对待 123456&gt;&gt;&gt; age = 10&gt;&gt;&gt; def print_age():··· age = 20&gt;&gt;&gt; print_age()&gt;&gt;&gt; print(age)10 下面使用global关键字： 1234567&gt;&gt;&gt; age = 10&gt;&gt;&gt; def print_age():··· global age··· age = 20&gt;&gt;&gt; print_age()&gt;&gt;&gt; print(age)20 应该尽量减少使用全局变量，避免全局变量和局部变量重名 补充：如果是字典、列表作为全局变量，在函数当中对其进行增删改，可以不使用global声明]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端基础02——CSS]]></title>
    <url>%2F2018%2F07%2F10%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%8002%E2%80%94%E2%80%94CSS%2F</url>
    <content type="text"><![CDATA[一、互联网前端开发三层 技术 说明 作用 HTML 超文本标记语言 从语义的角度描述页面结构 CSS 层叠式样式表 从审美的角度负责页面样式 JS JavaScript 从交互的角度描述页面行为 二、常见属性 属性 设置 sublime快捷键 颜色 color:red; c 字号大小 font-size:40px; fsize 背景颜色 background-color:blue; bgc 加粗 font-weight:bold;(加粗)font-weight:normal;(正常) fwb / fwn 斜体 font-style:italic(normal); fos 下划线 text-decoration:underline(none);（decoration：装饰） td 三、基础选择器123456789/*标签选择器*/ul&#123; background-color:pink;&#125;/*id选择器*/#head&#123; color:red;&#125; 四、类选择器一个标签可以属于多个类！ 要使用原子类！ 12345678/*类选择器*/.important&#123; text-decoration:underline;&#125;.special&#123; color:red;&#125; 12&lt;!-- 属于多个类 --&gt;&lt;p class="important special"&gt;xxx&lt;/p&gt; id选择器与类选择器的取舍 类上样式，id上行为 提示：一般来说，CSS使用类选择器（class），id给JS使用，减少共用情况 五、后代选择器后代选择器选择的是“后代”，而非“儿子”，包含即可！ 1234567.div1 p&#123; color:red;&#125;.div2 li2 p&#123; color:blue;&#125; 六、交集选择器特点：没有空格，可以多个交集 常用：标签名 + 类名 123h3.special&#123; color:red;&#125; 七、并集选择器123h3,li&#123; color:red;&#125; 八、通配符选择器注意：效率不高，页面标签越多效率越低，不建议使用 123*&#123; color:red;&#125; 九、一些CSS3选择器一、儿子选择器（IE7开始兼容） 1234/* 仅作用于儿子，而非后代 */div&gt;p&#123; color:red;&#125; 二、序选择器（IE8开始兼容） 1234567891011ul li:first-child&#123; color:red;&#125;ul li:nth-child&#123; color:yellow;&#125;ul li:last-child&#123; color:blue;&#125; 三、下一个兄弟选择器（IE7开始兼容） 1234/*紧跟着的下一个兄弟标签*/h3+p&#123; color:red;&#125; 十、CSS的继承性和层叠性（重要！）一、继承性 可继承的属性（文字样式属性） color text-开头的 line-开头的 font-开头的 二、层叠性 权重统计方法：（无兼容问题） 数id选择器的数量、类选择器的数量、标签选择器的数量：按位比较大小 如果权重相同，写在后面的有效 注意1：继承得到的样式权重为0（未真实选中） 注意2：实际权重都为0时（即都是通过继承），属性描述更接近目标标签的有效 注意3：若&lt;注意2&gt;的接近程度相同，判断继承权重；权重再相同，判断书写顺序 提示：标签含有多个类名并分别设置样式，和类名顺序无关，仅和CSS顺序相关 提高权重（了解）123456/*1. 提高样式，不提高选择器本身2. 对继承样式无效*/div&#123; color:red !important;&#125; 十一、盒子模型（重要！）宽度和真实占有宽度不同！（需要考虑padding和border） 盒子属性 属性含义 width 宽度（描述内容） heigth 高度（描述内容） padding 内边距 border 边框 margin 外边距 （一）认识padding 1、padding区域有背景颜色（CSS2.1下和内容区域相同） 2、padding有方向（空格隔开：上右下左） padding-top padding-right padding-bottom padding-left （二）认识border（上右下左） 属性 效果 全称 粗细 10px border-width 线型 solid：实线dashed：虚线dotted：点线double：双横线groove：内阴影inset：内陷outset：外凸ridge：垄状边框 border-style 颜色 默认黑色 border-color 1、样式拆分 border-top-style border-bottom-color border-left-width 2、border可以没有 1234div&#123; border-left:none;/*法一*/ border-left-width:0;/*法二*/&#125; 十二、标准文档流一、文档流现象 （1）空白折叠现象 12&lt;!-- 要让图片没有缝隙，必须紧密连接 --&gt;&lt;img src="images/0.jpg"&gt;&lt;img src="images/1.jpg"&gt;&lt;img src="images/2.jpg"&gt; （2）高矮不齐，底边对齐现象（3）自动换行现象 二、块级元素和行内元素 （1）块级元素 独占一行（不与其他元素并列） 可以设置宽高 若不设置宽度，默认宽度变为父级元素的100% （2）行内元素 与其他元素并排 不能设置宽高，默认宽高就是文字宽高 （3）块级元素和行内元素的相互转换 123456div&#123; display:inline;/*显示模式：行内*/&#125;span&#123; display:block;/*显示模式：块级*/&#125; 三、脱离标准文档流 （1）浮动（重要！！！） 特性 说明 浮动元素自动脱离标准文档流 任何元素都可以设置宽高 浮动元素自动贴靠 有空间的情况下会自动寻找边 浮动元素有“字围”效果 浮动元素可以遮挡未浮动元素，但不能遮挡文字 （2）绝对定位 （3）固定定位]]></content>
      <categories>
        <category>前端</category>
        <category>CSS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端基础01——HTML]]></title>
    <url>%2F2018%2F07%2F10%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%8001%E2%80%94%E2%80%94HTML%2F</url>
    <content type="text"><![CDATA[准备关于HTML的DTD区别 DTD：三种文档类型：S（Strict）、T（Transitional）、F（Frameset）。 html5没有XHTML 1.0 Transitional严格的要求，并且简化了很多东西可以直接使用 &lt;!DOCTYPE HTML&gt; DTD类型 使用环境 Strict 如果您需要干净的标记，免于表现层的混乱，请使用此类型。请与层叠样式表（CSS）配合使用 Transitional DTD 可包含 W3C 所期望移入样式表的呈现属性和元素。如果您的读者使用了不支持层叠样式表（CSS）的浏览器以至于您不得不使用 HTML 的呈现特性时使用 Frameset DTD 应当被用于带有框架的文档。除 frameset 元素取代了 body 元素之外，Frameset DTD 等同于 Transitional DTD HTML与XHTML区别最主要的不同： XHTML 元素必须被正确地嵌套 XHTML 元素必须被关闭 标签名必须用小写字母 XHTML 文档必须拥有根元素 一、关键字和页面描述设置页面描述： 1&lt;meta name="Description" content="描述内容"/&gt; 定义关键词： 1&lt;meta name="Keywords" content="关键词"&gt; 二、基本标签以及属性 标签 （文本级：只含文字、图片、表单） 属性 img src：相对路径 alt：图片出错提示 a（文本级） href：超链接地址 title：鼠标悬停文本 target：是否新标签打开（_blank） 锚点：href=”#xxx” (xxx为其他a标签的name或id属性) 三、定义表格123456789&lt;!-- dt和dd都是容器级标签 --&gt;&lt;dl&gt; &lt;dt&gt;定义标题&lt;/dt&gt; &lt;dd&gt;描述&lt;/dd&gt; &lt;dt&gt;定义标题&lt;/dt&gt; &lt;dd&gt;描述1&lt;/dd&gt; &lt;dd&gt;描述2&lt;/dd&gt;&lt;/dl&gt; 四、div和span 标签 类型 div 容器级 span 文本级 五、表单123456789101112131415&lt;form action="提交路径" method="post"&gt; 文本框：&lt;input type="text" value=“xxx”/&gt; 密码框：&lt;input type="password" /&gt; 单选框：&lt;input type="radio" name="sex" checked="checked"/&gt; 复选框：&lt;input type="checkbox" name="hobby"/&gt; 下拉框： &lt;select&gt; &lt;option&gt;北京&lt;/option&gt; &lt;option&gt;上海&lt;/option&gt; &lt;option&gt;广州&lt;/option&gt; &lt;/select&gt; 文本域：&lt;textarea cols="30" rows="10"&gt;&lt;/textarea&gt;&lt;/form&gt; 六、三种按钮123普通按钮：&lt;input type="button" value="确定" /&gt;提交按钮：&lt;input type="submit" /&gt;重置按钮：&lt;input type="reset" /&gt; 七、label标签123请选择性别：&lt;input type="radio" name="sex" id="male"&gt;&lt;label for="male"&gt;男&lt;/label&gt;&lt;input type="radio" name="sex" id="female"&gt;&lt;label for="female"&gt;女&lt;/label&gt; 八、转义字符常用字符： 字符 转义（分号结尾） 实体编号（分号结尾） &lt; &amp;lt &amp;#60 &gt; &amp;gt &amp;#62 © &amp;copy &amp;#169 空格 &amp;nbsp &amp;#160 &amp; &amp;amp &amp;#38 &#34;&#34; &amp;quot &amp;#34 其他特殊字符： 字符 转义（分号结尾） 实体编号（分号结尾） &#39; &amp;apos &amp;#39 ￥ &amp;yen &amp;#165 ® &amp;reg &amp;#174 § &amp;sect &amp;#167 £ &amp;pound &amp;#163 × &amp;times &amp;#215 ÷ &amp;divide &amp;#247 ¢ &amp;cent &amp;#162 &#95; &#95; &amp;#95 &#42; &#42; &amp;#42 九、html废弃标签介绍1234567891011字体：&lt;font size="1~7" color="red"&gt;&lt;/font&gt;&lt;!-- 现作为css钩子使用 --&gt;加粗：&lt;b&gt;&lt;/b&gt;斜体：&lt;i&gt;&lt;/i&gt;下划线：&lt;u&gt;&lt;/u&gt;强调：&lt;strong&gt;&lt;strong&gt;强调：&lt;em&gt;&lt;/em&gt;水平线：&lt;hr/&gt;换行（p替代）：&lt;br&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>HTML基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python知识学习13——函数的return]]></title>
    <url>%2F2018%2F07%2F08%2FPython%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A013%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E7%9A%84return%2F</url>
    <content type="text"><![CDATA[return的基本使用有时我们不需要在函数当中输出程序的结果，而仅仅需要其充当一个功能时，我们就需要使用函数的返回值，即return关键字 示例如下： 12345def get_sum(a, b): return (a + b)result = get_sum(10, 20)print(result) 一个函数返回多个值当一个函数包含多个return会发生什么呢？ 123456789def test(): a = 11 b = 22 c = 33 return a return b return cresult = test()print(result) 打印的结果是11，也就是说，只有a被成功返回了，因为：return不仅仅意味着返回，同时意味着函数执行终止。 因此以上代码在将a作为返回值返回后也就终止了函数test()的执行。 要成功返回多个参数，方法可以有： 将多个参数存放在列表当中 将多个参数存放在元组当中 其他类似方法 将多个参数存放在列表当中 1234567def test(): a = 11 b = 22 c = 33 return [a, b, c]result = test()print(result) 返回：[11, 22, 33] 将多个参数存放在元组当中 1234567def test(): a = 11 b = 22 c = 33 return (a, b, c)result = test()print(result) 返回：(11, 22, 33) 补充：直接返回多个值 1234567def test(): a = 11 b = 22 c = 33 return a, b, cresult = test()print(result) 返回：(11, 22, 33) 由此可见，直接返回多个值等于通过一个元组进行返回]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python知识学习12——带参数的函数]]></title>
    <url>%2F2018%2F07%2F08%2FPython%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A012%E2%80%94%E2%80%94%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[若我们需要实现一个加法计算器，计算a与b的和，代码可能是这样的： 123456def get_sum(): a = 10 b = 20 print(a + b)get_sum() 不过这样的代码存在一个问题，即函数中a与b的值是固定的。那么怎么才能从函数外部传递值呢？ 1234def get_sum(a, b): print(a + b)get_sum(10, 20)]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[佛祖注释版]]></title>
    <url>%2F2018%2F07%2F08%2F%E4%BD%9B%E7%A5%96%E6%B3%A8%E9%87%8A%E7%89%88%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122////////////////////////////////////////////////////////////////////// _ooOoo_ //// o8888888o // // 88" . "88 // // (| -_- |) // // O\ = /O //// ____/`---'\____ // // .' \\| |// `. //// / \\||| : |||// \ // // / _||||| -:- |||||- \ //// | | \\\ - /// | | //// | \_| ''\---/'' | | // // \ .-\__ `-` ___/-. / // // ___`. .' /--.--\ `. . ___ // // ."" '&lt; `.___\_&lt;|&gt;_/___.' &gt;'"". //// | | : `- \`.;`\ _ /`;.`/ - ` : | | // // \ \ `-. \_ __\ /__ _/ .-` / / //// ========`-.____`-.___\_____/___.-`____.-'======== // // `=---=' //// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ //// 佛祖保佑 永无BUG 永不修改 //////////////////////////////////////////////////////////////////////]]></content>
      <categories>
        <category>技巧分享</category>
        <category>有趣的事物</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>趣事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python知识学习11——函数]]></title>
    <url>%2F2018%2F07%2F08%2FPython%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A011%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数可以将代码模块化，便于代码的维护和管理，提高代码的复用性，同时也可以降低代码的耦合程度。 函数在定义之后需要调用才会运行。 这里介绍一下Python当中的函数的定义和调用： 1234567891011121314151617181920212223242526272829303132def print_fozu(): print(" _ooOoo_ ") print(" o8888888o ") print(" 88 . 88 ") print(" (| -_- |) ") print(" O\\ = /O ") print(" ____/`---'\\____ ") print(" . ' \\| |// `. ") print(" / \\||| : |||// \\ ") print(" / _||||| -:- |||||- \\ ") print(" | | \\\\\\ - /// | | ") print(" | \\_| ''\\---/'' | | ") print(" \\ .-\\__ `-` ___/-. / ") print(" ___`. .' /--.--\\ `. . __ ") print(" ."" '&lt; `.___\\_&lt;|&gt;_/___.' &gt;'"". ") print(" | | : `- \\`.;`\\ _ /`;.`/ - ` : | | ") print(" \\ \\ `-. \\_ __\\ /__ _/ .-` / / ") print(" ======`-.____`-.___\\_____/___.-`____.-'====== ") print(" `=---=' ") print(" ") print(" ............................................. ") print(" 佛祖镇楼 BUG辟邪 ") print(" Zen of python: ") print(" Beautiful is better than ugly.； ") print(" Explicit is better than implicit. ") print(" Simple is better than complex. ") print(" Complex is better than complicated. ") print(" Flat is better than nested. ") print(" Sparse is better than dense. ") print(" Readability counts. ") print(" Now is better than never. ")print_fozu()]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac电脑如何查询命令存储位置]]></title>
    <url>%2F2018%2F07%2F08%2FMac%E7%94%B5%E8%84%91%E5%A6%82%E4%BD%95%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[我们会在Mac电脑当中使用很多命令，如Python3，或者java等。那么如果我们忘记了该命令的安装位置，我们要怎么查找呢？ 首先，打卡Mac系统自带的终端或者iTerm，然后在命令行中这样查找你所需要查询的命令： 12$ which java/Library/Java/JavaVirtualMachines/jdk1.8.0_141.jdk/Contents/Home/bin/java]]></content>
      <categories>
        <category>技巧分享</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>Mac</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python知识学习10——元组]]></title>
    <url>%2F2018%2F07%2F08%2FPython%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A010%E2%80%94%E2%80%94%E5%85%83%E7%BB%84%2F</url>
    <content type="text"><![CDATA[元组类型：tuple 元组是有序的，元组的元素不能修改，否则会报错！ 一个元素的元组定义： 1t = (1,) 但是如果元组内存储的对象地址没有改变，但是该对象内部发生了变化，这样的行为是被允许的 1234567&gt;&gt;&gt; a = [11, 22, 33]&gt;&gt;&gt; b = (a)&gt;&gt;&gt; print("元组b原本的内容：&#123;&#125;".format(b))&gt;&gt;&gt; a.append(44)&gt;&gt;&gt; print("元组b现在的内容：&#123;&#125;".format(b))元组b原本的内容：[11, 22, 33]元组b现在的内容：[11, 22, 33, 44] 获取元组内的各个元素的小技巧： 1234&gt;&gt;&gt; tup = (1, 2, 3)&gt;&gt;&gt; a, b, c = tup&gt;&gt;&gt; print("a，b，c分别是&#123;&#125;，&#123;&#125;，&#123;&#125;".format(a, b, c))a，b，c分别是1，2，3 命名元组： 使用命名元组可以实现对象的创建 1234from collections import namedtupleStudent = namedtuple("Student", "name age sex")stu1 = Student("王小明", 12, "男") name age sex可以使用可迭代对象的方式传入，或者使用空格or逗号分隔]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python知识学习09——集&字典]]></title>
    <url>%2F2018%2F07%2F08%2FPython%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A009%E2%80%94%E2%80%94%E9%9B%86%26%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[（一）Set集的定义1234# 定义一个空集s = set()# 定义含有元素的集s1 = &#123;1&#125; 注意：s = {}这种定义方式是定义一个空字典，而不是空Set 注意：set的元素要求必须可以hash （二）字典len()获取字典键值对的个数： 12students = &#123;"name":"Jack", "age":20&#125;len(students) keys()获取字典所有的键： 123&gt;&gt;&gt; students = &#123;"name":"Jack", "age":20&#125;&gt;&gt;&gt; students.keys()dict_keys(['name', 'age']) 提示：在Python2当中，该函数会返回的是一个单纯的列表 values()获取字典所有的值： 123&gt;&gt;&gt; students = &#123;"name":"Jack", "age":20&#125;&gt;&gt;&gt; students.values()dict_values(['Jack', 20]) 提示：在Python2当中，该函数会返回的是一个单纯的列表 items()得到一个列表，该列表的元素由多个元组组成，每一个键值对被以键和值得形式存储到元组当中，分别是元组的第零个元素，和第一个元素 123&gt;&gt;&gt; students = &#123;"name":"Jack", "age":20&#125;&gt;&gt;&gt; students.items()dict_items([('name', 'Jack'), ('age', 20)]) 提示：在Python2当中，该函数会返回的是一个单纯的列表]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中append和extend的区别]]></title>
    <url>%2F2018%2F07%2F08%2FPython%E4%B8%ADappend%E5%92%8Cextend%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[在Python的列表当中，有这两种列表添加元素的方法，那就是append和extend。那么他们到底有什么区别、有什么不一样呢？ appendappend用于将一个对象 整体作为列表的新元素，这将改变原列表，但append并没有返回值： 12345&gt;&gt;&gt; a = ["Jack", "Rose"]&gt;&gt;&gt; b = "Peter"&gt;&gt;&gt; a.append(b)&gt;&gt;&gt; print(a)['Jack', 'Rose', 'Peter'] 如果将一个新列表作为append的对象，则会将新列表作为原列表的一个元素： 12345&gt;&gt;&gt; a = ["Jack", "Rose"]&gt;&gt;&gt; b = ["Peter", "Bob"]&gt;&gt;&gt; a.append(b)&gt;&gt;&gt; print(a)['Jack', 'Rose', ['Peter', 'Bob']] extendextend用于将列表2的元素添加进列表1当中，这将改变列表1，extend同样没有返回值： 1234&gt;&gt;&gt; a = ["Jack", "Rose"]&gt;&gt;&gt; b = ["Peter", "Bob"]&gt;&gt;&gt; a.extend(b)['Jack', 'Rose', 'Peter', 'Bob'] 如果将一个字符串作为被extend的对象，将会怎么样呢？ 1234&gt;&gt;&gt; a = ["Jack", "Rose"]&gt;&gt;&gt; b = "Peter"&gt;&gt;&gt; a.extend(b)['Jack', 'Rose', 'P', 'e', 't', 'e', 'r']]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
        <category>Python技巧</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>学习</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python知识学习08——for循环的else]]></title>
    <url>%2F2018%2F07%2F07%2FPython%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A008%E2%80%94%E2%80%94for%E5%BE%AA%E7%8E%AF%E7%9A%84else%2F</url>
    <content type="text"><![CDATA[在Python当中，存在一种比较特殊的语法for-else，该语法允许在for循环遍历一个列表时，在列表中已经没有未被遍历的元素时，执行else语句块当中的语句。 例： 12345names = ["Java", "Python", "Ruby", "C++"]for lang in names: print(lang)else: print("============") 输出： 12345JavaPythonRubyC++============ 我们也可以使用这个技巧避免使用flag标记法来判断一些逻辑。 例： 判断students列表中，是否存在name为Jack的学生： 12345678students = [&#123;"name":"Rose", "age":"22"&#125;, &#123;"name":"Rose", "age":"19"&#125;, &#123;"name":"Peter", "age":"23"&#125;]find_name = "Rose" # 查询是否存在一个名为Rose学生for stu in students: if stu["name"] == find_name: print("存在该名学生，该学生名为&#123;&#125;，今年&#123;&#125;岁".format(stu["name"], stu["age"])) breakelse: print("不存在该学生") # 若执行该条语句，说明列表students已经遍历结束，但尚未break跳出，则说明：未找到目标]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>学习</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python知识学习07——字典]]></title>
    <url>%2F2018%2F07%2F06%2FPython%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A007%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[字典类型：dict Python字典的增删改查增： 123stu = &#123;"name":"Rose"&#125;stu["age"] = 22print(stu) 删： 123stu = &#123;"name":"Rose", "age":22&#125;del stu["name"]print(stu) 提示：如果删除的是不存在的key，则会报错 改： 123stu = &#123;"name":"Rose", "age":22&#125;stu["age"] = 30print(stu) 查： 123stu = &#123;"name":"Rose", "age":22&#125;age = stu["age"]print(age) 提示：使用这种查询方法，如果键不存在，则会报错 1234&gt;&gt;&gt; stu = &#123;"name":"Rose", "age":22&#125;&gt;&gt;&gt; age = stu.get("age")&gt;&gt;&gt; print(age)22 1234&gt;&gt;&gt; stu = &#123;"name":"Rose", "age":22&#125;&gt;&gt;&gt; address = stu.get("address")&gt;&gt;&gt; print(address)None 提示：使用这种查询方法，如果键不存在，不会报错 查询字典当中是否存在某个键： 123&gt;&gt;&gt; stu = &#123;"name":"Jack", "age":"22"&#125;&gt;&gt;&gt; "name" in stuTrue 123&gt;&gt;&gt; stu = &#123;"name":"Jack", "age":"22"&#125;&gt;&gt;&gt; "name" in stu.keys()True 查询字典当中是否存在某个值： 123&gt;&gt;&gt; stu = &#123;"name":"Jack", "age":"22"&#125;&gt;&gt;&gt; "Jack" in stu.values()True]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python知识学习06——列表]]></title>
    <url>%2F2018%2F06%2F28%2FPython%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A006%E2%80%94%E2%80%94%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[（一）与Java列表的对比列表类型：list Java语言的数组： 1int nums = &#123;11, 22, 33, 44, 55&#125; Java列表的特点 数组内元素数据类型必须相同 数组长度固定 Python语言的列表： 1a = [123, 1.23, "123", True] Python列表的特点 列表内元素数据类型可以不同 列表长度不固定 python列表不能指定初始化大小 （二）列表的索引列表的index方法没有rindex，但是可以接收起始值，只能从左向右查 index和count方法的时间复杂度都是On，当index方法没有找到匹配元素时，将会报错 index方法12345# 列表的index方法，返回第一个匹配的元素到索引&gt;&gt;&gt; lst = [1, 2, 1]&gt;&gt;&gt; lst.index(1)0 12345# 列表的index方法，指定从哪个索引位置开始查找，还可以指定结束的索引，但是只能从左向右&gt;&gt;&gt; lst = [1, 2, 1]&gt;&gt;&gt; lst.index(1, -1)2 count方法12345# count方法，统计一个元素出现的总次数&gt;&gt;&gt; lst = [1, 2, 3, 4, 1]&gt;&gt;&gt; lst.count(1)2 （三）列表的增删改查操作增加append方法，将元素添加在列表的最后时间复杂度为O1，属于就地修改，返回值为None 123&gt;&gt;&gt; names = ["Tom", "Jerry", "Rose"]&gt;&gt;&gt; names.append("Peter")['Tom', 'Jerry', 'Rose', 'Peter'] insert方法，将元素插入指定索引位置insert也属于就地修改，返回值为None（索引可以溢出，过大则尾部追加，过小则头部追加） 123&gt;&gt;&gt; names = ["Tom", "Jerry", "Rose"]&gt;&gt;&gt; names.insert(1, "Peter")['Tom', 'Peter', 'Jerry', 'Rose'] 提示：insert()需要指定插入的索引位置（索引从0计），而append()固定添加在原有列表的最后 +/*方法合并两个列表的方法：列表相加，产生一个新的列表，原列表保持不变 1234&gt;&gt;&gt; names1 = ["Tom", "Jerry"]&gt;&gt;&gt; names2 = ["Peter", "Rpse"]&gt;&gt;&gt; names3 = names1 + names2['Tom', 'Jerry', 'Peter', 'Rpse'] 提示：列表也可以使用乘*n来重复列表元素n次，产生新列表，原列表保持不变 extend方法，将可迭代对象的元素追加进来，就地修改，返回None将一个列表合到另一个列表当中： 12345&gt;&gt;&gt; names1 = ["Tom", "Jerry"]&gt;&gt;&gt; names2 = ["Peter", "Rose"]&gt;&gt;&gt; names1.extend(names2)# names1 ['Tom', 'Jerry', 'Peter', 'Rpse']# names2 ['Peter', 'Rose'] 提示：names1不仅拥有自己原本的元素，还继承了names2的元素 删除按元素删除remove()函数接收一个元素，并将该元素从列表中删除，返回值为None 123&gt;&gt;&gt; names = ["Tom", "Jerry", "Rose", "Tom"]&gt;&gt;&gt; names.remove("Tom")# names ['Jerry', 'Rose', 'Tom'] 按下标删除pop()函数将列表最后一个元素删除，并返回该元素 pop(index)可以根据索引删除元素，并返回该元素 123&gt;&gt;&gt; names = ["Tom", "Jerry", "Rose"]&gt;&gt;&gt; names.pop()'Rose' 提示：从左到右删除第一个匹配的元素 使用切片使用下标获取列表元素，以及切片 123&gt;&gt;&gt; names = ["Tom", "Jerry", "Rose", "Tom"]&gt;&gt;&gt; names[0]'Tom' 123&gt;&gt;&gt; names = ["Tom", "Jerry", "Rose", "Tom"]&gt;&gt;&gt; names[1: 3]['Jerry', 'Rose'] 使用del关键字，根据下标删除元素：123&gt;&gt;&gt; names = ["Tom", "Jerry", "Rose", "Tom"]&gt;&gt;&gt; del names[0]['Jerry', 'Rose', 'Tom'] 使用clear清除元素clear()可以清空一个列表内的所以元素 修改改变元素123&gt;&gt;&gt; names = ["Tom", "Jerry", "Rose", "Tom"]&gt;&gt;&gt; names[0] = "Tommy"# names ['Tommy', 'Jerry', 'Rose', 'Tom'] 列表的反转（倒序排列）就地修改，返回None 1234&gt;&gt;&gt; lst = [1, 2, 3]&gt;&gt;&gt; lst.reverse()[3, 2, 1] 列表的排序sort(key = None, reverse = False) -&gt; None 排序函数，就地修改，默认为升序，key接收一个排序函数 查询12345names = ["Tom", "Jerry", "Rose"]if "Jerry" in names: print("找到了")elif "Jerry" not in names: print("未找到") 查询获取目标对象的索引123names = ["Tom", "Peter", "Rose"]index = names.index("Peter")print(index) （四）拓展：列表的复制及比较列表复制copy()方法可以复制列表的元素，赋值给新的变量，但是不是同一个对象 1234567&gt;&gt;&gt; lst1 = [1, 2, 3]&gt;&gt;&gt; lst2 = lst1.copy()&gt;&gt;&gt; print(lst1 == lst2)&gt;&gt;&gt; print(lst1 is lst2)TrueFalse 小练习01已知代码如下，问： lst1 == lst2结果是什么 如何比较lst1和lst2的内存地址 12lst1 = list(range(4))lst2 = list(range(4)) 如果再执行以下语句，是否发生列表复制的过程？ 1lst1 = lst2 如果再执行以下语句，求输出结果 12lst1[0] = 99print(lst2[0]) 答： lst1 == lst2，返回True，因为在Python中，双等号是依次比较列表元素是否相同 我们可以通过id(lst1)、id(lst2)来分别获取两个列表的相对内存地址，比较其是否为相同对象；或者直接使用lst1 is lst2来进行比较；注意，列表不可求hash() 不存在列表复制，而是指向的内存地址的更改 输出99，因为此时，lst1和lst2已经指向相同内存，为同一对象 小练习02问已知如下代码，请写出输出结果： 12345678lst1 = [1, 2, 3, [55, 88, 99], 4]lst2 = lst1.copy()lst2[1] = 22lst2[3][0] = 555print(lst1[1])print(lst1[3][0]) 答122555 原因分析：我们都知道，copy()方法是复制列表中的元素，所以乍一看下，lst1的子列表中的元素不应该跟随lst2的子列表元素一起更改。但是，由于lst1中的子列表是引用类型，当执行copy()`lst1操作的时候，并不会将子列表中的元素也一起拷贝，而是拷贝了子列表的内存地址，这被称作浅拷贝` 浅拷贝： 只拷贝父对象，不会拷贝对象的内部的子对象 解决使用深拷贝： 12345678910import copylst1 = [1, 2, 3, [55, 88, 99], 4]lst2 = copy.deepcopy(lst1)lst2[1] = 22lst2[3][0] = 555print(lst1[1])print(lst1[3][0]) 输出： 12255]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字符串切割小练习]]></title>
    <url>%2F2018%2F06%2F28%2FPython%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E5%89%B2%E5%B0%8F%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[题： 对以下字符串进行处理，删除所有的空白符和\t，并返回新的字符串 1a = "cwow uv j w oiowu \tcowjcw\tovbub \t covxoq jcocn" 析： 在这里如果使用split(&quot; &quot;)这样的方法，无法去除\t； 而如果使用split(&quot; \t&quot;)这样的方法，仅能去除空格和\t相连的情况 因此，在这里split()函数不需要接收任何参数，默认删除所有空格和\t 最后使用join()函数，功能：用一个字符串连接列表中各个元素，组成新的字符串 答： 12345&gt;&gt;&gt; a = "cwow uv j w oiowu \tcowjcw\tovbub \t covxoq jcocn"&gt;&gt;&gt; result = a.split()&gt;&gt;&gt; temp = ""&gt;&gt;&gt; temp.join(result)'cwowuvjwoiowucowjcwovbubcovxoqjcocn']]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
        <category>Python技巧</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>学习</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python轻松交换两个变量的值]]></title>
    <url>%2F2018%2F06%2F28%2FPython%E8%BD%BB%E6%9D%BE%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%2F</url>
    <content type="text"><![CDATA[现在假设： 12a = 10b = 20 如果需要交换这两个变量的值得话，我们一般会想到的方法是采用引入一个中间变量的方法： 12345a = 10b = 20c = aa = bb = c 那么有没有更加简单，不需要引入第三方变量的方法呢？ 答案自然有，这里介绍两种，一种是语言无关的方法，各种程序设计语言都可以使用；另一种方法则是基于Python的语法糖实现，更为简单，好记！ 方法一： 12345a = 10b = 20a = a + bb = a - ba = a - b 提示：此方法不局限于加减法，乘除法等其他运算皆可 方法二： 123a = 10b = 20a, b = b, a]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
        <category>Python技巧</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>学习</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有用的搜索引擎工具]]></title>
    <url>%2F2018%2F06%2F25%2F%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[学会更好地使用搜索引擎，大大提高使用搜索引擎的效率。推荐使用Google搜索引擎（部分功能仅对Google生效）。 常用关键字intitle：在title标签中 inurl：在URL字串当中 filetype：明确文件类型 site：规定站点范围 日常类工具天气：weather 城市名 汇率：货币一 in 货币二 行程/航程：城市一 to 城市二 倒数计时器：set timer 数字 seconds/minutes/hours 学术绘制函数图像：graph 函数]]></content>
      <categories>
        <category>技巧分享</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>搜索引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python知识学习05——字符串操作]]></title>
    <url>%2F2018%2F06%2F23%2FPython%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A005%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[本篇主要介绍两部分内容： 字符串与数 字符串的常见操作 字符串与数：12345a = 100str(a) # 数转字符串b = "100"int(b) # 字符串转数 求字符串长度： 12a = "1234"len(a) Python字符串拼接的两种方式： 方式一： 123a = "123"b = "456"c = "&lt;" + a + b + "&gt;" 方法二： 123a = "123"b = "456"c = "&lt;%s&gt;"%(a + b) 通过字符串下标获取字符： 12a = "abcde"print(a[1]) 字符串的切片（包头不包尾）： 123&gt;&gt;&gt; a = "abcdefg"&gt;&gt;&gt; a[2: 5]cde 字符串的切片——从第三个取到倒数第二个： 123&gt;&gt;&gt; a = "abcdefg"&gt;&gt;&gt; a[2: -1]cdef 字符串的切片——从第三个取到最后一个： 123&gt;&gt;&gt; a = "abcdefg"&gt;&gt;&gt; a[2: ]cdefg 切片的步长——取下列字符串第二个字符到倒数第二个字符，间隔1个字符： 123&gt;&gt;&gt; a = "123456789"&gt;&gt;&gt; a[1: -1: 2]2468 字符串的逆序： 123&gt;&gt;&gt; a = "123456789"&gt;&gt;&gt; a[-1: :-1]987654321 字符串的逆序——简化： 123&gt;&gt;&gt; a = "123456789"&gt;&gt;&gt; a[: :-1]987654321 字符串的常见操作：find()函数（查找 首次出现位置的下标）： 123&gt;&gt;&gt; myStr = "hello world！"&gt;&gt;&gt; myStr.find("o")4 rfind()函数（查找 最后一次出现位置的下标）： 12&gt;&gt;&gt; myStr = "hello world!"&gt;&gt;&gt; myStr.rfind("o") index()函数（查找对应字符串 首次出现的索引，类似find()） 123&gt;&gt;&gt; myStr = "hello world！"&gt;&gt;&gt; myStr.index("o")4 rindex()函数（查找对应字符串 最后一次出现位置的下标，类似rfind()）： 12&gt;&gt;&gt; myStr = "hello world!"&gt;&gt;&gt; myStr.rindex("o") 提示1：find()和index()函数都不仅仅可以对单个字符使用，还可以对字符串使用 提示2：find()函数若查询无果，返回-1，而index()函数则会报错 count()函数（查找该字符串在另一字符串中的出现次数）： 1234&gt;&gt;&gt; a = "hello, just say hello"&gt;&gt;&gt; b = "hello"&gt;&gt;&gt; print(a.count(b))2 replace()函数（替换）： 123a = "I love Java"b = "Python"a.replace("Java", b) 123a = "I love Java, Java is my love"b = "Python"a.replace("Java", b, 1) 提示：替换并不会修改原字符串，只会把修改后的结果作为返回值返回，因为字符串不可变 split()函数（切割）： 123&gt;&gt;&gt; a = "I love China, China is my country"&gt;&gt;&gt; print(a.split(" "))['I', 'love', 'China,', 'China', 'is', 'my', 'country'] 注意：字符串split缺省参数就是按照空白符分割，多个空格也视为是一个整体的空白字符，只会切割一次 注意：split可以接收第二个参数，代表切割次数 splitlines()函数（切割换行符）： 12&gt;&gt;&gt; '1\r2'.splitlines()['1', '2'] 注意：可以传入True代表保留行分割符，三种行分隔符都已经考虑进去了 capitalize()函数（把字符串第一个字符大写）： 123&gt;&gt;&gt; a = "i love china"&gt;&gt;&gt; a.capitalize()'I love china' title()函数（把字符串每一个单词大写）： 123&gt;&gt;&gt; a = "i love china"&gt;&gt;&gt; a.title()'I Love China' startswith()函数 &amp; endwith()函数（判断字符串是否以某字符串开头或结尾） 123&gt;&gt;&gt; a = "China is a beautiful country"&gt;&gt;&gt; a.startswith("China")True 123&gt;&gt;&gt; a = "China is a beautiful country"&gt;&gt;&gt; a.endswith("China")False lower()函数 &amp; upper()函数（将字符串中的小写/大写字母转换为大写/小写字母） 123&gt;&gt;&gt; a = "AbCdefg"&gt;&gt;&gt; print(a.upper())ABCDEFG 123&gt;&gt;&gt; a = "AbCdefg"&gt;&gt;&gt; print(a.lower())abcdefg 提示：大小写转换并不会修改原字符串，只会把修改后的结果作为返回值返回，因为字符串不可变 center()函数（将字符串用空格填充，字符串居中） 123&gt;&gt;&gt; a = "如果大海能够，带走我的哀愁"&gt;&gt;&gt; a.center(50)' 如果大海能够，带走我的哀愁 ' 提示：并不会修改a，而是以返回值的形式给出修改结果 ljust()函数（将字符串用空格填充，字符串居中） 123&gt;&gt;&gt; a = "就让我用一生等待"&gt;&gt;&gt; a.ljust(50)'就让我用一生等待 ' 提示：同上 rjust()函数（将字符串用空格填充，字符串居中） 123&gt;&gt;&gt; a = "就让我用一生等待"&gt;&gt;&gt; a.rjust(50)' 就让我用一生等待' 提示：同上 以上三个函数也可以使用指定字符进行填充： 1234567891011&gt;&gt;&gt; a = "就让我用一生等待"&gt;&gt;&gt; a.rjust(50, "=")'==========================================就让我用一生等待'``` **lstrip()函数**（去除字符串左边的空白符）```python&gt;&gt;&gt; a = " hello world "&gt;&gt;&gt; a.lstrip()'hello world ' rstrip()函数（去除字符串右边的空白符） 123&gt;&gt;&gt; a = " hello world "&gt;&gt;&gt; a.rstrip()' hello world' strip()函数（去除字符串左右两边的空白符） 123&gt;&gt;&gt; a = " hello world "&gt;&gt;&gt; a.strip()'hello world' partition()函数（以给定字符串为中心，切割原字符串为三个元素的元组） 该函数也较为常用，需要和split()进行对比 123&gt;&gt;&gt; a = "hello world, I love use Java!"&gt;&gt;&gt; a.partition("love")('hello world, I ', 'love', ' use Java!') 提示：以从左到右第一个为准，rpartition()函数则相反，这里不再举例 splitlines()函数（以换行符\n作切割，返回列表） 123&gt;&gt;&gt; a = "窗前明月光，\n疑似地上霜。\n举头望明月，\n低头思故乡。"&gt;&gt;&gt; a.splitlines()['窗前明月光，', '疑似地上霜。', '举头望明月，', '低头思故乡。'] isalpha()函数（判断字符串内容是否是字母） 123&gt;&gt;&gt; a = "abc"&gt;&gt;&gt; a.isalpha()True isdigit()函数（判断字符串内容是否是数字） 123&gt;&gt;&gt; a = "1a2"&gt;&gt;&gt; a.isdigit()False isalnum()函数（判断字符串内容是否仅由数字和字母组成） 123&gt;&gt;&gt; a = "1a2"&gt;&gt;&gt; a.isalnum()True 提示：函数名alnum意为：alpha前两个字母 + num isspace()函数（判断字符串内容是否是纯空格组成） 123&gt;&gt;&gt; a = " 1"&gt;&gt;&gt; a.isspace()False join()函数（用一个字符串连接列表中各个元素，组成新的字符串） 1234&gt;&gt;&gt; a = ["hello", "world", ",", "I", "love", "Java"]&gt;&gt;&gt; b = " "&gt;&gt;&gt; b.join(a)'hello world , I love Java']]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python知识学习04——循环]]></title>
    <url>%2F2018%2F06%2F23%2FPython%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A004%E2%80%94%E2%80%94%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[while循环比如：打印1-10 1234a = 1while a &lt;= 10: print(a) a += 1 这里补充一个Python使用Print()函数输出，实现不换行的方式： 1234a = 1while a &lt;= 5: print(a, end = "") a += 1 小练习：使用Python的while循环打印99乘法表 123456789a = 1b = 1while a &lt;= 9: while b &lt;= a: print("&#123;&#125; * &#123;&#125; = &#123;&#125;".format(b, a, a * b), end = "\t") b += 1 b = 1 a += 1 print("") for循环初见123name = "Tom"for temp in name: print(temp)]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS设置input高度]]></title>
    <url>%2F2018%2F06%2F23%2FMacOS%E8%AE%BE%E7%BD%AEinput%E9%AB%98%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[我们会发现在MacOS下，无论使用Safari还是其他浏览器，都不能修改input的高度。 这是因为Mac OS X系统下的Webkit内核对于表单样式有很强的控制， 所以如果需要自己定义的话，需要重置掉浏览器的默认设置，如下： 123input&#123; -webkit-apperaence: none;&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>前端Fix</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Fix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python知识学习03——Python基础语法3]]></title>
    <url>%2F2018%2F06%2F10%2FPython%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A003%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[关键字查看Python语言当中所有关键字的方法： 12import keywordkeyword.kwlist 运算符1234567891011121314151617181920212223a = 5b = 2# 加法a + b# 减法a - b# 乘法a * b# 幂运算a ** b# 除法a / b# 地板除（去除小数部分）a // b# 取模a % b 补充：在Python当中，不止数值可以乘法，对字符串使用乘法可以起到复制的作用 123&gt;&gt;&gt; a = "Hello"&gt;&gt;&gt; a * 10'HelloHelloHelloHelloHelloHelloHelloHelloHelloHello' print()输出的变量拼接方法一： 12name = "Tom"print("your name is %s"%name) 方法二： 1234name = "Tom"age = 23addr = "江苏南京"print("my name is %s, I'm %d years old, my address is %s"%(name, age, addr)) 提示：这里我们也可以不区分类型，若仅仅是输出变量内容，可以统一使用%s 方法三： 123name = "Tom"age = 20print("my name is &#123;&#125;, I'm &#123;&#125; years old".format(name, age)) 比较运算符基本的比较运算符在这里不做过多的介绍，这里着重介绍一下==和不等于!=或&lt;&gt; 123a = 10b = 10print(a == b) 提示：==代表等于比较运算，而=仅代表赋值运算 1234a = 10b = 20print(a != b)print(a &lt;&gt; b) 提示：不等于符号&lt;&gt;是Python2当中的，在Python3中不能使用 逻辑运算符逻辑运算符包括and、not和orand代表：与or代表：或not代表取反 if语句12345678a = 10b = 30if a == b: print("a和b相等")elif a &gt; b: print("a大于b") else: print("a小于b")]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode001_两数之和]]></title>
    <url>%2F2018%2F06%2F09%2FLeetCode001_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[这是一个记录自己LeetCode算法刷题过程的新系列，以方便日后自己的复习，也能为广大网友朋友提供一些方便。目前LeetCode在国内已经上线了中文版，所以这里我们采用中文版进行记录，这样容易更快理解题干，因为对于解决问题来说，第一步就是充分、正确的理解我们需要做什么。不过我还是会保留英文的原题作为对照，毕竟多掌握一些英语也是很有好处的事情。 本次要记录的题是LeetCode第001题：两数之和 题干：给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice. 示例：给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 解答：最初我想到的解答是比较粗暴的双重循环，但是这样是比较低效的，因为他的时间复杂度是O(n^2)，然后经过网友提醒，使用了 哈希表的方式降低了算法复杂度。代码如下： 12345678910111213141516171819class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; // 声明结果集 int[] result = new int[2]; Map&lt;Integer, Integer&gt; m = new HashMap&lt;&gt;(); int temp = 0; for (int i = 0; i &lt; nums.length; i++) &#123; temp = target - nums[i]; if(m.containsKey(temp))&#123; result[0] = m.get(temp); result[1] = i; break; &#125;else&#123; m.put(nums[i], i); &#125; &#125; return result; &#125;&#125; 原理分析：在通常的contains()验证时，我们需要遍历整个list或数组，因此这里的双重for循环每一层循环的算法复杂度都是O(n)，而不一样的是，Map所使用的hash算法是O(1)的时间复杂度，因此我们可以省去本来的内层循环，算法的执行时间也就这样被降低了。 最终成绩：这里是我跑这个算法的执行结果，仅供大家参考一下：]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法练习</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo本地搜索失效解决办法]]></title>
    <url>%2F2018%2F06%2F09%2FHexo%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2%E5%A4%B1%E6%95%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[起因：最近遇到一个非常奇怪的bug，那就是本来一直非常好用的Hexo博客的搜索功能突然失灵了， 一直处于loading动画，这让我百思不得其解。幸好，经过数小时的各种尝试后，问题已经解决了，这里记录一下解决的方法，帮助后来遇到该问题的同学。 尝试：在尝试过更换浏览器、清空缓存、更换电脑、手机打开均无果之后，一度怀疑是配置文件设置的问题，经历数小时的检查，发现并非配置文件问题，同时受到该篇文章的启发，才想起里查看Chrome的报错信息。 这里是问题解决后才截得图，但是不影响叙述问题的解决流程，这里大致说一下。 解决： 首先通过Chrome浏览器的检查（审查元素）功能，记录一次鼠标点击search或搜索按钮时的请求与响应 然后点击network按钮，进入网络相关模块，并选择all，找到search.xml这一项 然后进入到如上图所示页面，如果这里有问题，或在&lt;entry&gt;标签前说明存在问题的文件，最简单的方法就是先将其移除 总结：该问题主要由于书写的.md文件中包含了一些奇怪的、不合法的字符，导致在解析这些内容时报解析异常错误。该错误最具迷惑性的是http响应状态是 200，使人不会第一时间想到问题的源头，而去从配置文件入手，从而浪费大量时间 补充：出错的字符是一个退格键，在你最近的md文件中，使用正则表达式搜索 \x08 或者 \u0008就行。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Hexo</tag>
        <tag>创建博客</tag>
        <tag>故障解决</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python知识学习02——Python基础语法2]]></title>
    <url>%2F2018%2F06%2F05%2FPython%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A002%E2%80%94%E2%80%94Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[（一）输入语法在Python中，我们可以很简单地接收键盘输入的信息，从而实现用户输入的效果，方法如下： 12name = input("请输入您的姓名：")print("您的名字是：" + name) 注意：字符串拼接仅限于两个（或多个）字符串，如果要将数字类型和字符串拼接，请接着阅读 比如，下面计算年龄的代码就需要用到类型转换才可以正常拼接 12age = input("请输入您的年龄：")print("明年您是" + str(int(age) + 1) + "岁") 因为“age”作为接收的键盘信息，为字符串类型，不能与数字类型的“1”直接相加减，需要使用int()函数进行转换，而计算后的年龄为数字类型，不能与“明年您是”等字符串直接拼接，需要使用str()函数将数值转换为字符串 （二）Python注释我们在书写代码的同时，思路也在脑中运转，这时的我们是清晰得知道每一句代码的意义，以及自己要做什么的。而当我们两个星期以后再来回顾或者修改这些代码时，就需要先花费时间阅读代码，然后才能搞清楚代码的具体逻辑了，更不用谈让别人来阅读我们的代码，所要花费的阅读时间了。 因此，我们需要学会在代码当中添加注释来使代码更加清晰、明了。 在Python当中有多种注释方式，这里将一一展示。 单行注释： 12# 打印“Hello World”print("Hello World") 提示：这里仅仅为了演示，实际上在正式代码当中，应当尽量使代码本身的表达力更强，减少这样没有意义的注释。在这里我们的代码语言已经足够直观到可以直接理解其含义了。因此实际使用注释时，注释应当尽量用来解释逻辑关系 多行注释： 1234'''使用一对三引号，就能实现多行注释。''' 1234"""多行注释可以是单引号也可以使用双引号。""" （三）文件信息既然我们已经学会使用注释了，那么这里就介绍一下我们正常Python代码的头文件信息。我们在编写Python代码时，可以直接在编辑器内书写，但是加上头信息可以使我们的程序更加规范、不易出错。 12345678910#!/usr/bin/env python3# -*- coding: utf-8 -*-"""script to process files@Version : 1.0@Author : SherlockGy@File : HelloWorld.py@Software: PyCharm@Time : 2018/4/4 下午2:28""" 这样的写法可以调用系统环境变量当中配置的python解释器，并且遵循了pep8编码规范。如果我们环境变量当中没有配置python路径，也可以直接显式配置python解释器的位置，不过还是建议使用前者。直接配置python解释器的方法如下（博主电脑中python解释器路径）： 1#!/usr/local/bin/python3 （四）数据类型（1）整数 在Python3当中，整数类型没有上下限，而是决定于系统的内存大小，这里不同于Java语言的int类型和long类型拥有大小限制。在Python当中，所有整数类型，无论大小，都属于int类型，所有的浮点数无论大小，都属于float类型。我们可以通过type()函数获取其类型。 1234&gt;&gt;&gt; a = 12121212121212121212121212121212912012901920192019209102910290192019 ...: 21920192012012&gt;&gt;&gt; type(a)int 123&gt;&gt;&gt; b = 1.2121212121212121212121212121&gt;&gt;&gt; type(b)float 提示：Python当中的整数运算永远是精确运算，而浮点数运算可能存在误差 （2）字符串 之前其实已经介绍过字符串与字符串的拼接，这里就介绍一下字符串的转义吧。在Python中存在一些包含特殊含义的字符串，如\t表示制表符，\n表示换行符，\本身表示转义符。 提示：‘\r’是Mac当中的回车；’\n’是Unix系统中的换行；在这两者中，都可以实现回到行首，从下一行开始的效果。而’\r\n’是Windows系统当中的，先回车，在换行。在Windows中，只回车只会回到行首，不会换行，接着输入就会逐渐替换这一行；只换行会让光标移动到下一行的同样位置，不会回到行首。不过在现在的高级编程语言当中，统一使用\n即可。 比如我们需要得到字符串\n，由于其存在特殊含义，并不能作为正常字符串输出，需要转义。 1print("\\n") 而要得到\也需要对它进行转义。 1print("\\") 而要得到\\就需要对每个\进行分别转义。 1print("\\\\") 这样的书写方法非常没有可读性，且容易出错，因此在Python当中还有一种处理方式： 1print(r"不管是'\t'还是'\r'或者'\n'甚至是'\\'我都可以输出啦") 这个r代表该字符串默认不使用转义。 Python中字符串实现多行打印不一定使用\n，也可以使用这样的方式： 12345print('''床前明月光，疑似地上霜。举头望明月，低头思故乡。''') （3）布尔类型 Python中布尔值分别写作True和False，运算符包括and，or，not。我们必须注意其书写方法，尤其注意大小写。 提示：在Python中，True == 1，False == 0 （4）空值 空值在Python当中表示为None，None和0不同，0是一个普通数字，None为特殊类型，表示空 未完待续…]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客——实现文章阅读全文]]></title>
    <url>%2F2018%2F06%2F03%2FHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E5%85%A8%E6%96%87%2F</url>
    <content type="text"><![CDATA[我们在搭建好博客后，肯定是第一时间写一篇文章测试一下啦！但是细心的你一定会发现一个问题，那就是——主页为什么会展示每一篇文章的所有内容？而不是首页只展示文章的部分内容，再提供一个阅读全文的按钮呢？ 本篇博客就是帮助各个同学实现阅读全文的功能，同时根据自己的使用经验给出意见和建议。要实现阅读全文，目前存在两种方法，我们会一个个讨论，评价其优缺点的。 方法一：配置文件设置首先我们需要找到Hexo所使用主题的主配置文件_config.yml，注意此处不是Hexo的主配置文件，而是主题的。博主所使用的是NexT主题，因此在此以此为例。 方法一是搜索此处的auto_excerpt，将enable改为true，就自动可以对每一篇文章进行分割了，length属性就是定义显示的字符数量。 但是不得不说，很不建议使用此方法，主要原因是： 作者不能灵活控制显示内容，只能固定遵循字数设置 会丢失Markdown语法的格式，只显示纯文本 对！没错！Markdown的格式会全部丢失，所以整个首页的博客预览会非常难看。而主题作者推荐的做法也写的非常明显了，就是在图片中红框当中的内容。 方法二：手动分割文章在文章当中需要分割的位置手动插入以下语句即可： 1&lt;!-- more --&gt; 效果还是很不错的，如图所示：]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Hexo</tag>
        <tag>创建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客——实现主页分页]]></title>
    <url>%2F2018%2F06%2F03%2FHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E2%80%94%E2%80%94%E4%B8%BB%E9%A1%B5%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[我们在搭建完Hexo + Github pages的博客后，会发现他的主页会默认显示很多的文章（默认10篇），而我们也许需要自定义分页进行管理主页博客的显示数量。因此，本教程教会大家，如何设置主页的文章显示数量 首先我们找到Hexo的根配置文件_config.yml，注意不是主题的配置文件。 然后按照下面图片中的内容搜索：per_page，在图片中对应位置修改数字即可 之后我们就可以在我们的博客主页看到分页的效果啦！]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Hexo</tag>
        <tag>分页</tag>
        <tag>创建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python知识学习01——Python基础语法]]></title>
    <url>%2F2018%2F06%2F03%2FPython%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A001%E2%80%94%E2%80%94Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Python是一款非常简单易学的计算机高级编程语言，他拥有强类型、动态性等特性，适合进行web开发、网络爬虫、数据分析、游戏开发、人工智能等多种多样的工作。 在web开发方面，国内的豆瓣、知乎就是采用的Python，游戏开发方面，网易最近出品的很多手游皆是基于Python，在数据分析、人工智能方面Python更是难以多得的一把好手，可以说，现在不学Python，更待何时？ （一）第一个Python程序1print("Hello World!") Python并不强制需要分号结尾，因为Python使用缩进的方式进行代码片段的控制，这一点在稍后还会提到 （二）给Python文件可执行能力该功能仅限Linux、Mac操作系统 首先要在文件头加上这一句话： 1#!/usr/local/bin/python3 提示：这句话的内容是取决于您Python命令所安装的位置的，可以使用which python3命令查找到安装位置 然后，通过命令给hello.py以执行权限： 1$ chmod a+x hello.py 这样，在该Python文件目录下，执行该文件即可 1$ ./test.py 提示：./代表当前目录 （三）简单结果输出使用print函数输出文本到控制台 1print('我是要被输出到控制台的文本') 提示：该处作者故意使用单引号包裹文本，事实上Python字符串不仅可以支持上文的双引号，同样支持单引号表示字符串，但是要注意无论使用哪一种，需要前后统一 使用print函数输出数字到控制台 1print(12345678) 提示：当需要表达输出数字时，则不需要使用引号包裹，因为一旦使用了引号，这就成为了一个字符串，也就不能进行数值计算了，关于数值计算我们后面还会提到 1print(100 + 200) 提示：对于这种计算表达式，输出到控制台上的并不会是：100 + 200因为这里我们输出的不是字符串，而是数值计算的结果 （四）简单字符串拼接与Java等其他很多语言不同，Python字符串拼接更为简单 1print("Tom", "is", "a", "good", "boy") 需要注意的是，在该语句当中，我们并未在双引号当中键入任何空格字符，但是该语句的输出结果却是这样的： Tom is a good boy 这也就是说，这种字符串拼接的方式，不但会拼接各个字符串，还会将各个字符串使用空格符号分隔开来，只要我们稍加发挥，就可以写出这样的代码来： 1print('100 + 200 =', 100 + 200) 我们注意到这行代码的前半段采用了字符串输出的方式，后半段则是数值计算，所以输出的结果自然是： 100 + 200 = 300 提示：读者们可以思考一下，字符串和数值拼接，会不会出现类型不相同的问题呢？学过Java语言的都知道在Java当中数值类型会自动转换为字符串类型，然而在Python语言当中会一直这样吗？这里先存个疑，后面还会再说到 未完待续…]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用来必力为博客添加评论系统]]></title>
    <url>%2F2018%2F06%2F01%2F%E4%BD%BF%E7%94%A8%E6%9D%A5%E5%BF%85%E5%8A%9B%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[我们的个人博客往往需要一个评论系统。目前，多说，网易云跟贴的服务都已经下线了，因此在这里推荐的是使用一款韩国的产品：来必力。 首先我们需要点击这里来注册一个账号。 提示：Chrome（谷歌）浏览器或者其他Chrome内核浏览器可能在验证码阶段出现输入框不显示问题，本环节建议使用火狐浏览器进行操作。 注册成功之后点击最上方的安装，即可获取uid，复制该uid代码。 打开NexT主题的配置文件_config.yml，搜索livere_uid，将livere_uid前面的#号去掉（即：取消注释），然后将我们刚刚复制的uid填写到livere_uid的后面就可以啦。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Hexo</tag>
        <tag>创建博客</tag>
        <tag>来必力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows系统如何关闭Java升级提示]]></title>
    <url>%2F2018%2F05%2F31%2FWindows%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%ADJava%E5%8D%87%E7%BA%A7%E6%8F%90%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[我们有很多同学都是使用Windows系统初学Java的，为了适应当前市场环境的需求，我们几乎不会使用最新版的Java，而依然是Java 1.7、Java 1.8，但是有些同学会发现，Java会总是提示升级，这不是我们希望的。因此，本文将介绍如何关闭Java的升级提示。想要关闭其实也非常简单，首先请打开控制面板：点击Java按钮，然后进入以下界面：只要在这里关闭自动检查更新，并且应用-确定，就OK啦~]]></content>
      <categories>
        <category>程序人生</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用GitHub创建个人博客（Mac篇）]]></title>
    <url>%2F2018%2F05%2F29%2F%E5%88%A9%E7%94%A8GitHub%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88Mac%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、安装Node.JS二、安装Git三、安装Hexo（一）安装1$ sudo npm install -g hexo 提示：加上sudo以使用管理员权限 （二）初始化选定一个存放Blog的目录，在该目录下执行下面的初始化命令： 1hexo init 同样在该目录下，安装npm，请执行以下命令： 1npm install （三）生成静态资源执行命令： 12hexo g 生成public静态资源hexo s 启动本地服务端 在浏览器访问：http://localhost:4000，即可看到博客首页。 四、关联GitHub（一）注册一个GitHub账号（二）创建一个仓库（三）修改配置文件（四）生成SSH Key（1）生成新的SSH key：（引号内的邮箱替换为自己的邮箱1ssh-keygen -t rsa -C "邮箱" （2）运行后结果如下：123456$ ssh-keygen -t rsa -C "swordsmanye@gmail.com"Generating public/private rsa key pair. Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa): 按回车键 Enter passphrase (empty for no passphrase): 输入密码，也可以直接回车Enter same passphrase again: 再次输入密码 （3）拷贝key在~/.ssh目录下就能看到生成的文件，在文件目录下会得到 id_rsa和 id_rsa.pub两个文件，id_rsa.pub文件里存放的就是我们要使用的key. 补充：（一）输入hexo d后出现： ERROR Deployer not found: git执行以下命令即可 1npm install --save hexo-deployer-git （二）解决提交到github报错 Run config : Please tell me who you are执行以下命令： 1git config --global user.email "你的邮箱" 1git config --global user.name "你的名字" 注意：”双引号”前有空格 （三）更换主题（1） 进入themes目录（2） 执行以下命令： 1git clone https://github.com/litten/hexo-theme-yilia.git （3） 编辑_config.yml文件修改theme: hexo-theme-yilia 补充：注意冒号后面有空格 （4） 在hexo-theme-yilia目录下执行命令： 1git pull origin master 依次执行hexo g，hexo d命令，完成修改]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Hexo</tag>
        <tag>创建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TestBlog]]></title>
    <url>%2F2018%2F05%2F28%2FTestBlog%2F</url>
    <content type="text"><![CDATA[这是一个测试!]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
